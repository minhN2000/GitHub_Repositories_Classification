plt,Programming Language Theory λΠ,4896,https://github.com/steshaw/plt,main,['index.md']
the-rust-programming-language-ja,Rust文書の【旧】和訳レポジトリ → 最新版はこちら： https://github.com/rust-lang-ja/book-ja,354,https://github.com/rust-lang-ja/the-rust-programming-language-ja,master,['# Rust文書の和訳リポジトリ [![CircleCI](https://circleci.com/gh/rust-lang-ja/the-rust-programming-language-ja.svg?style=svg)](https://circleci.com/gh/rust-lang-ja/the-rust-programming-language-ja)\n\n[TRPL](https://doc.rust-lang.org/book/)を主としたRustドキュメントの翻訳プロジェクトです。\n余力があれば他の文書の翻訳もするかもしれません。\n\n飜訳文書は[こちら](http://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/book/)にあります。\n\n## ビルド方法\n\n`rustbook`コマンドが必要です。\n\n```\nmake RUSTBOOK=/path/to/rustbook\n```\n\n`rustbook`コマンドのインストール方法については、Wikiページの「[rustbookのインストール方法](https://github.com/rust-lang-ja/the-rust-programming-language-ja/wiki/rustbook%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E6%96%B9%E6%B3%95)」を参照してください。\n\n## CI 継続的インテグレーション\n\n本リポジトリでは、CIサービスを活用し、PR（プルリクエスト）に対してHTMLの自動生成を行っています。詳しくはWikiページの「[CI 継続的インテグレーション](https://github.com/rust-lang-ja/the-rust-programming-language-ja/wiki/CI-%E7%B6%99%E7%B6%9A%E7%9A%84%E3%82%A4%E3%83%B3%E3%83%86%E3%82%B0%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3)」を参照してください。\n\n## ライセンス\n\n元のドキュメントはRustのソースと同じくApache2.0とMITのデュアルライセンスです。\n\n翻訳ドキュメントも同じくApache2.0とMITのデュアルライセンスとします。\n']
gobook,The Go Programming Language,363,https://github.com/qiniu/gobook,master,['# 介绍\n\n这里是《GO语言编程》一书中示例源代码。\n\n# 环境配置\n\n1) 安装 go1\n\n2) 打开 ~/.bashrc，加入： \n\n    export $GOBOOK=~/gobook  #假设代码在 ~/gobook 下\n    source $GOBOOK/env.sh\n\n3) 保存 ~/.bashrc，并 source 之\n\n# 运行代码\n\n对于单文件程序，如sample.go，直接运行go run sample.go即可。\n\n对于多文件的复杂样例，直接 go run 主程序文件即可。\n']
go-internals,dig into implemention of the go programming language,1755,https://github.com/tiancaiamao/go-internals,master,['# 《深入解析Go》\n因为自己对Go底层的东西比较感兴趣，所以抽空在写一本开源的书籍《深入解析Go》。写这本书不表示我能力很强，而是我愿意分享，和大家一起分享对Go语言的内部实现的一些研究。\n\n我一直认为知识是用来分享的，让更多的人分享自己拥有的一切知识这个才是人生最大的快乐。\n\n这本书目前我放在Github上，时间有限、能力有限，所以希望更多的朋友参与到这个开源项目中来。\n\n## 参与到本项目\n\n如果对某些章节很有兴趣，可以写作相应章节的内容并pull request给我。如果觉得有哪些相关的内容缺失，欢迎提出。如果发现书中内容有错误或者疏漏，欢迎指正。\n\n不管任何形式的参与都是非常受欢迎的。\n\n## 致谢\n先留空\n\n## 授权许可\n除特别声明外，本书中的内容使用[CC BY-SA 4.0 License](http://creativecommons.org/licenses/by-sa/4.0/)（创作共用 署名-相同方式共享4.0许可协议）授权，代码遵循[BSD 3-Clause License](<https://github.com/astaxie/build-web-application-with-golang/blob/master/LICENSE.md>)（3项条款的BSD许可协议）。\n\n## 开始阅读\n[开始阅读](http://tiancaiamao.gitbooks.io/go-internals/content/zh/index.html)\n']
The-Swift-2.0-Programming-Language-playground,对应最新发布《The Swift Programming Language》Swift 2.0 一书中的内容。这些playground基本是书中知识点的一个总结。,465,https://github.com/mengxiangyue/The-Swift-2.0-Programming-Language-playground,master,['# The-Swift-2.0-Programming-Language-playground\n对应最新发布《The Swift Programming Language》Swift 2.0 版本一书中内容。这些Playground基本是书中知识点的一个总结，如果不想看英文书的人看这些Palyground都看完了，也基本算是看完了书中的内容。  \n\n如果你感觉该项目不错，麻烦点下star，支持一下，谢谢！\n\n本人后续计划根据这些Playground制作一套入门的视频，希望能够帮助到一部分人入门Swift。  \n\n视频已经开始录制了：   \n\t在线播放地址:<http://edu.csdn.net/course/detail/1380>   \n\t百度网盘地址：<http://pan.baidu.com/s/1o67Xtz0>\n\n本人也是一个菜鸟，在整理的时候难免会有错误的地方，欢迎大家拍砖。\n\n本人 孟祥月  \n博客：<http://blog.csdn.net/mengxiangyue>  \n微博：[@孟祥月](http://weibo.com/u/1750643861)  \nSwift技术交流群 QQ群：247617797\n']
book,The Rust Programming Language,236,https://github.com/rust-lang-ru/book,master,['# Язык программирования Rust (The Rust Programming Language)\n\nВ данном репозитории содержится перевод книги [The Rust Programming Language](https://github.com/rust-lang/book).\n\n## Зачем ещё один репозиторий?\n\nЭтот репозиторий подключён к системе перевода и вся работа ведётся там.\nСама система перевода нужна для отслеживания изменений в оригинале книги и\nза счёт этого становится более удобной поддержка перевода, так как не надо\nсамому переводчику искать что изменилось - система сама это показывает.\n\n## GitLocalize\n\nПроект на GitLocalize: https://gitlocalize.com/repo/4579\n\n## Правила участия в переводе\n\nПравила участия в переводе описаны в [этом документе](https://github.com/rust-lang-ru/book/blob/master/CONTRIBUTING.md).\n']
Blawn,Pleasant Programming Language.,755,https://github.com/Naotonosato/Blawn,master,["# Blawn\nI'm developing [Clawn](https://github.com/Naotonosato/Clawn) now.\n"]
write-a-programming-language-in-450-lines,本教程教大家用 450 行 Go 代码实现一个简单的编程语言,470,https://github.com/karminski/write-a-programming-language-in-450-lines,main,['牙医教你 450 行代码自制编程语言\n-----------------------------\n\n# Description\n\n没有系统学习过编译原理的同学可能会很好奇编程语言的编译器, Lexer & Parser, 虚拟机是怎么实现的. 而又苦于系统性的教材过于枯燥.  \n\n本教程教大家用 450 行 Go 代码实现一个简单的编程语言, 它的语法是这样的:  \n\n```php\n$a = "pen pineapple apple pen."\nprint($a)\n```\n\n看上去很简单是不是? 但是它包含了个手写的递归下降解析器和一个简单的解释器.   \n\n虽然该语言甚至不是图灵完备的. 但写这个语言和教程的主要目的是让编译原理初学者有一个预热, 简单了解一个编程语言是怎么构建的.  \n\n准备好了吗? 让我们开始!  \n\n\n# Markdown\n\n建议直接看用 Markdown 编写的原始版本, PDF 生成的不是很好:\n\n- [牙医教你 450 行代码自制编程语言 - 1, 从 EBNF 开始](./DOCUMENTS/part-1-start-from-ebnf/part-1-start-from-ebnf.md)\n- [牙医教你 450 行代码自制编程语言 - 2, 两个魔法就可以实现永动机](./DOCUMENTS/part-2-two-magic/part-2-two-magic.md)\n- [牙医教你 450 行代码自制编程语言 - 3, 实现 Lexer 上篇](./DOCUMENTS/part-3-create-a-lexer/part-3-create-a-lexer.md)\n- [牙医教你 450 行代码自制编程语言 - 4, 实现 Lexer 下篇](./DOCUMENTS/part-4-create-a-lexer/part-4-create-a-lexer.md)\n- [牙医教你 450 行代码自制编程语言 - 5, 递归下降语法解析器](./DOCUMENTS/part-5-parser/part-5-parser.md)\n- [牙医教你 450 行代码自制编程语言 - 6, 后端](./DOCUMENTS/part-6-backend/part-6-backend.md)\n- [牙医教你 450 行代码自制编程语言 - 7, 后续该如何学习编译原理](./DOCUMENTS/part-7-how-to-learn/part-7-how-to-learn.md)\n\n\n# PDF \n\n- [或者戳这里直接看PDF版本](./pdf/write-a-programming-language-in-450-lines.pdf)\n\n\n# 示例代码\n\n- [Go 版本: pineapple](https://github.com/karminski/pineapple).\n- [Python 版本: pineapple-py](https://github.com/KevinXuxuxu/pineapple-py) 由 [KevinXuxuxu](https://github.com/KevinXuxuxu) 贡献.\n- [TypeScript 版本: pineapple-ts](https://github.com/liulinboyi/pineapple-ts) 由 [liulinboyi](https://github.com/liulinboyi) 贡献.\n- [Dart 版本: dart-pineapple](https://github.com/damonchen/dart-pineapple) 由 [damonchen](https://github.com/damonchen) 贡献.\n- [Java 版本: pineapple-java](https://github.com/LionCoder4ever/pineapple-java) 由 [LionCoder4ever](https://github.com/LionCoder4ever) 贡献.\n- [Java 版本 2: pineapple-java](https://github.com/xiaofine1122/pineapple-java) 由 [xiaofine1122](https://github.com/xiaofine1122) 贡献.\n- [Ruby 版本: pineapple-ruby](https://github.com/YoogoC/pineapple-ruby) 由 [YoogoC](https://github.com/YoogoC) 贡献.\n- [C# 版本: pineapple-csharp](https://github.com/KamioRinn/pineapple-csharp), 由 [KamioRinn](https://github.com/KamioRinn) 贡献.\n- [Rust 版本: pineapple-rs](https://github.com/Max-astro/pineapple-rs), 由 [Max-astro](https://github.com/Max-astro) 贡献.\n- [Scala 版本: pineapple-scala](https://github.com/lzy0505/pineapple-scala), 由 [lzy0505](https://github.com/lzy0505) 贡献.\n- [F# 版本: pineapple-fsharp](https://github.com/Nomyfan/pineapple-fsharp), 由 [Nomyfan](https://github.com/Nomyfan) 贡献. \n\n\n# Author\n\n[karminski-牙医](https://github.com/karminski)  \n\n\n# License \n\n[CC BY-NC-ND 4.0](https://creativecommons.org/licenses/by-nc-nd/4.0/)\n\n您可以自由地:  \n\n共享 - 在任何媒介以任何形式复制, 发行本作品  \n\n只要你遵守许可协议条款, 许可人就无法收回你的这些权利.  \n\n惟须遵守下列条件： \n\n署名 - 您必须给出适当的署名, 提供指向本许可协议的链接, 同时标明是否 (对原始作品) 作了修改. 您可以用任何合理的方式来署名, 但是不得以任何方式暗示许可人为您或您的使用背书.  \n\n非商业性使用 - 您不得将本作品用于商业目的.  \n\n禁止演绎 - 如果您 再混合, 转换, 或者基于该作品创作, 您不可以分发修改作品.  \n\n']
ceu,The Programming Language Céu,200,https://github.com/ceu-lang/ceu,master,['Céu is a reactive language that aims to offer a higher-level and safer \nalternative to C.\n\nTry it online:\n\nhttp://www.ceu-lang.org/\n\nDocumentation:\n\nhttp://ceu-lang.github.io/ceu/\n\nSource code:\n\nhttps://github.com/ceu-lang/ceu/\n\nJoin our chat:\n\nhttps://gitter.im/fsantanna/ceu\n\n<!--\n# WHY CÉU\n\n`TODO`\n-->\n\n# INSTALLATION\n\n## Install required software:\n\n```\n$ sudo apt-get install git lua5.3 lua-lpeg liblua5.3-0 liblua5.3-dev\n```\n\n(Assuming a Linux/Ubuntu machine.)\n\n## Clone the repository of Céu:\n\n```\n$ git clone https://github.com/ceu-lang/ceu\n$ cd ceu/\n```\n\n## Install Céu:\n\n```\n$ make\n$ sudo make install     # install as "/usr/local/bin/ceu"\n```\n\n## Run the tests (optional):\n\n```\n$ cd tst/\n$ ./run.lua\n```\n\n## Run the examples\n\n```\n$ make samples\n```\n']
Kuin,Kuin Programming Language,266,https://github.com/kuina/Kuin,develop,["# Kuin Programming Language\r\nプログラミング言語「Kuin」\r\n\r\n## [English]  \r\n  \r\n***-- Welcome to the Labyrinth of Kuin Compiler,***  \r\n***where many programmers who challenged to read the code never came back. --***  \r\n  \r\nThis is the git repository for the Kuin programming language, developed by Kuina-chan.  \r\n  \r\nAll the files here are provided under the Kuina-chan License.  \r\nIf you have any questions, please let me know in English or Japanese.  \r\n  \r\nKuina-chan's website: <https://kuina.ch>  \r\nKuina-chan's twitter account: <https://twitter.com/kuina_ch> (@kuina_ch)  \r\n  \r\n## [Japanese]  \r\n  \r\n***――Kuinコンパイラの迷宮へようこそ。***  \r\n***ここは、読解に挑んだ多くのプログラマが帰らぬこととなった場所です――。***  \r\n  \r\n「くいなちゃん」が開発するプログラミング言語「Kuin」( <https://kuina.ch/kuin> )のリポジトリです。  \r\n  \r\n#### # 報告の方法  \r\n不具合の報告や機能追加を要望したい場合は、下記の方法で行うことができます。  \r\n* 開発者(くいなちゃん)に日本語か英語で直接報告する。  \r\n* リポジトリをForkして編集した後Pull Requestをくいなちゃん宛てに送る。  \r\n* 修正したソースコードの断片をどこかにアップロードしてくいなちゃんに知らせる。  \r\n戴いたソースコードはわたしが検査して適宜修正しますので、不具合やコーディングルールの不統一があっても問題ありません。  \r\n  \r\n#### # ビルド方法  \r\nKuinコンパイラを手元でビルドする場合には、Visual C++ 2019が必要です。  \r\n  \r\n/build/deploy_for_exe.batを実行すると、以下の段階を経て/build/deploy_exe_ja内にKuinコンパイラ及びKuinエディタが生成されます。  \r\n1. 仮のKuinコンパイラ(/build/kuincl.exe)を使って、/src/compilerのソースからKuinコンパイラが/build/output/kuin.exeに生成されます。  \r\n2. 生成されたコンパイラを使って、/src/compilerのソースからC++のKuinコンパイラ(/build/output/kuin_cpp_ja.cppおよび/build/output/kuin_dll_ja.cpp)が生成されます。  \r\n3. Visual C++を使って、C++のKuinコンパイラから最終的なKuinコンパイラ/build/deploy_exe_ja/kuincl.exeが生成されます。  \r\nC++を経ているのは、Visual C++の強力な最適化によってパフォーマンスを高めるためです。  \r\n4. 最終的なKuinコンパイラを使って、/src/kuin_editorのソースからKuinエディタが/build/deploy_exe_ja/kuin.exeに生成されます。  \r\n  \r\nその後、/build/deploy_exe_ja/内の全ファイルを/build/package_ja/内にコピーすると、パッケージが完成します。  \r\n  \r\nすべてのファイルは「くいなちゃんライセンス( <https://kuina.ch/others/license> )」でご自由にお使いいただけます。  \r\nその他、あらゆるご質問はくいなちゃんまでどうぞ。  \r\n  \r\nWebサイト: <https://kuina.ch>  \r\nTwitterアカウント: <https://twitter.com/kuina_ch> (@kuina_ch)  \r\n"]
larva-lang,The larva programming Language,143,https://github.com/larva-lang/larva-lang,master,['# ***larva-lang***\n\n一个用go做后端的语言\n\n## **特点**\n\n1. 语法贴近C++、Java、C#这一系列，吸收了Go中个人认为较好的一些设计，静态类型，编译到Go语言代码，后端利用Go的工具和环境\n\n1. 对Go语言语法较为晦涩或不太符合习惯的地方做了修改，例如类型系统采用Java和C#的方式（对象用引用传递）；将Go的匿名包含改成了类似的usemethod机制；\n等等\n\n1. 除语法的区别外，对Go语言的一些不足之处做了补充，例如支持泛型类和泛型函数，且实现方式为编译期展开（类似C++模板的处理），基本无性能损耗\n\n1. Larva源代码和Go语言目标代码的对应规则简单明了，Native代码采用嵌入式设计，但lib代码还是尽量会采用Larva自身实现\n\n## **如何使用？**\n\n* 文档已在逐步开发中，请访问doc目录阅读细节\n\n## **大体进度和TODO**\n\n1. 语法基本完成，编译器和runtime的剩余主要工作就是测试和修复bug，会根据具体情况调整语法\n\n1. 需补充必要的标准库\n\n1. 需补充文档\n\n## **近期计划**\n\n1. 补充文档\n1. 补充示例和测试用例\n1. 补充基础库\n\n## **有问题联系**\n\n* github：maopao-691515082\n\n* QQ：691515082\n\n* zhihu：[冒泡](https://www.zhihu.com/people/xtlisk)\n']
Yampa,Functional Reactive Programming domain-specific language  for efficient hybrid systems,362,https://github.com/ivanperez-keera/Yampa,develop,['yampa/README.md']
elixir-examples.github.io,A collection of elixir programming language examples.,189,https://github.com/elixir-examples/elixir-examples.github.io,master,['## Elixir Examples\nA collection a elixir programming language examples.\n\nWebsite: <https://elixir-examples.github.io/>\n\n### Contributing\nPlease submit a pull request or issue.\n\n### License\n[![CC0](https://i.creativecommons.org/p/zero/1.0/88x31.png)](https://creativecommons.org/publicdomain/zero/1.0/)\n']
rust_book_ru,The Rust Programming Language на русском языке,189,https://github.com/rust-lang-ru/rust_book_ru,master,['# Введение к русскоязычному переводу\n\n**ВНИМАНИЕ!** Это перевод первого издания. Сейчас перевод заморожен, как и оригинал. Дальнейшая работа - [перевод второго издания](https://github.com/ruRust/community/issues/3).\n\n**Issues и Pull Requests здесь больше не принимаются.**\n\nЭта книга представляет собой перевод «The Rust Programming Language». Оригинал\nкниги расположен [здесь][original].\n\nПеревод окончен и соответствует stable версии книги на момент выхода Rust 1.2 stable.\nМогут встречаться несоответсвия оригиналу книги, но написанное здесь актуально\nдля любого Rust 1.x, поскольку Rust гарантирует стабильность языка в пределах \nмажорной версии.\n\n* [Читать книгу](http://ruRust.github.io/rust_book_ru/)\n* [Скачать в PDF](https://raw.githubusercontent.com/ruRust/rust_book_ru/gh-pages/converted/rustbook.pdf)\n* [Скачать в EPUB](https://raw.githubusercontent.com/ruRust/rust_book_ru/gh-pages/converted/rustbook.epub)\n* [Скачать в MOBI](https://raw.githubusercontent.com/ruRust/rust_book_ru/gh-pages/converted/rustbook.mobi)\n\n# Полезные ссылки\n\nЧаты                                   | Ссылки\n---------------------------------------|--------\nдля обсуждения языка, получения помощи | [![Join the chat at https://gitter.im/ruRust/general](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/ruRust/general?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\nдля обсуждения самой книги и вопросов перевода | [![Join the chat at https://gitter.im/ruRust/rust_book_ru](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/ruRust/rust_book_ru?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n[![ruRust/rust_book_ru](http://issuestats.com/github/ruRust/rust_book_ru/badge/pr?style=flat)](http://issuestats.com/github/ruRust/rust_book_ru)\n[![ruRust/rust_book_ru](http://issuestats.com/github/ruRust/rust_book_ru/badge/issue?style=flat)](http://issuestats.com/github/ruRust/rust_book_ru)\n\n[Мы на Хабре](http://habrahabr.ru/post/266813/)\n\n# Соавторам\n\n## С чего начать\n\nЕсть некоторое количество очень простых проблем. Это\n[опечатки](https://github.com/ruRust/rust_book_ru/labels/%D0%BE%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%BA%D0%B0),\nи, взяв одну из таких задач, вы сможете легко поучаствовать в переводе\nи очень нам поможете.\n\nНе бойтесь code review, у нас не принято наезжать на новичков. :smile:\n\n## Сборка\n\nЕсли вы занялись инфраструктурой, вам понадобится проверять свою работу\nлокально.\n\nСейчас самый простой способ собрать книгу локально - это проделать те же действия, что\nделает Travis. Смотрите файл `.travis.yml`, разделы `install`, `before_script`,\n`script`, `after_success`. Они должны быть достаточно понятны сами по себе.\n\n## Тестирование\n\nЕсли вы изменили инфраструктуру, следует проверить изменения. Проверка зависит\nот компонента, в который вы внесли изменение.\n\nЕсли это стили и генерация книги - нужно сгенерировать книгу локально и\nпосмотреть, что всё работает как надо. Конвейер преобразования HTML-версии в\nдругие варианты проверяется так же.\n\nЕсли вы внесли изменения в скрипты, вызываемые Travis, или в сам `.travis.yaml`,\nпожалуйста, следите за статусом сборки - он отображается в PR. PR, который не\nпроходит сборку, принят не будет.\n\n## Где получить помощь\n\nУ этого репозитория есть чат-комната на Gitter. Если у вас возник\nвопрос по задаче или по тому, что вы взялись делать, как перевести\nкакой-то термин или как собрать книгу локально - вам\n[сюда](https://gitter.im/ruRust/rust_book_ru).\n\n## Для опытных\n\n[Правила перевода](https://github.com/ruRust/rust_book_ru/wiki/Правила).\n\n## Благодарности\n\nВыражаем благодарность [всем, кто принимал участие в создании этой\nкниги][authors].\n\nОт @kgv: «Хочу поблагодарить моих родителей: **Таню** и **Володю**. Без них не\nбыло бы этой книги».\n\n## Ошибки\n\nЕсли вы встретили ошибку или неточность, пожалуйста, [напишите о ней][error].\n\n## Ресурсы\n\n* rustbook расположен [здесь][rustbook]\n* репозиторий расположен [здесь][github]\n\n[authors]: https://github.com/ruRust/rust_book_ru/blob/master/AUTHORS.md\n[original]: https://doc.rust-lang.org/book\n[github]: https://github.com/ruRust/rust_book_ru\n[error]: https://github.com/ruRust/rust_book_ru/issues\n[rustbook]: http://ruRust.github.io/rust_book_ru\n']
nadesiko3,Japanese Programming Language Nadesiko v3 (JavaScript),188,https://github.com/kujirahand/nadesiko3,master,['# 日本語プログラミング言語「なでしこ3」\n\n[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg?style=flat)](LICENSE)\n[![npm version](https://badge.fury.io/js/nadesiko3.svg)](https://www.npmjs.com/package/nadesiko3)\n![Node.js CI](https://github.com/kujirahand/nadesiko3/workflows/Node.js%20CI/badge.svg)\n\n## 「なでしこ3」とは\n\n「なでしこ3」とは、日本語のプログラミング言語です。HTML5/JavaScript(TypeScript)をベースとしているので、PC/スマホ/タブレットなど、さまざまな環境で動作させることができます。日本語プログラミング言語は、読みやすく理解しやすいのが特徴で、初めてでも楽しくプログラミングを覚えることができます。また、バッチ処理や定型処理などを手軽に記述できます。\n\n- [なでしこのWebサイト](https://nadesi.com/top/)\n- [なでしこ3のGitHub Pages](https://kujirahand.github.io/nadesiko3/)\n- [マニュアル](https://nadesi.com/v3/doc/)\n\n## 対応機器/ブラウザ\n\n主要ブラウザ(Chrome/Safari/Edge/Firefox)に対応しています。詳しくは、[対応機器/ブラウザ](doc/browsers.md) をご覧ください。\n\n## ブラウザで利用する場合\n\n以下、Webエディタ上で、なでしこを実行できます。\n\n- [なでしこ3簡易エディタ](https://nadesi.com/doc3/index.php?%E3%81%AA%E3%81%A7%E3%81%97%E3%81%933%E7%B0%A1%E6%98%93%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF)\n  - [なでしこ3貯蔵庫(プログラム一覧)](https://n3s.nadesi.com/)\n  - [なでしこエディタの一覧](https://nadesi.com/doc3/index.php?%E3%81%AA%E3%81%A7%E3%81%97%E3%81%933%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E3%81%AE%E4%B8%80%E8%A6%A7)\n\n## 各OSごとに利用する方法\n\nなでしこ3をPC向けにローカル環境で動作させることも可能です。\n\n- [OS別のインストール方法](https://nadesi.com/doc3/index.php?OS%E5%88%A5)\n\n## npm でなでしこ3コマンドライン版をインストール\n\n先にNode.jsをインストールします。\n次いで、コマンドラインから以下のコマンドを実行します。\n\n```bash\nnpm install -g nadesiko3\n```\n\nすると、cnako3というコマンドで、なでしこを利用できます。\n\n```bash\n# なでしこのサーバーを起動\nnpm start\n# なでしこエディタ(PC版)を起動\nnpm run nako3edit\n# なでしこエディタ(WEB版)を起動\nnpm run nako3server\n```\n\n> Node.jsの推奨バージョンは、v14以上です。\n\n## Gitからインストール\n\nまた、以下のコマンドを実行すると、なでしこの開発環境をセットアップできます。\n\n```bash\ngit clone --recursive https://github.com/kujirahand/nadesiko3.git\ncd nadesiko3\nnpm install\n```\n\nサブモジュールとして[`nadesiko3core`](https://github.com/kujirahand/nadesiko3core)を利用するので、`--recursive` を付け忘れたら以下のコマンドを実行して、サブモジュールも取得してください。\n\n```bash\n# 以下のように --recursive 付け忘れた場合\ngit clone https://github.com/kujirahand/nadesiko3.git\ncd nadesiko3\n# サブモジュールを取得する\ngit submodule update --init --recursive\n```\n\n## Ubuntuへの開発環境のセットアップ\n\nまっさらなUbuntu22.04でなでしこ3の開発環境を整える場合は以下のコマンドを実行します。\n\n```\nsudo apt update\n# nvm で Node.js をインストール\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash\nsource ~/.bashrc\nnvm install v18.12.1\n# リポジトリのセットアップ\ngit clone --recursive https://github.com/kujirahand/nadesiko3.git\ncd nadesiko3\nnpm install\n# なでしこ3のビルド\nnpm run build\n# 『圧縮』『解凍』命令のために\nsudo apt install -y p7zip-full\n# cnako3をパスに追加する\n```\n\n## 追加インストール(macOS/Linux)\n\n必要に応じて以下のコマンドをインストールします。\n\nmacOS:\n\n```bash\n# 『圧縮』『解凍』命令のために\nbrew install p7zip\n```\n\nUbuntu/Debian:\n\n```bash\n# 『圧縮』『解凍』命令のために\nsudo apt install p7zip-full\n# 『キー送信』命令のために\nsudo apt install xdotool\n```\n\n全てのコマンドが正しく動くかを確認するには、以下のコマンドを実行します。\n\n```bash\nnpm test\nnpm run test:all\n```\n\n## なでしこの開発履歴\n\n「なでしこ3」の開発は2017年に始まり、以後コツコツとバージョンアップを続けています。\n「誰でも簡単プログラマー」の目標を実現するために、これからも頑張ります。\n\n- (2022-05-19) v3.3.18でJavaScriptからTypeScriptへ変更。言語コアを別リポジトリに移動\n- (2022-04-20) v3.3.2を公開(モジュール構造をCommonJS→ESModuleへ変更/asyncFnの実装)\n- (2021-04-09) v3.2.1を公開\n- (2020-04-24) v3.1.2を公開\n- (2017-12-29) v3.0.19を公開(無名関数の「には」構文の実装など)\n- (2017-06-25) 内部構造を大幅に修正(PEGパーサーから独自のパーサーに変更)\n- (2017-02-13) なでしこ3のプロジェクトが開始\n- (2004-08-01) ひまわり2としてゼロからなでしこv1の開発が開始\n\n## なでしこ3の開発に参加する\n\nなでしこ3自身を開発するために、開発環境を整えようという方は、 [doc/SETUP.md](doc/SETUP.md) をご覧ください。\nまた、なでしこ3開発者向けの[Gitter](https://gitter.im/nadesiko3/community)への参加も可能です。\n\n## 関連リポジトリへのリンク\n\n- [なでしこ3開発リポジトリ(GitHub)](https://github.com/kujirahand/nadesiko3/)\n- [なでしこ3拡張プラグイン](https://nadesi.com/v3/doc/index.php?FAQ%2F%E6%8B%A1%E5%BC%B5%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6&show)\n  - [nadesiko3-server](https://github.com/kujirahand/nadesiko3-server) --- Webサーバ(HTTP)\n  - [nadesiko3-websocket](https://github.com/kujirahand/nadesiko3-websocket) --- WebSocket\n  - [nadesiko3-office](https://github.com/kujirahand/nadesiko3-office) --- Excelなど\n  - [nadesiko3-sqlite3](https://github.com/kujirahand/nadesiko3-sqlite3/) --- SQLite3\n  - [nadesiko3-tools](https://github.com/kujirahand/nadesiko3-tools) --- 便利ツール\n  - [nadesiko3-mecab](https://github.com/kujirahand/nadesiko3-mecab/) --- 形態素解析(MeCab)\n  - [nadesiko3-htmlparser](https://github.com/kujirahand/nadesiko3-htmlparser) --- スクレイピング\n  - [nadesiko3-ml](https://github.com/kujirahand/nadesiko3-ml/) --- 機械学習\n  - [nadesiko3-odbc](https://github.com/kujirahand/nadesiko3-odbc) --- データベース(ODBC)\n  - [nadesiko3-mysql](https://github.com/kujirahand/nadesiko3-mysql) --- データベースMySQL\n  - [nadesiko3-postgresql](https://github.com/kujirahand/nadesiko3-postgresql) --- データベースPostgreSQL\n  - [nadesiko3-mssql](https://github.com/kujirahand/nadesiko3-mssql) --- データベースmssql\n- 配布用パッケージ\n  - [nadesiko3webkit - なでしこ3軽量配布キット(webkit版)](https://github.com/kujirahand/nadesiko3webkit)\n  - [nadesiko3electron - なでしこ3フル配布キット(electron版)](https://github.com/kujirahand/nadesiko3electron)\n  - [nadesiko3win32 - なでしこ3(コンソール版)のWindows配布パッケージ](https://github.com/kujirahand/nadesiko3win32/releases)\n- サーバーサイドJavaScriptエンジン用の実装\n  - [nadesiko3(Node.js)](https://github.com/kujirahand/nadesiko3)\n  - [nadesiko3(Deno)](https://github.com/kujirahand/nadesiko3deno)\n- 実験的に別言語で実装したなでしこ3\n  - [nadesiko3php - なでしこ3PHP](https://github.com/kujirahand/nadesiko3php)\n  - [nadesiko3rust - なでしこ3Rust](https://github.com/kujirahand/nadesiko3rust)\n  - [nadesiko3go - なでしこ3Go言語](https://github.com/kujirahand/nadesiko3go)\n- 本リポジトリのサブモジュール\n  - [nadesiko3core](https://github.com/kujirahand/nadesiko3core/) --- 言語コア\n']
bato,Ang Bato ay isang programming language sa wikang Filipino,314,https://github.com/jjuliano/bato,master,['# Bato\n\nAng **Bato Programming Language** ay isang scripting language sa wikang\n*Filipino*.\n\nAng layunin ng proyektong ito ay upang mag turo ng *Computer Programming* sa\nwikang *Filipino*, sa madaling maintindihang wika upang matutuhan ito.\n\nSubukan ang [Bato *interactive online console*](https://trybato.herokuapp.com/).\n\n## Media\n\n* Yukihiro Matzumoto (Chief Designer of Ruby) - https://twitter.com/yukihiro_matz/status/962193256929832960\n* The Register - https://www.theregister.co.uk/2018/03/21/philippines_ruby_bato\n* Speed Magazine - https://www.speedmagazine.ph/bato-tagalog-programming-language-by-joel-bryan-juliano/\n* University of the Philippines (UPLB Mathematical Sciences Society) - https://twitter.com/uplbmass1973/status/1429684834511716355\n* De La Salle University (Access DLSU) - https://www.facebook.com/AccessDLSU/posts/1666465890181933\n* San Beda University (BITS San Beda) - https://www.facebook.com/BITSSanBeda/photos/a.476052709434852/1391553414551439\n* Philippine Web Design Organization (Form Function Class) - https://twitter.com/ffcph/status/1015212784089534464\n* FullStack HQ - https://twitter.com/fullstackhq/status/1429035930640388106\n* Programmer Ako - https://www.facebook.com/ProgrammerLang/posts/808487952978981\n* Algo Filipino - https://www.facebook.com/AlgoFilipino/posts/149472316929258\n* Binalatongan Community College (BITS) - https://www.facebook.com/BinalatonganCommunityCollegeBITS/posts/207649374632071\n* Philippine Insider TV (YouTube) - https://www.facebook.com/philippineinsidertv/posts/186868113430790\n* Jeck\'s Tech Nook - https://www.facebook.com/jeck.tech.nook/posts/442902100786391\n* YCombinator Hacker News - https://twitter.com/hnbot/status/951816054161977344\n\n## Pagtatalaga\n\nKailangan mo munang *i-install* ang Ruby programming language (version 3.0.1 o mas\nbago) at pagkatapos maitalaga ang Ruby, *i-run* naman ito\n\n```shell\ngem install bato\n```\n\n## Bakit Bato?\n\nAng **bato** ay hango sa [Ruby Programming Language](http://www.ruby-lang.org/)\nna may *Filipino* sintaks. Ang kadahilanang ginamit ang pangalang \'bato\' ay\ndahil ang Ruby ay isang uri ng bato.\n\n## Ang unang program\n\nGumawa ng isang file na `kamusta_mundo.bt` na may mga sumusunod na nilalaman\n\n```ruby\nkapag 1 > 0\n  mag_print "Kumusta mundo!"\nkung_hindi\n  mag_print "Mayroong sira"\nwakas\n```\n\nat pa-andarin ang program sa pamamagitan ng\n\n```shell\nbato kamusta_mundo.bt\n```\n\n## Sintaks\n\n### Pagsusulat\n\n```ruby\n"Ito ay mga serye ng mga sulat sa wikang Filipino"\n<<-KATAPUSAN\n  mga salita\n  na nahahati\n  sa ilang mga hilera\nKATAPUSAN\n```\n\n### Dinikit na mga pamamaraan\n\n```ruby\n\'magandang araw\'.baliktad         # => \'wara gnadnagam\'\n\'Pangungusap\'.haba                # => 11\n```\n\n### Ekspresyong Boolean\n\n```ruby\ntama\nmali\nhindi tama\n```\n\n### Kondisyon\n\nPaggamit ng kondisyon.\n\n\n```ruby\nhalaga = 100\n\nmensahe = kapag halaga > 100 dapat\n "ayos lang"\nkung_kapag halaga > 0 dapat\n "ok lang"\nkung_hindi\n "wala lang"\nwakas\n\nmag_print mensahe\n\nmensahe = \n  kung_sakaling halaga\n  pagka 5 dapat "lima"\n  pagka 4 dapat "apat"\n  kung_hindi "wala"\n  wakas\n\nmag_print mensahe\n```\n\n### Pamamaraan sa pagkakamali\n\nNOTE: Hindi ito gagana sa online compiler, ngunit sa pag *i-install* lang sa\niyon computer. Tignan ang seksiyon na [Pagtatalaga](#Pagtatalaga)\n\n```ruby\nbilang_ng_pagkakamali = 0\nsimula\n  # mag komento kapag hindi sigurado\n  1 / 0\niligtas => pagkakamali\n  bilang_ng_pagkakamali += 1\n  subukang_muli kapag bilang_ng_pagkakamali < 3\n  iangat "malubhang pagkakamali"\nsiguraduhing\n  mag_print "Tapos na"\nwakas\n```\n\n### Panuntunan\n\n```ruby\nang iprintAngPangalan(pangalan = wala)\n  mensahe =\n    kapag pangalan != wala\n      "Magandang araw sa iyo #{pangalan}!"\n    kung_hindi\n      "Magandang araw!"\n    wakas\n  \n  mag_print mensahe\nwakas\n\niprintAngPangalan "Maria" # => "Magandang araw sa iyo Maria!"\niprintAngPangalan         # => "Magandang araw!"\n```\n\n## Paggamit ng mga ekspresyon ng mga salita sa program\n\n### wakas\n\nMaari kang gumamit sa alin sa mga sumusunod sa pagtatapos ng program\n\n```ruby\nwakas\ndulo\nkatapusan\n```\nHalimbawa\n\n```ruby\nbilang_ng_saging = 2\n\nmensahe =\n  kapag bilang_ng_saging > 1\n    "Mayroon akong #{bilang_ng_saging} saging! 🍌"\n  kung_hindi\n    "Wala na akong saging! 😐"\n  wakas\n\nmag_print mensahe\n```\n###  kung_iba\n\nKapag ang ekspresyon ay hindi nasunod maaring gumamit sa alin sa mga sumusunod\n\n```ruby\niba\nkung_iba\nkung_hindi\nkung_hindi_naman\nkapag_hindi\nkapag_hindi_naman\nkung_hindi_pa\nkapag_hindi_pa\nat_kung_hindi\nat_kapag_hindi\nat_kung_hindi_naman\nat_kapag_hindi_naman\nat_kapag_hindi_pa\nat_kung_hindi_pa\nmaliban_dito\nmaliban_sa_mga_ito\n```\n\nHalimbawa\n\n```ruby\npangalan_mo = "Maliksi"\n\nmensahe =\n  kapag_ang pangalan_mo == "Maliksi"\n    "Ikaw ay si #{pangalan_mo}!"\n  kung_hindi_naman\n    "Magandang araw sa iyo #{pangalan_mo}!"\n  wakas\n\nmag_print mensahe\n```\n### sakali\n\nKapag mayroon kang ekspresyon na madaming resulta gawa ng mga iba\'t ibang\nkondisyon, maari kang gumamit ng mga sumusunod\n\n```ruby\nsakaling\nsakali\nkung_sakaling\nsakali_na\nkung_sakali_na\nkalagayan\nkaukulan\n```\n\nHalimbawa\n\n```ruby\npangalan_mo = "Mabait"\n\nmensahe =\n  sakaling pangalan_mo\n  ay "Maliksi"\n    "Ikaw ay si Maliksi!"\n  ay "Matipuno"\n    "Ikaw ay si Matipuno!"\n  ay "Mabait"\n    "Ikaw ay si Mabait!"\n  maliban_dito\n    "Magandang araw sa iyo!"\n  wakas\n\nmag_print mensahe\n```\n### tiyakin\n\nKung mayroon kang ekspresyon na gusto mong masunod kahit ano pa ang kahihinatnan\nnito, gumamit ng mga sumusunod\n\nNOTE: Hindi ito gagana sa online compiler, ngunit sa pag *i-install* lang sa\niyon computer. Tignan ang seksiyon na [Pagtatalaga](#Pagtatalaga)\n\n```ruby\ntiyaking\nmatiyak\ntiyakin\nsiguraduhing\nsiguraduhin\npanigurado\n```\n\nHalimbawa\n\n```ruby\nsimulan\n  itaas "May sira!"\nagapan\n  mag_print "Ipagpatuloy..."\n  itaas "May nasira na na-agapan"\ntiyaking\n  mag_print "Tapos na"\nwakas\n```\n\n### grupo\n\nAng grupo ay ang lalagyanan ng mga kabilang na klase sa iyong program\n\n```ruby\ngrupo\n```\n\nHalimbawa\n\n```ruby\ngrupo Hayop\n  KABUUAN = 5\n\n  bilang Aso\n    ang tahol\n      mag_print "Woof..."\n    wakas\n\n    ang kumanin\n      mag_print "..."\n    wakas\n\n    ang ikembot_ang_buntot\n      mag_print "Ginagawa ko ito dahil masaya ako!"\n    wakas\n  wakas\nwakas\n\ndami = 6\nbrowny = Hayop::Aso.kumatawan\nbrowny.ikembot_ang_buntot kapag dami >= Hayop::KABUUAN\n```\n\n### ngunit_kapag\n\nGumamit ng ngunit_kapag kapag mayroon ka pang kondisyon maliban sa nauna ng\nkondisyon\n\n```ruby\nngunit_kapag\nkung_kapag\nngunit_kapag_ang\nkung_kapag_ang\n```\n\nHalimbawa\n\n```ruby\npangalan_mo = "Masipag"\nkapag_ang pangalan_mo == "Matipuno"\n  mag_print "Ikaw ay si Matipuno!"\nngunit_kapag_ang pangalan_mo == "Masipag"\n  mag_print "Ikaw ay si Masipag!"\nmaliban_sa_mga_ito\n  mag_print "Wala kang rekord saamin!"\nwakas\n```\n\n### ang\n\nAng ang ay may kalakip na pangalan upang ito ay matawag sa program\n\n```ruby\nang\npanuntunan\npanuntunang\n```\n\nHalimbawa\n\n```ruby\nang id(estudyante = {})\n  pangalan = estudyante[:pangalan]\n  edad     = estudyante[:edad]\n  tirahan  = estudyante[:tirahan]\n  baitang  = estudyante[:baitang]\n  seksiyon = estudyante[:seksiyon]\n\n  mag_print <<-KATAPUSAN\n    Pangalan: #{pangalan}\n    Edad:     #{edad}\n    Tirahan:  #{tirahan}\n    Baitang:  #{baitang}\n    Seksiyon: #{seksiyon}\n  KATAPUSAN\nwakas\n\nid({\n  pangalan: "Maliksi Batubalani",\n  edad: "13",\n  tirahan: "Ilocos",\n  baitang: "6",\n  seksiyon: "Masisipag"\n})\n```\n\n### agapan\n\nAng agapan ay ginagamit kung mayroon maaaring mangyaring pagkakamali na gusto\nmong maisalba o mailigtas\n\n```ruby\niligtas\nagapan\n```\n\nHalimbawa\n\n```ruby\nsimulan\n  1 / 0\nagapan\n  mag_print "Hindi ito posible!"\nwakas\n```\n\n### dapat\n\nKapag mayroon kang ekspresyon na mayroong inaasahan na resulta, gumamit ng dapat\n\n```ruby\ndapat\n```\n\nHalimbawa\n\n```ruby\npanulat_mo = "lapis"\n\npapel = sakaling panulat_mo\n  ay "lapis" dapat "bond paper"\n  ay "ballpen" dapat "dilaw na papel"\n  maliban_sa_mga_ito "intermediate paper"\nwakas\n\nmag_print "Ang papel na gagamitin mo ay #{papel}"\n```\n\n### magbigay_daan\n\nKapag ang ekspresyon ay mayroong inaasahang dapat na ibigay na resulta habang\ngumagana pa ang program, gumamit ng magbigay_daan\n\n```ruby\nmagbigay_daan\nbigyang_daan\n```\n\nHalimbawa\n\n```ruby\nang gumawaNgID\n  mag_print "------------------------------------------"\n  magbigay_daan\n  mag_print "------------------------------------------"\nwakas\n\nang ID(impormasyon = {})\n  gumawaNgID na_ganito\n    mag_print <<-KATAPUSAN\n      Pangalan: #{impormasyon[:pangalan]}\n      Edad:     #{impormasyon[:edad]}\n      Tirahan:  #{impormasyon[:tirahan]}\n      Baitang:  #{impormasyon[:baitang]}\n      Seksiyon: #{impormasyon[:seksiyon]}\n    KATAPUSAN\n  wakas\nwakas\n\nID({\n  pangalan: "Maliksi Batubalani",\n  edad: "13",\n  tirahan: "Ilocos",\n  baitang: "6",\n  seksiyon: "Masisipag"\n})\n```\n\n### para_sa\n\nKapag may listahan na nais mong isa isahin, gumamit ng para_sa\n\n```ruby\npara_sa\npara_ang\n```\n\nHalimbawa\n\n```ruby\nlistahan_ng_mga_prutas = ["mansanas", "mangga", "guava", "santol", "ubas"]\npara_sa prutas na_nasa listahan_ng_mga_prutas ganito_gawin\n  mag_print prutas.sa_malaking_titik\nwakas\n```\n\n### subukang_muli\n\nGinagamit ang subukang_muli upang umikot muli ang ekspresyon kung may sirang\nnangyari at nais mo ulit subukan pa andarin\n\n```ruby\nsubukang_muli\n```\n\nHalimbawa\n\n```ruby\nbilang_ng_pagkakamali = 0\nsimula\n  1 / 0\nagapan => pagkakamali\n  bilang_ng_pagkakamali += 1\n  subukang_muli kapag bilang_ng_pagkakamali < 3\n  iangat "malubhang pagkakamali"\nsiguraduhing\n  mag_print "Tapos na"\nwakas\n```\n\n### ibalik\n\nKapag mayroon kang ibabalik na resulta sa nagtawag ng ang\n\n```ruby\nibalik\nibalik_ang\nmagbalik\nmagbalik_nang\nisauli\nisauli_ang\nibigay\nibigay_ang\nmagbigay\nmagbigay_nang\n```\n\nHalimbawa\n\n```ruby\nang magdagdag_ng_isa(halaga)\n  idadagdag = halaga + 1\n  ibalik_ang halaga\nwakas\n```\n\n### kapag\n\nGinagamit ang kapag kung meron kang kondisyon sa iyong ekspresyon\n\n```ruby\nkapag\nkapag_ang\nkapag_na_ang\nkung\nkung_ang\n```\n\nHalimbawa\n\n```ruby\nkapag_ang 1 > 0\n  mag_print "mas madami!"\nkung_iba\n  mag_print "may sira"\nwakas\n```\n\n### bilang\n\nAng bilang ay ang pagsasabilang ng isang kaukulang klasipikasyon\n\n```ruby\nbilang\n```\n\nHalimbawa\n\n```ruby\ngrupo Tinapay\n  bilang Donut\n    ang flavor\n      mag_print \'Strawberry!\'\n    wakas\n  wakas\nwakas\n\ntinapay = Tinapay::Donut.kumatawan\ntinapay.flavor\n=> \'Strawberry!\'\n```\n\n### habang\n\nGumamit ng habang kung may hinihintay pa na resulta, kondisyon o pangyayari\n\n```ruby\nhabang\nhabang_ang\n```\n\nHalimbawa\n\n```ruby\nmay_buhay = totoo\n\nhabang may_buhay\n  mag_print \'may pag-asa!\'\n  hinto\nwakas\n=> \'may pag-asa!\'\n```\n\n### alyas\n\nGumamit ng alyas kung kailangan mo tawagin sa ibang pangalan ang iyong\npanuntunan\n\n```ruby\nalyas\n```\n\nHalimbawa\n\n```ruby\nbilang Hayop\n  ang aso\n    mag_print \'si browny ay mabait!\'\n  wakas\n  alyas browny aso\nwakas\n\nhayop = Hayop.kumatawan\nhayop.browny\n=> \'si browny ay mabait!\'\n```\n\n### nakatukoy?\n\nAng nakatukoy? ay ginagamit kung kailangan malaman kung umiiral ang isang grupo\no klase\n\n```ruby\nnakatukoy?\nnakasaad?\n```\n\nHalimbawa\n\n```ruby\ngrupo Manggagawa\n  bilang Magsasaka\n    ang pananim\n      [\'sibuyas\', \'kamatis\', \'palay\', \'mais\'].isaisahin na_ganito |pananim|\n        mag_print "Mag tatanim ng #{pananim} ngayong panahon"\n      wakas\n    wakas\n  wakas\nwakas\n\nkung nakatukoy?(Manggagawa::Magsasaka)\n  mag_print \'May nakatukoy!\'\nwakas\n```\n\n### tanggalin\n\nGinagamit ang tanggalin kung may tatanggaling panuntunan sa isang klase\n\n```ruby\ntanggalin\nmagtanggal\n```\n\nHalimbawa\n\n```ruby\ngrupo Hayop\n  bilang Aso\n    ang tahol\n      mag_print \'baw waw!\'\n    wakas\n  wakas\nwakas\n\nbilang Pusa < Hayop::Aso\n  tanggalin tahol\n  ang meow\n    mag_print \'meow wahu!\'\n  wakas\nwakas\n\npusa = Pusa.kumatawan\n\nsimulan\n  pusa.tahol\nagapan => pagkakamali\n  mag_print "ang pagkakamali ay \'#{pagkakamali}\'"\nwakas\n```\n\n### ihinto\n\nGumamit ng \'hinto\' kung may nais kang matapos na kondisyon gamit ang \'habang\'\n\n```ruby\nihinto\nhinto\n```\n\nHalimbawa\n\n```ruby\nnakamit = mali\n\nhabang nakamit == mali\n  mag_print \'hindi pa nakakamit!\'\n  hinto\nwakas\n\nmag_print \'nakamit na!\'\n```\n\n### sa\n\nGinagamit ang \'sa\' kung nais mong matukoy ang kasulukuyang listahan\n\n```ruby\nsa\nsa_loob_ng\nnasa\nna_nasa\n```\n\nHalimbawa\n\n  Tignan ang [para_sa](#para_sa)\n\n### ganito\n\nGinagamit ang \'ganito\' kung nais mong i konteksto ang kasulukuyang listahan\n\n```ruby\nna_ganito\nnang_ganito\nganito\n```\n\nHalimbawa\n\n  Tignan ang [magbigay_daan](#magbigay_daan), [nakatukoy?](#nakatukoy?)\n\n### hanggang\n\nAng \'hanggang\' ay magpapatuloy tumakbo hanggang maabot ang tamang kundisyon.\n\n```ruby\nhanggang\nhanggang_ang\nmapa_hanggang\n```\n\nHalimbawa\n\n```ruby\npambilang = 0\npanghuling_numero = 5\nsimula\n  mag_print "Ang numero ay #{pambilang} na"\n  pambilang += 1\nwakas hanggang pambilang < panghuling_numero\n```\n\n### maliban_na\n\n```ruby\nmalibang\nmaliban_na\nmaliban_ang\n```\n\nHalimbawa\n\n```ruby\nmga_persona = [\n  { pangalan: \'Gener\', kasarian: \'lalaki\' },\n  { pangalan: \'Karmen\', kasarian: \'babae\' }\n]\n\nmga_persona.isaisahin ng_ganito |tao|\n  malibang tao[:kasarian] == \'lalaki\'\n    mag_print "si #{tao[:pangalan]} ay babae!"\n  maliban_dito\n    mag_print "si #{tao[:pangalan]} ay lalaki!"\n  wakas\nwakas\n```\n\n### o\n\nAng \'o\' ay ginagamit upang piliin ang nagsasauli ng tama.\n\n```ruby\no\no_ang\n```\n\nHalimbawa\n\n```ruby\ntotoo o mali\n=> totoo\n```\n\n### katangian\n\nAng \'katangian\' ay ginagamit upang makapag takda at makapag basa ng *value* sa\nkatangian na ipinahayag sa loob ng grupo.\n\n```ruby\nkatangian\npanguri\n```\n\nHalimbawa\n\n```ruby\nbilang Robot\n  katangian :pangalan, :kakayahan\n\n  ang magpakilala\n    mag_print <<-INTRO\n        Ako ay isang Robot!\n        Ang pangalan ko ay "#{sariling.pangalan}"\n        Ako ay may kakayahang mag "#{sariling.kakayahan}"\n    INTRO\n  wakas\nwakas\n\nrobot = Robot.gumawa\nrobot.pangalan = "bot-chukoy"\nrobot.kakayahan = "tambling"\nrobot.magpakilala\n```\n\n### ulit-ulitin\n\nAng \'ulit-ulitin\' ay ginagamit upang paikot-ikutin ang ekspresyon hanggang\nihinto ito kapag natupad ang isang kondisyon.\n\n```ruby\npaulit_ulit\nulit_ulitin\n```\n\nHalimbawa\n\n```ruby\npambilang = 0\n\npaulit_ulit na_ganito\n  ihinto kapag_ang pambilang == 10\n  mag_print pambilang\n  pambilang += 1\nwakas\n```\n\n## Pagtulong sa pagdedevelop ng Bato\n\nMagpadala ng mga kahilingan sa paggawa ng ticket.\n\n## Lisensya\n\nInstituto Ng Tekonolohiya sa Massachusetts License (makikita sa LICENSE.txt na file).\n']
helloworld,Helloworld programs in different languages,pull requests are welcome :),168,https://github.com/Prithvirajbilla/helloworld,master,['helloworld\n==========\n127 programs.\n\nCode for some of the programming languages is taken from\nhttp://en.wikipedia.org/wiki/List_of_Hello_world_program_examples\n\nHelloworld programs in different languages\n\n* abap\n* ada\n* adventure_game_studio_script\n* algol\n* amiga_e\n* apl\n* applescript\n* arc\n* as3\n* autoit\n* awk\n* basic\n* batch\n* befunge\n* bennugd\n* boo\n* brainfuck\n* casiobasic\n* c\n* ceylon\n* chef\n* clojure\n* cobol\n* coffeescript\n* coldfusion_markup_language\n* common-lisp\n* context\n* cpp\n* csharp\n* cshell\n* css\n* dart\n* d\n* delphi\n* ecl\n* eiffel\n* elixir\n* emacs_lisp\n* erlang\n* falcon\n* false\n* fancy\n* fantom\n* fimpp\n* forth\n* fortran\n* fsharp\n* go\n* golo\n* gosu\n* groovy\n* haskell\n* homespring\n* hop\n* hq9plus\n* htm\n* idris\n* io\n* java\n* javascript\n* julia\n* kotlin\n* latex\n* livescript\n* logo\n* logtalk\n* lolcode\n* lua\n* m4\n* magic\n* mathematica\n* matlab\n* modula-2\n* nasm\n* nemerle\n* objective-c\n* ocaml\n* omgrofl\n* pascal\n* perl\n* perl 6\n* php\n* pl_sql\n* postscript\n* potion\n* powershell\n* processing\n* prolog\n* pure\n* python\n* qbasic\n* racket\n* rebol\n* rexx\n* r\n* ruby\n* rust\n* scala\n* scheme\n* shakespeare\n* shellcode\n* shell\n* small_basic\n* smalltalk\n* smilebasic\n* sml\n* snobol\n* speakeasy\n* sql\n* stata\n* supercollider\n* supernova\n* swift\n* tcl\n* tex\n* ti-basic\n* unlambda\n* unrealscript\n* vala\n* verilog\n* vhdl\n* vim\n* visual-basic\n* whitespace\n* x86\n* xpath2\n* xquery\n* xslt\n* xtend\n* zimbu\n\ntodo\n====\n\nadd few more languages\n\nInspired by [99bottles](http://www.99-bottles-of-beer.net/).\n\n']
ffi-overhead,comparing the c ffi (foreign function interface) overhead on various programming languages,588,https://github.com/dyu/ffi-overhead,master,['ffi-overhead\n============\n\ncomparing the c ffi overhead on various programming languages\n\nRequirements:\n- gcc\n- tup\n- zig\n- nim\n- v\n- java7\n- java8\n- go\n- rust\n- d (dmd and ldc2)\n- haskell (ghc)\n- ocaml\n- csharp (mono)\n- luajit\n- julia\n- node\n- dart\n- wren\n- elixir\n\nMy environment:\n```\n- Intel i7-3630QM laptop (4cores, HT) with 16g ram\n- Ubuntu 14.04 x64\n- gcc/g++ 5.4.1\n- tup 0.7.4\n- zig 0.2.0\n- nim 0.14.3\n- v 0.2.2 aebb551\n- java 1.7.0_72 and 1.8.0_91\n- go 1.8.0\n- rust 1.17.0-nightly (c0b7112ba 2017-03-02)\n- dmd 2.0.71.1\n- ldc2 1.9.0\n- ghc 7.10.3 (at /opt/ghc)\n- ocaml 4.06.1\n- mono 5.12.0.226\n# dynamic languages \n- luajit 2.0.4\n- julia 0.6.3\n- node 6.9.0 (at /opt/node)\n- dart 1.22.0 (at /usr/lib/dart)\n- wren 0.1.0\n- elixir 1.6.5 (Erlang/OTP 20)\n```\n\n### Initialize\n```sh\ntup init\n```\n\n### Compile\n```sh\n./compile-all.sh\n```\n\nCompile opts:\n- -O2 (gcc - applies to c/jni/nim)\n- -C opt-level=2 (rust)\n\n### Run\n```sh\n./run-all.sh 1000000\n```\n\nMeasurement:\n- call the c function "plusone" x number of times and print out the elapsed time in millis.\n ```c\nint x = 0;\nwhile (x < count) x = plusone(x);\n ```\n\n- 2 samples/runs\n\n## Results (500M calls)\n```\n./run-all.sh 500000000\nThe results are elapsed time in milliseconds\n============================================\n\nluajit:\n891\n905\n\njulia:\n894\n889\n\nc:\n1182\n1182\n\ncpp:\n1182\n1183\n\nzig:\n1191\n1190\n\nnim:\n1330\n1330\n\nv:\n1779\n1781\n\nrust:\n1193\n1196\n\nd:\n1330\n1330\n\nd ldc2:\n1191\n1189\n\nhaskell:\n1197\n1198\n\nocamlopt:\n1634\n1634\n\nocamlc:\n4299\n4302\n\ncsharp mono:\n2697\n2690\n\njava7:\n4469\n4472\n\njava8:\n4505\n4472\n\nnode:\n9163\n9194\n\nnode scoped:\n15425\n15409\n\ngo:\n37975\n37879\n\ndart:\n31265\n31282\n\ndart scoped:\n61906\n69043\n\nwren:\n14519\n14514\n\nelixir:\n23852\n23752\n```\n\n']
book-cn,Rust  程序设计语言 中文版——Chinese translation of The Rust Programming Language (Book),514,https://github.com/rust-lang-cn/book-cn,master,['# Rust 程序设计语言\n\n![Build Status](https://github.com/rust-lang-cn/book-cn/workflows/CI/badge.svg)\n[![LICENSE-MIT](https://img.shields.io/badge/license-MIT-green)](https://raw.githubusercontent.com/rust-lang-cn/book-cn/master/LICENSE-MIT)\n[![LICENSE-APACHE](https://img.shields.io/badge/license-Apache%202-blue)](https://raw.githubusercontent.com/rust-lang-cn/book-cn/master/LICENSE-APACHE)\n![GitHub last commit](https://img.shields.io/github/last-commit/rust-lang-cn/book-cn?color=gold)\n![GitHub contributors](https://img.shields.io/github/contributors/rust-lang-cn/book-cn?color=pink)\n![Locatized 100%](https://img.shields.io/badge/localized-100%25-purple)\n![rustwiki.org](https://img.shields.io/website?up_message=rustwiki.org&url=https%3A%2F%2Frustwiki.org)\n\n> Chinese translation of [The Rust Programming Language][github-en]\n>\n> - 鉴于目前网上的中文版已经滞后英文内容，所以重新开启本书翻译，跟进原书，本书是 Rust 中文翻译项目组的重点翻译项目。\n> - 本文档已 100% 翻译成中文，最后更新时间为 2022-02-06。\n> - 本仓库翻译内容包括 Rust 中文翻译项目组本身原有的翻译以及采用网上已有的开源的翻译版本（如：[KaiserY/trpl-zh-cn][KaiserY] 译本），我们尽可能避免不必要的重复劳动，我们对原译者感激不尽！\n\n[github-en]: https://github.com/rust-lang/book\n[KaiserY]: https://github.com/KaiserY/trpl-zh-cn\n\n本仓库包含《Rust 程序设计语言》图书的源码。\n\n可以从 [No Starch 出版社购买本书的英文纸质图书][nostarch]。\n\n> 中文译版注：\n>\n> 1. 中文出版书名为《Rust 权威指南》，可以在线上或线下购书平台购买。\n> 2. 出版的版本翻译独立于本仓库翻译。\n\n[nostarch]: https://nostarch.com/rust\n\n在线版可以在本组织官网上[阅读中文版][book-cn]（**支持同一页面中英双语切换**）或在 Rust 官网上[阅读英文版][book-en]。另外在 Rust 官网的英文版在线阅读可以选择 [stable]、[beta] 和 [nightly] 三个不同的分支版本，这几个分支版本可能滞后于[英文仓库][github-en]的最新内容。\n\n[book-cn]: https://rustwiki.org/zh-CN/book\n[book-en]: https://doc.rust-lang.org/book/\n[github-en]: https://github.com/rust-lang/book\n[stable]: https://doc.rust-lang.org/stable/book/\n[beta]: https://doc.rust-lang.org/beta/book/\n[nightly]: https://doc.rust-lang.org/nightly/book/\n\n## 依赖\n\n构建本书需要 [mdBook]，最好使用的版本和 `rust-lang/rust` 在[这个文件][rust-mdbook]中指定的版本一致。执行以下命令安装：\n\n[mdBook]: https://github.com/rust-lang-nursery/mdBook\n[rust-mdbook]: https://github.com/rust-lang/rust/blob/master/src/tools/rustbook/Cargo.toml\n\n```bash\n$ cargo install mdbook --vers [version-num]\n```\n\n## 构建\n\n构建此书，请输入：\n\n```\n$ mdbook build\n```\n\n输出内容存放在 `book` 子目录中。可使用浏览器打开来查看内容。\n\n_Firefox:_\n\n```bash\n$ firefox book/index.html                       # Linux\n$ open -a "Firefox" book/index.html             # OS X\n$ Start-Process "firefox.exe" .\\book\\index.html # Windows (PowerShell)\n$ start firefox.exe .\\book\\index.html           # Windows (Cmd)\n```\n\n_Chrome:_\n\n```bash\n$ google-chrome book/index.html                 # Linux\n$ open -a "Google Chrome" book/index.html       # OS X\n$ Start-Process "chrome.exe" .\\book\\index.html  # Windows (PowerShell)\n$ start chrome.exe .\\book\\index.html            # Windows (Cmd)\n```\n\n运行测试:\n\n```bash\n$ mdbook test\n```\n\n## 参与贡献\n\n您的帮助，我们将感激不尽(We\'d love your help)！请参见 [CONTRIBUTING.md][contrib-cn]（英文原项目参与贡献指引 [CONTRIBUTING-EN.md][contrib]）。\n\n[contrib-cn]: https://github.com/rust-lang-cn/book-cn/blob/master/CONTRIBUTING.md\n[contrib]: https://github.com/rust-lang/book/blob/main/CONTRIBUTING.md\n\n## 翻译\n\n我们很乐意翻译这本书！请参阅[“翻译”][Translations]标签（在[英文原仓库][github-en]）以加入当前正在进行的工作。新建一个 Issue，开始使用新语言！在我们合并任何内容之前，我们正在等待 [mdbook 对多种语言的支持][mdbook support]，只要支持后将随时可以开始！\n\n[github-en]: https://github.com/rust-lang/book\n[Translations]: https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations\n[mdbook support]: https://github.com/rust-lang-nursery/mdBook/issues/5\n\n## 拼写检查\n\n要扫描源文件是否存在拼写错误，可以使用 `ci` 目录中的脚本 `spellcheck.sh`。这需要一个带有有效单词的字典文件，由 `ci/dictionary.txt` 提供。如果脚本产生误报（例如，使用了词语 `BTreeMap` 被脚本认为无效），则需要在 `ci/dictionary.txt` 中添加该单词（保持排序顺序以确保一致性）。\n\n## 授权协议\n\n《Rust 程序设计语言》（中文版与英文版 The Rust Programming Language 均） 使用以下两种协议的任一种进行授权：\n\n* Apache 2.0 授权协议，（[LICENSE-APACHE](LICENSE-APACHE) 或 http://www.apache.org/licenses/LICENSE-2.0）\n* MIT 授权协议 ([LICENSE-MIT](LICENSE-MIT) 或 http://opensource.org/licenses/MIT)\n\n可以根据自己选择来定。\n\n除非您有另外说明，否则您在本仓库提交的任何贡献均按上述方式进行双重许可授权，就如 Apache 2.0 协议所规定那样，而无需附加任何其他条款或条件。\n']
book,文言陰符 An Introduction to Programming in Wenyan Language,278,https://github.com/wenyan-lang/book,master,['<img src="assets/wy-logo.svg" align="right" width="128" height="128"/>\n\n# wenyan-book《文言陰符》\n\n*An Introduction to Programming in Wenyan Language*\n\n文言文編程入門: The official [wenyan-lang](https://wy-lang.org) handbook, written in Classical Chinese.\n\n<img src="assets/cover-alt.png" width="700" height="700">\n\n> 編程者何？所以役機器也。機器者何？所以代人力也。然機器之力也廣，其算也速，唯智不逮也。故有智者慎謀遠慮，下筆千言，如軍令然，如藥方然，謂之程式。機器既明之，乃能為人所使。或演星文，或析事理，其用豈止萬端。問曰：機器者，物也，銅鐵也，何能為而能識人之語，而為人之使耶？曰：此所以有編程語言也。人之所常言，辭或斐然，典或奧雅，機器故不能解。然機器所解者，則寥寥然二三言也。曰與、曰或、曰非。此皆至元之辭，人又未易用之。故取其中庸之道，倣人之所言，取其精煉明要者，點竄典字，嚴定其義。上足觀之而為人之用，下足譯之而為機器所解。是謂編程語言也。古有算經，易有繫辭，其用雖不同，語如其類也。\n> \n> ── 《文言陰符內篇•明義第一》\n\n## [Read Online](https://book.wy-lang.org)\n\n[![Netlify Status](https://api.netlify.com/api/v1/badges/7c6b5275-99ea-4dfa-af77-23ac38b80ac6/deploy-status)](https://app.netlify.com/sites/wy-book/deploys)\n\n[![](assets/screenshots/screenshot001.png)](https://book.wy-lang.org)\n\n \n## Download PDF\n\n### 【[Relic Edition](https://github.com/wenyan-lang/book/releases)】【[Remastered Edition](assets/wenyan-book.pdf)】\n\n([alternative link](https://cdn.jsdelivr.net/gh/wenyan-lang/book/assets/wenyan-book.pdf))\n\n[![](assets/screenshots/screenshot003.png)](https://github.com/wenyan-lang/book/releases)\n\n[![](assets/screenshots/screenshot004.png)](https://github.com/wenyan-lang/book/releases)\n\n\n## 目錄 Table of Contents\n\n- [明義第一](01%20明義第一.md)\n- [變數第二](02%20變數第二.md)\n- [算術第三](03%20算術第三.md)\n- [決策第四](04%20決策第四.md)\n- [循環第五](05%20循環第五.md)\n- [行列第六](06%20行列第六.md)\n- [言語第七](07%20言語第七.md)\n- [方術第八](08%20方術第八.md)\n- [府庫第九](09%20府庫第九.md)\n- [格物第十](10%20格物第十.md)\n- [克禍第十一](11%20克禍第十一.md)\n- [圖畫第十二](12%20圖畫第十二.md)\n- [宏略第十三](13%20宏略第十三.md)\n\n\n## Translations\n\n- [Japanese Kanbun version by @747](https://gitlab.com/yheuhtozr/book-ja-kanbun)\n- [Simplified Chinese version by @zuorong-zhang](https://github.com/zuorong-zhang/wybk-slcn)\n\n## Contributing\n\n\n> 雖實覆甕之質，尚存斧正之望；雖乏呂相之金，易字之渴蓋同。\n\nIf you\'d like to suggest an edit, please discuss in an Issue before opening a PR, thanks!\n']
awesome-koans,A curated list of program language koans.,201,https://github.com/ts25504/awesome-koans,master,['# awesome-koans\n### What is [Kōan](https://en.wikipedia.org/wiki/K%C5%8Dan#Sources)\n\nKoan（公案）是佛教禅宗的术语，乃是佛教禅宗祖师的一段言行或者一个小故事，用于引导和开悟。\n\n编程语言的学习也有一种公案形式的学习方法，是我见过的最好的学习一门新的编程语言的方式。以[TDD](https://en.wikipedia.org/wiki/Test-driven_development)的形式，预先编写好每一个知识点的测试代码，引导学习者使用相关的知识编写代码以通过测试。这种像闯关一样的形式让人充满的学习的动力，也解决了很多人学习过程中只有纸上谈兵而没有动手机会的问题。\n\n这个Repo用于收集各种语言可用的koans方便学习。\n\n### AngularJS\n\nhttps://github.com/bjpbakker/angular-koans\n\n### Bash\n\nhttps://github.com/marcinbunsch/bash_koans\n\n### C \n\nhttps://github.com/c-koans/c_koans\n\n### Clojure\n\nhttps://github.com/lazerwalker/clojurescript-koans\n\n### Cpp\n\nhttps://github.com/torbjoernk/CppKoans\n\n### ColdFusion\n\nhttps://github.com/nodoherty/ColdFusion-Koans\n\n### CoffeeScript\n\nhttps://github.com/sleepyfox/coffeescript-koans\n\n### CSharp\n\nhttps://github.com/jtigger/csharp-koans\n\n### Dart\n\nhttps://github.com/butlermatt/dart_koans\n\n### DotNet\n\nhttps://github.com/CoryFoy/DotNetKoans\n\n### Elixir\n\nhttps://github.com/elixirkoans/elixir-koans\n\n### Erlang\n\nhttps://github.com/patrickgombert/erlang-koans\n\n### FSharp\n\nhttps://github.com/ChrisMarinos/FSharpKoans\n\n### Go\n\nhttps://github.com/cdarwin/go-koans\n\n### Groovy\n\nhttps://github.com/nadavc/groovykoans\n\n### Haskell\n\nhttps://github.com/HaskVan/HaskellKoans\n\n### Java\n\nhttps://github.com/matyb/java-koans\n\n### Javascript\n\nhttps://github.com/mrdavidlaing/javascript-koans\n\n### Kotlin\n\nhttps://github.com/Kotlin/kotlin-koans\n\n### Lisp\n\nhttps://github.com/google/lisp-koans\n\n### Lua\n\nhttps://github.com/kikito/lua_missions\n\n### Objective-C\n\nhttps://github.com/joecannatti/Objective-C-Koans\n\n### Perl\n\nhttps://github.com/forcedotcom/PerlKoans\n\n### Prolog\n\nhttps://github.com/araneforseti/prolog-koans\n\n### Python\n\nhttps://github.com/gregmalcolm/python_koans\n\n### R\n\nhttps://github.com/DASpringate/Rkoans\n\n### ReactJS\n\nhttps://github.com/arkency/reactjs_koans\n\n### Ruby\n\nhttp://rubykoans.com/\n\n### SAP ABAP\nhttps://github.com/damir-majer/ABAPKoans\n\n### Scala\n\nhttps://github.com/rubbish/scala-koans\n\n### Smalltalk\n\nhttps://github.com/sl4m/gnu_smalltalk_koans\n\n### Swift\n\nhttps://github.com/mokagio/Swift-Koans\n']
potigol,Linguagem Potigol - Linguagem de programação funcional moderna para iniciantes - A Functional Programming Language for Beginners,225,https://github.com/potigol/potigol,master,['# Linguagem Potigol\n\n[![Join the chat at https://gitter.im/potigol/Potigol](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/potigol/Potigol?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Follow us](https://img.shields.io/twitter/follow/potigol.svg?style=social)](http://twitter.com/potigol)\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/2b0637491b834a229351fab7fd897dfc)](https://www.codacy.com/app/leonardo-lucena-71/Potigol?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=potigol/Potigol&amp;utm_campaign=Badge_Grade)\n[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.53192.svg)](https://doi.org/10.5281/zenodo.53192)\n\n > <a href="https://potigol.github.io/docs/hacktoberfest"><img src="https://hacktoberfest.digitalocean.com/_nuxt/img/logo-hacktoberfest-full.f42e3b1.svg" width=250></a>\n\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io#https://github.com/potigol/gitpod)\n[![IFRN](https://potigol.github.io/docs/logo_ifrn_40.png)](https://www.ifrn.edu.br)\n\n > Linguagem de Programação moderna para iniciantes\n\n\n## Documentação\n  - [Documentação](https://potigol.github.io)\n  - [Problemas de programação resolvidos usando a Linguagem Potigol](https://potigol.github.io/uoj-potigol) (Mais de 700 exemplos)\n\n\n## Características\n  - Sintaxe simples\n  - Palavras-chave em português\n  - Tipagem estática e forte\n  - Inferência de tipos\n  - Multiparadigma\n  - Encoraja a programação funcional\n\n![Editor](https://cloud.githubusercontent.com/assets/303460/8604675/7180d638-2656-11e5-9239-90d29628d9d0.png)\n\n## Como usar:\n  - Baixe a versão mais recente do Potigol https://github.com/potigol/Potigol/releases\n  - Descompacte o arquivo\n  - Para executar o Editor de Código digite no prompt do terminal\n  \n  ````java -jar epotigol.jar````\n\n  - Para executar um programa em Potigol digite no prompt do terminal\n\n  ````java -jar potigol.jar arquivo.poti````\n\n  - No Windows basta usar ````epotigol```` ou ````potigol arquivo.poti````.\n  \nExemplos: https://github.com/potigol/Potigol/wiki/jogos\n\n## Editores de Código\n\nEditores de código para Potigol:\n\n  - [x] [Plugin (potigol/potigol-language)](https://marketplace.visualstudio.com/items?itemName=Potigol.potigol-language) para o [VSCode](https://code.visualstudio.com/)\n  - [x] [Plugin](https://github.com/potigol/language-potigol) para o [Atom](https://atom.io)\n  - [x] [Plugin](https://github.com/nfischer/vim-potigol) para o [Vim](http://www.vim.org/)\n  - [x] [Editor Potigol](https://github.com/potigol/EditorPotigol) (já incluso na versão executável de Potigol)\n  - [x] [JCEditor](https://github.com/crhenr/JCEditor)\n  - [x] [Plugin (potigol/PotigolAce)](https://github.com/potigol/PotigolAce) para o Ace Editor\n  - [x] [Plugin (nelson-ion/potigol_codemirror)](https://github.com/nelson-ion/potigol_codemirror) para o CodeMirror\n\n<br/>\n\n# Instalação\n\nVeja o passo a passo de como instalar o Potigol em sistemas Windows e Linux\n\n## Windows 7, 8 e 10\n\n  - Baixe a versão mais nova do Potigol: https://github.com/potigol/Potigol/releases\n  - Descompacte o arquivo e copie a pasta Potigol para c:\\potigol\n  - Envie um atalho de "epotigol.jar" para a área de trabalho\n  - Altere o nome do atalho para "Editor Potigol"\n  - Em propriedades, altere o ícone. Escolha o ícone em cores que está na pasta do Potigol.\n  - Envie um atalho de C:\\Windows\\System32\\cmd.exe para a área de trabalho.\n  - Em propriedade altere:\n  \n >   Destino: %windir%\\system32\\cmd.exe /E:ON /K C:\\potigol\\configpotigol.bat\n\n > Iniciar em: [Vazio]\n\n > Alterar ícone. Escolha o icone em preto e branco.\n\n  - Usando o botão direito do mouse escolha a opção "Fixar na Tela Inicial".\n\n## LINUX\n\n  - Baixe a versão mais nova do Potigol: https://github.com/potigol/Potigol/releases\n  - Copie a pasta Potigol para o local adequado\n  - Insira as linhas abaixo no final do arquivo /etc/bash.bashrc\n\n>   ````alias potigol=\'java -jar [caminho até a pasta do potigol]/potigol.jar\'````\n\n>   ````alias epotigol=\'java -jar [caminho até a pasta do potigol]/epotigol.jar\'````\n\n  - Crie o arquivo \'~/Área de Trabalho/potigol_lancador.desktop\'\n    \n````\n[Desktop Entry]\nName=Potigol\nType=Application\nExec=java -jar [caminho até a pasta do potigol]/epotigol.jar\nIcon=[caminho até a pasta do potigol]/potigol.png\n````\n\n## Compilação\n\nPara compilar siga as instruções em [compilação.md](https://github.com/potigol/Potigol/blob/master/compilacao.md)\n']
rpp,RPP is a new programming language combined with C++ and LISP,131,https://github.com/roundsheep/rpp,master,['\ufeff### RPP - 国产开源编程语言\r\n\r\n\r\n##### 为什么需要它？\r\n\r\n理由一：目前DIY操作系统一般使用gcc+nasm，RPP支持编译运行，抽象能力强过C，可直接内联汇编，不需要面对难看的AT&T汇编，绝对是您DIY操作系统的利器（支持GRUB从U盘或硬盘引导）。\r\n\r\n理由二：RPP以静态类型为主，没有GC，所以理论运行速度和C++一样，最终的效率肯定比动态类型的lua要高，并且不会引起GC停顿。（目前运行速度与luaJIT接近，比tcc略快）\r\n\r\n下面是RPP性能测试数据：（双重循环求和，具体测试代码请参考rpp.pdf）\r\n\r\n![github](https://github.com/roundsheep/rpp/blob/master/bin/pic/rpp_speed.png "github")\r\n\r\n理由三：RPP与C/C++互相调用比lua还简单，而且RPP和C++共享进程内存空间，RPP变量和C++变量生命周期相同，不会出现像lua一样的这里变量已经GC了那边还在使用。\r\n\r\n理由四：RPP既可以编译运行又可以解释运行，既可以用静态类型又可以用动态类型。语法层支持C++、JS、Lisp、python、asm混合编程，一种语言，五种语法。（目前兼容50%的C++语法，70%的C语法，编译器本身使用C++编写，其90%的源码都可以自我编译）\r\n\r\nRPP的整体设计：\r\n\r\n![github](https://github.com/roundsheep/rpp/blob/master/bin/pic/rpp.png "github")\r\n\r\n##### RPP编码风格1：（这是标准C++语法，本段代码可用VC++、G++或RPP进行编译）\r\n\r\n\t\tstatic rbool inherit_proc(tsh& sh, tclass& tci, int level = 0)\r\n\t\t{\r\n\t\t\tif (level++ > c_rpp_deep)\r\n\t\t\t\treturn false;\r\n\t\t\tif (tci.vfather.empty())\r\n\t\t\t\treturn true;\r\n\t\t\trbuf<tword> v;\r\n\t\t\tfor(int i = 0; i < tci.vfather.count(); i++)\r\n\t\t\t{\r\n\t\t\t\trstr cname = tci.vfather[i].vword.get(0).val;\r\n\t\t\t\ttclass* ptci = zfind::class_search(sh, cname);\r\n\t\t\t\tif (ptci == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tptci = zfind::classtl_search(sh, cname);\r\n\t\t\t\t\tif (ptci == null)\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (!inherit_proc(sh, *ptci, level))\r\n\t\t\t\t\treturn false;\r\n\t\t\t\tv += ptci->vword;\r\n\t\t\t}\r\n\t\t\tv += tci.vword;\r\n\t\t\ttci.vword = v;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n##### RPP编码风格2：（类似python的无花括号风格）\r\n\r\n\t\tbool next_permutation<T>(rbuf<T>& v)  \r\n\t\t{  \r\n\t\t\tif v.count <= 1  \r\n\t\t\t\treturn false  \r\n\t\t\tnext = v.count - 1  \r\n\t\t\tfor  \r\n\t\t\t\ttemp = next  \r\n\t\t\t\tnext--  \r\n\t\t\t\tif v[next] < v[temp]  \r\n\t\t\t\t\tmid = v.count - 1  \r\n\t\t\t\t\tfor !(v[next] < v[mid])  \r\n\t\t\t\t\t\tmid--  \r\n\t\t\t\t\tswap<T>(v[next], v[mid])  \r\n\t\t\t\t\treverse<T>(v, temp)  \r\n\t\t\t\t\treturn true  \r\n\t\t\t\tif next == 0  \r\n\t\t\t\t\treverse<T>(v, 0)  \r\n\t\t\t\t\treturn false\r\n\t\t} \r\n\r\n##### RPP编码风格3：（类似《算法导论》的伪代码）\r\n\r\n\t\tdefine ← =  \r\n\t\t  \r\n\t\tvoid insertion_sort(rstr& a)  \r\n\t\t{  \r\n\t\t\tfor j ← 1 to a.count - 1  \r\n\t\t\t\tkey ← a[j]  \r\n\t\t\t\ti ← j - 1  \r\n\t\t\t\twhile i >= 0 && a.get(i) > key  \r\n\t\t\t\t\ta[i + 1] ← a[i]  \r\n\t\t\t\t\ti ← i - 1  \r\n\t\t\t\ta[i + 1] ← key  \r\n\t\t}\r\n\r\n##### RPP编码风格4：（Lisp风格，从v1.91开始S表达式用逗号分隔）\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\t\t\tint a\r\n\t\t\tint b\r\n\t\t\t[int, =, [a, 1]]\r\n\t\t\t[int, =, [b, 2]]\r\n\t\t\t[rf, print, [[int, +, [a, b]]]]\r\n\t\t}\r\n\r\n理由五：RPP自由度极高，完全开源，您可以随意DIY运算符的优先级，增加新运算符，增加修改“内置类型”，甚至于int、double这些基础类型都是由用户自定义的，一切由您做主。\r\n\r\n理由六：它是C++的山寨版，C++程序员几乎无需学习即可使用，而且RPP所有数据类型和C++二进制兼容，无论是静态链接还是动态链接，想怎样就怎样。\r\n\r\n理由七：它以Lisp作为中间层，编译器在运行期可用，程序在运行时可以改变其结构，新的函数可以被引进，因此支持mixin、元编程以及各种动态特性，并且同时支持call_by_name、call_by_need和call_by_value。\r\n\r\n理由八：RPP对C++的一些复杂语法进行了简化，单纯的编译速度比C++略快。但是RPP在解释运行的时候并不会一次编译整个程序，而是在函数需要运行的时候才进行即时编译（边运行边编译），所以综合编译速度比C++快一个数量级（仅与VC++和G++对比）。\r\n\r\n理由九：RPP的设计目标是简洁、快速、稳定。它的源码结构比lua简单得多，但实现的功能不比lua少，因此RPP将是您实现编译器的绝佳参考。另外嵌入编译器只需要包含一个头文件即可（zmain.h），您再也不用担心各种奇怪的链接错误了。\r\n\r\n<br/>\r\nRPP支持多种运行方式，方法如下：（各种运行方式支持的特性请参考rpp.pdf）\r\n\r\n##### JIT：\r\n\r\n1. cd到bin目录\r\n2. 命令行敲入 rjit example\\1.h\r\n\r\n\r\n##### JIT打包发布（生成独立EXE）：\r\n\r\n1. cd到bin目录\r\n2. 命令行敲入 rpack example\\1.h\r\n3. 成功后会生成example\\1.exe，可脱离RPP环境运行\r\n\r\n\r\n##### 解释运行：\r\n\r\n1. cd到bin目录\r\n2. 命令行敲入 rpp example\\1.h\r\n\r\n下面是RPP编写的控制台贪食蛇：\r\n\r\n![github](https://github.com/roundsheep/rpp/blob/master/bin/pic/rpp_snake.png "github")\r\n\r\n##### 编译运行（生成EXE）：\r\n\r\n1. cd到bin目录\r\n2. 命令行敲入 build_run example\\1.h\r\n\r\n\r\n##### 编译不运行（生成EXE）：\r\n\r\n1. cd到bin目录\r\n2. 命令行敲入 build example\\1.h\r\n\r\n\r\n##### 执行语法检查（不生成任何文件）：\r\n\r\n1. cd到bin目录\r\n2. 命令行敲入 rcheck example\\1.h\r\n\r\n\r\n##### 裸奔（无操作系统运行）：\r\n\r\n1. cd到bin\\nasm\\\r\n2. 敲入 bin cell.h （成功后会生成 cell.bin）\r\n3. 修改 menu.lst 将引导文件改为 cell.bin\r\n4. 使用 bootice（或其它工具）制作 grub4dos 引导扇区\r\n5. 将 cell.bin、menu.lst、grldr 三个文件拷贝至U盘或硬盘根目录\r\n6. 推荐先使用虚拟机进行测试\r\n\r\n\r\n##### cocos2dx win32 绑定运行：\r\n（仅v1.83及以下版本支持，新版本正在重构cocos2dx绑定）\r\n\r\n1. cd到bin目录\r\n2. 命令行输入 rcc cocos\\flappy.h（需要VS2012运行库和最新的opengl驱动）\r\n\r\n![github](https://github.com/roundsheep/rpp/blob/master/bin/pic/flappy.png "github")\r\n\r\n##### cocos2dx android 绑定运行：\r\n（仅v1.83及以下版本支持，新版本正在重构cocos2dx绑定）\r\n\r\n1. 安装cocos\\rcc.apk\r\n\r\n\r\n##### 解释运行方式可以关联.h文件：（这样就不用每次敲命令行）\r\n\r\n1. 右键点击bin\\example下任意一个.h文件，选择“属性”\r\n2. 点击“更改”\r\n3. 点击“浏览”\r\n4. 找到bin\\rpp.exe并点击“打开”\r\n5. 选中“始终使用选择的程序打开这种文件”\r\n6. 点击两次“确定”\r\n7. 之后可以直接双击后缀为.h的源文件运行RPP程序\r\n\r\n##### 第三方IDE编辑代码：\r\n\r\n1. 运行bin\\ide\\SciTE.exe\r\n2. 点击File->Open\r\n3. 选择bin\\example\\1.h，点击“打开”\r\n4. 按F5运行程序（F7打包发布）\r\n\r\n##### Windows窗体模式：（WinMain）\r\n\r\n1. cd到bin目录\r\n2. 命令行敲入 rjit_win example\\win.h\r\n3. 或者使用IDE打开win.h，按Ctrl+F5运行或者Ctrl+F7打包发布\r\n\r\n![github](https://github.com/roundsheep/rpp/blob/master/bin/pic/rpp_win.png "github")\r\n\r\n使用scite可以自动补全代码，但不如Visual Assist的智能补全。\r\n\r\nVisual Assist智能补全请看视频演示：\r\n\r\nhttp://www.tudou.com/programs/view/40Ez3FuqE10/\r\n\r\n<br/>\r\n\r\n##### 编译RPP源码：\r\n\r\n1. 确保安装了 VS2012 update4 或者 VS2013\r\n2. 打开proj\\rpp.sln\r\n3. 按F7，成功后会生成bin\\rpp.exe\r\n\r\n\r\n##### 低版本VC++编译RPP源码：（VS2005、VS2008、VS2010）\r\n\r\n1. 修改RPP源码中使用了C++11 move语义的地方（或者回退到RPP v1.87及以下版本）\r\n2. 新建控制台解决方案\r\n3. 添加rpp\\rpp.cpp\r\n4. 设置项目属性为多字节字符集\r\n5. 设置运行库为“多线程MT”（可选）\r\n6. 按F7，成功后会生成bin\\rpp.exe\r\n\r\n\r\n##### 自动测试example下所有例子：\r\n（如果您修改了编译器源码，请运行这个批处理）\r\n\r\n1. 双击bin\\check_all.bat\r\n\r\n<br/>\r\nRPP没有协议，任何人可以随意使用、复制、发布、修改、改名。\r\n\r\n\r\nQQ交流群：34269848   \r\n\r\nE-mail：287848066@qq.com']
IoPLMaterials,Materials for the class "Implementation of Programming Languages" in Kyoto University.,143,https://github.com/kuis-isle3sw/IoPLMaterials,master,['{% include head.html %}\n\n# 京都大学工学部専門科目「プログラミング言語処理系」講義資料\n\n## お知らせ\n\n- 4月1日: 本科目の履修を検討している人は，必ず[PandAの本科目のページ](https://panda.ecs.kyoto-u.ac.jp/portal/site/2022-110-9128-000/page/23850a9f-f535-41a1-8cb9-147f9cba50bf) をチェックしておいてください．\n- 4月1日: 2022年度版ページにしました．\n\n## 学習の仕方\n\n_計算機科学コースの学生には講義中に別途やり方を指示します．（実験3SWもやるので．）_\n\n- [この講義資料の GitHub のページ](https://github.com/kuis-isle3sw/IoPLMaterials)からリポジトリを clone しましょう．\n- [OCaml が使えるように環境を設定](textbook/setting-up-ocaml.md)しましょう．\n- 落ちてきたソースコード中の `textbook/interpreter/` ディレクトリの中にインタプリタのソースコードが入っているので，`dune`コマンドでビルドしましょう．\n- [教科書](https://kuis-isle3sw.github.io/IoPLMaterials/)を読みながらもりもり演習問題を解きましょう．\n  - 教科書にバグを見つけたら [issue](https://github.com/kuis-isle3sw/IoPLMaterials/issues) で報告しましょう．\n  - 講義の履修者は講義用 Slack で質問してもよいですね．\n- プログラミング言語強者になりましょう．そのためには．．．\n  - なにか自分で言語を作って処理系を作ってみましょう．作った処理系を自慢しましょう．世界中で自作の言語が使われるようになったらいいですね．\n  - もしくは，プログラミング言語理論やプログラム検証を勉強してみましょう．\n    TODO: 参考文献\n\n## 教科書 <a name="textbook"></a>\n\n（鋭意 Markdown 化中．）\n\n### リンク\n\n<https://kuis-isle3sw.github.io/IoPLMaterials/>\n\n### 目次\n\n<!-- - [オリエンテーション資料](misc/orientation.md) -->\n- [OCaml の環境設定](textbook/setting-up-ocaml.md) [(講義スライド)](textbook/slides/ocaml.pdf)\n<!--  - [opamのインストール方法](textbook/install_opam.jp.md) -->\n- OCaml あまり知らない人向け: 前提となる OCaml の知識を身に付ける．\n  - [OCaml 爆速入門 by 五十嵐淳](http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/pl/03-ocaml.html)\n  - [OCaml で二分探索木を書く by 五十嵐淳](http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/pl/04-bst-ocaml.html)\n  - [この資料の「多相二分木 in OCaml」のところ](http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/pl/09-polymorphism.html)\n  - [高階関数 (OCamlに関するところのみ)](http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/pl/10-hofuns.html)\n  - [多相性についてもう少し & 例外処理 (OCamlに関するところのみ)](http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/pl/11-polyBST.html)\n- もう少しちゃんとした OCaml のテキスト: [OCaml入門テキスト by 五十嵐淳](textbook/mltext.pdf)\n  - _1章は古くなっているので，2章から読むこと_\n- プログラミング言語処理系テキスト by 五十嵐淳，馬谷誠二，末永幸平\n  - [1章: イントロダクション](textbook/chap01.md)\n  - [2章: 概論的な話](textbook/chap02.md) [(講義スライド)](textbook/slides/intro.pdf)\n  - 3章: 型無し MiniML インタプリタの実装 [(講義スライド)](textbook/slides/interpreter.pdf)\n    - [3.1: MiniML1 のシンタックス](textbook/chap03-1.md)\n    - [3.2: 各モジュールの機能 (1): `Syntax`, `Eval`, `Environment`, `Cui`](textbook/chap03-2.md)\n    - [3.3: 各モジュールの機能 (2): `Parser`, `Lexer`](textbook/chap03-3.md)\n    - [3.4: MiniML2: 定義の導入](textbook/chap03-4.md)\n    - [3.5: MiniML3: 関数の導入](textbook/chap03-5.md)\n    - [3.6: MiniML4: 再帰関数](textbook/chap03-6.md)\n    - [3.7: MiniML5 and beyond: やりこみのための演習問題](textbook/chap03-7.md)\n  - 4章: 型推論機能付き MiniML インタプリタの実装（あるいは，型システムを用いた形式検証の初歩）[(講義スライド)](textbook/slides/typing.pdf)\n    - [4.1: 静的プログラム検証へのイントロダクション](textbook/chap04-1.md)\n    - [4.2: MiniML2 のための型推論 (1): MiniML2 の型システム](textbook/chap04-2.md)\n    - [4.3: MiniML2 のための型推論 (2): 型推論アルゴリズム](textbook/chap04-3.md)\n    - [4.4: MiniML3,4 のための型推論 (1): Prelude](textbook/chap04-4.md)\n    - [4.5: MiniML3,4 のための型推論 (2): 型の等式制約と単一化](textbook/chap04-5.md)\n    - [4.6: MiniML3,4 のための型推論 (3): 型推論アルゴリズムの実装](textbook/chap04-6.md)\n    - [4.7: 多相的 `let` の型推論](textbook/chap04-7.md)\n    - 4.8: やりこみのための演習問題\n  - 5章: MiniML コンパイラの実装\n    - [5.1: 能書き](textbook/chap05-1.md)\n    - [5.2: ソース言語 MiniML4- と中間言語$\\mathcal{C}$](textbook/chap05-2.md)\n    - [5.3: MiniML4- から$\\mathcal{C}$への変換$\\mathcal{I}$](textbook/chap05-3.md)\n    - [5.4: MIPS アセンブリ言語入門](textbook/chap05-4.md)\n    - [5.5: 仮想マシンコードとその生成](textbook/chap05-5.md)\n    - [5.6: アセンブリ生成](textbook/chap05-6.md)\n    - 5.7: $\\mathcal{C}$の最適化（まだ）\n    - 5.8: $\\mathcal{V}$におけるデータフロー解析（まだ）\n    - 5.9: レジスタ割り付け（まだ）\n    - 5.10: 高階関数（まだ）\n    - 5.11: 動的メモリ管理（やるの？）\n    - 5.12: オブジェクト指向（やるの？）\n    - 5.13: 分割コンパイルとリンカ（やるの？）\n  - 6章: 字句解析と構文解析のためのアルゴリズム（まだ．今学期はスライドで講義済み．）\n    - 7.1: 字句解析\n    - 7.2: LL(1)アルゴリズム\n    - 7.3: LR(0)アルゴリズム\n    - 7.4: SLR(1), LR(1)アルゴリズム\n  - 7章: さらに学びたい人のための参考文献\n  - 8章: [参考文献](textbook/reference.md)\n  - 付録: [問題リンク集](textbook/exercises.md)\n\n## リンク集\n\n- [実験3ホームページ](https://kuis-isle3sw.github.io/kuis-isle3sw-portal/)\n- [専門科目「プログラミング言語」ホームページ](https://github.com/aigarashi/PL-LectureNotes)\n  - [の中の OCaml のページ（最低このくらいはわかってないとキツイ）](http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/pl/03-ocaml.html)\n  - [の中の OCaml で二分探索木を書くページ（これもわかってないとキツイ）](http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/pl/04-bst-ocaml.html)\n- [OCaml の標準ライブラリの話](textbook/chap03-2.md#standardLib)を教科書に書いてあるので読んでおくととても良い違いない．\n\n## 講義日程\n\n- 4/11\n- 4/18\n- 4/25\n- 5/2\n- 5/9\n- 5/16\n- 5/23\n- 5/30\n- 6/6\n- 6/13\n- 6/20\n- 6/27\n- 7/4\n- 7/11\n- (7/25)\n\n## 講義に関する情報\n\n- 講義をする人: 末永幸平（[@ksuenaga](http://www.twitter.com/ksuenaga/), [Researchmap](https://researchmap.jp/ksuenaga/)）\n- 講義が行われる時間: 月曜2限\n- 講義が行われる場所: 総合研究7号館講義室1\n- Language used in the class: Japanese\n\n## ご寄付のお願い\n\n本学学生以外の方で，もしこのページのマテリアルが有用であるとお思いになられたら，是非[京都大学基金](https://payment.kikin.kyoto-u.ac.jp/kyoto-u/entry.php?purposeCode=406000)へのご寄付をいただけると幸いです．運営費交付金が年々削減される中で，大学教員が教育と研究活動を両立させつつ，学外の方々にも有用な情報を発信し続けられるよう，ご支援をいただけると大変ありがたく思います．[京都大学へのご寄付に対しましては，法人税法，所得税法による税制上の優遇措置が受けられます．](https://www.kikin.kyoto-u.ac.jp/exemption/)\n\n特に以下の基金へのご寄付をいただけますと大変ありがたいです．\n\n+ [京都大学修学支援基金](https://www.kikin.kyoto-u.ac.jp/contribution/student/): 意欲と能力のある学生が経済的理由で修学・進学を断念することなく，希望する教育を受けられるようにすることを目的とした基金です．\n+ [男女共同参画支援たちばな基金](https://www.kikin.kyoto-u.ac.jp/contribution/tachibana/): 男女共同参画支援を推進するための基金で，育児等支援の充実，保育施策の充実，男女共同参画推進事業の充実を目的とした基金です．\n+ [情報学研究科基金](https://www.kikin.kyoto-u.ac.jp/contribution/informatics/): 情報学研究科における大学院生の学修・研究支援，若手研究者支援，研究支援を目的とした基金です．\n\n## ローカル環境でのビルド方法\n\nこの資料は [Jekyll](http://jekyllrb-ja.github.io/) を使用して構築されています．動作確認などのためにこの資料をローカル環境で表示させる場合は，[Ruby](https://www.ruby-lang.org/ja/) を導入した上で，次の通りコマンドを実行してください．\n```\n$ gem install bundler jekyll\n$ bundle exec jekyll serve --baseurl \'/IoPLMaterials\'\n```\nその後 [http://127.0.0.1:4000/IoPLMaterials/](http://127.0.0.1:4000/IoPLMaterials/) にアクセスしてください。\n\n<!--\nSome notes on the documentation:\n- build commands:\n  ```sh\n  ❯ bundle install # required for the first time\n  [...]\n\n  ❯ bundle exec jekyll serve --livereload\n  [...]\n  # Open the local server address and keep editting.\n  # The `--livereload` option is particularly helpful to see update immediatelly when you make change.\n  ```\n- 各ファイルのはじめに \\{\\% include head.html \\%\\} がおいてある．`_includes/head.html` をここに読み込むことを表してる．\n  - head.html には MathJax を使うための設定等が書いてある．\n-->\n']
LayaAir,LayaAir is an open-source 2D/3D engine. LayaAir Engine is designed for high performance games.LayaAir support TypeScript and JavaScript、ActionScript 3.0 programming language.Can develop once, publish for multi platform.,1276,https://github.com/layabox/LayaAir,Master3.0,['# LayaAir3.0\n欢迎使用LayaAir3.0源代码 ！\n## 引擎背景\n\n[LayaAir](https://baike.baidu.com/item/LayaAir/19782570)引擎是[Layabox](https://www.layabox.com/)旗下的游戏引擎品牌。LayaAir引擎不仅支持2D、3D、AR、VR 等类型的游戏研发，还可以用于广告、营销、教育等领域。除HTML5 版本的发布外，还同时支持发布Native-APP、微信小游戏、QQ小游戏、百度小游戏、Bilibili小游戏、抖音小游戏、头条小游戏、支付宝小游戏、OPPO小游戏、vivo小游戏、小米快游戏、华为快游戏等平台。\n\n## 如何使用源码\n安装依赖\n```diff\n执行npm install命令，如下图所示\n\nnpm install\n```\n运行示例\n```diff\nnpm run start\n```\n编译引擎\n```diff\nnpm run build\n\n执行之后会在根目录生成build文件夹，编译好的引擎都在其中\n```\n在IDE中使用源码引擎\n```diff\n如果需要使用自己编译的引擎代替IDE自带的引擎，可以将“build/libs”文件夹中的js文件拷贝到“你的项目文件夹/engine/libs"下。不需要拷贝全部js文件，可以只拷贝你需要覆盖的文件。\n```\n\n## 如何贡献代码\n从 github 官方开源项目 fork 一份到 自己仓储,git clone 到本地,将修改的代码提交后，PR到官方，我们会尽快为您回复，为您提供Approve和merge，欢迎大家来共同建设\n\n## 其他链接\n官网\n\n> https://layaair.layabox.com/\n\n论坛\n\n> https://ask.layabox.com/\n\ndemo（链接）\n\n> https://layaair.layabox.com/3.x/demo/\n\n开发者文档\n\n> https://layaair.layabox.com/3.x/doc/\n\nAPI（链接）\n\n> https://layaair.layabox.com/3.x/api/\n\n## 更多资讯\n该引擎使用[MIT](https://opensource.org/licenses/MIT)开源协议，请阅读 LICENSE文件']
goNum,开源Go语言数值算法库(An open numerical library purely based on Go programming language),169,https://github.com/chfenger/goNum,master,["关于goNum\r\n==========\r\ngoNum是一款完全以[Go](https://golang.org)语言为基础的开源数值算法库，它可以使你像调用其它go函数一样使用其进行数值运算，且不依赖于任何外部库。\r\n限于作者业余时间有限，目前功能还在一步步完善，算法还在慢慢添加。\r\n绝大部分算法进行了典型状态测试，但不保证所有算法在所有状态下都是安全的、可靠的。\r\n另外，需要注意的是，此算法库旨在解决问题，而不是实现语言的某些能力，即使作者正在努力使得go语言的独特性在其中充分体现。\r\n如果您对作者的工作满意，请留心关注goNum的更新状态；如果您对作者的工作有所建议，请电邮：chengfengcool@sina.com。\r\n或者，承蒙赏识，如果您愿意捐助关于goNum工作，请电邮联系作者。\r\n\r\n欢迎有志之士加入开发。\r\n\r\n安装环境\r\n=========\r\nLinux或者Windows\r\n1. go 1.11（推荐）或更新版本;\r\n2. [可选] LiteIDE X34或更新版本;\r\n3. 请关注Linux和Windows换行符的区别。\r\n\r\n安装方法\r\n=========\r\n## 1. 在线安装\r\n1. 安装go;\r\n2. 运行go get命令:\r\n```go\r\ngo get github.com/chfenger/goNum\r\n```\r\n## 2. 下载源码安装\r\n1. 下载源代码，并解压到指定文件夹（例如“UserDir”）下的src目录或其子目录（例如“UserDir/src/”或“UserDir/src/xxx/xxx/”）下;\r\n2. 添加UserDir到GOPATH;\r\n3. 重启IDE或终端即可。\r\n\r\n关于命名\r\n==========\r\n1. 包名'goNum'为算法库包;\r\n2. 包名'goNum_test'为测试库包（Benchmark）;\r\n3. 文件名'*_test.go'为测试文件名，其内容可作为算法包使用的参考手册。\r\n\r\n设计初衷\r\n=========\r\n1. 旨在为自己和他人提供一个浅显易懂而又功能强大的数值算法库;\r\n2. 优先保证速度和精度，因此诸如defer等优秀方式由于过于影响速度而并未实际采用;\r\n3. 完全以Go语言开发，独立而不依赖于任何外部库。\r\n\r\n算法\r\n=====\r\n（持续更新中...）\r\n- 基本数学\r\n  - 排列\r\n  - 二分法\r\n  - 组合\r\n  - 阶乘\r\n  - 切片元素最大值\r\n  - 切片元素绝对值最大值\r\n  - 切片元素从大到小排序\r\n  - 切片元素最小值\r\n  - 切片元素绝对值最小值\r\n  - 切片元素从小到大排序\r\n  - 矩阵1范数\r\n  - 矩阵无穷范数\r\n  - 向量的范数\r\n  - 次幂扩展\r\n  - 角度的三角函数和反三角函数\r\n  - 向量在三维空间的旋转\r\n  - Fibonacci数列\r\n  - 多项式求导\r\n\r\n- 数据结构\r\n  - 单向链表\r\n  - 双向链表\r\n  - 树\r\n\r\n- 矩阵\r\n  - 矩阵定义与操作\r\n  - 求矩阵行列式的列主元消去法\r\n  - 返回n阶单位矩阵（二维切片表示）\r\n  - 求矩阵逆的列主元消去法\r\n  - 求对称正定矩阵的平方根分解法\r\n  - 求矩阵Doolittlede LU分解\r\n  - 求对称矩阵全部特征值及其特征向量，经典雅可比法\r\n  - 求对称矩阵全部特征值及其特征向量，雅可比过关法\r\n  - 求矩阵A的主特征值及其特征向量\r\n\r\n- 解一般方程\r\n  - 求解非线性方程的牛顿迭代\r\n  - 搜索法求方程解\r\n  - 单点弦截法\r\n  - 双点弦截法\r\n  - 简单迭代求解类x=g(x)方程的解\r\n  - 简单迭代求解类x=g(x)方程的解（Aitken加速）\r\n  - Muller法求f(x)=0的解\r\n\r\n- 插值\r\n  - Hermite插值\r\n  - Hermite插值函数\r\n  - Lagrange插值\r\n  - Lagrange插值函数\r\n  - Newton插值\r\n  - Newton前向插值\r\n  - 用节点处的一阶导数表示的三次样条插值函数（一阶导数边界条件）\r\n  - 用节点处的一阶导数表示的三次样条插值函数（二阶导数边界条件）\r\n  - 用节点处的二阶导数表示的三次样条插值函数（一阶导数边界条件）\r\n  - 用节点处的二阶导数表示的三次样条插值函数（二阶导数边界条件）\r\n\r\n- 数值积分\r\n  - 1-8级复化Newton-Cotes求积分公式\r\n  - 1-8级逐次分半复化Newton-Cotes求积分公式\r\n  - 不超过8次的Gauss-Lagendre求积分公式\r\n  - 1-8级Newton-Cotes求积分公式\r\n  - Rumberg(龙贝格)求积分公式\r\n\r\n- 解线性方程组\r\n  - 求解矛盾方程组的最小二乘法\r\n  - 追赶法求解严格对角占优的三对角系数矩阵方程组\r\n  - 线性代数方程组的列主元消去法\r\n  - 解n阶线性方程组的Jocobi迭代法（简单迭代法）\r\n  - 解n阶线性方程组的Seidel迭代法\r\n  - 解n阶线性方程组的SOR(逐次超松弛)迭代法\r\n\r\n- 解非线性方程组\r\n  - 多元非线性方程组Seidel迭代\r\n\r\n- 数据拟合\r\n  - 多项式拟合\r\n  - 线性最小二乘拟合\r\n  - Bezier曲线拟合控制点\r\n  - 基于傅立叶（Fourier）级数的三角多项式拟合\r\n\r\n- 误差评估\r\n  - 最大误差\r\n  - 平均误差\r\n  - 均方根误差\r\n\r\n- 优化\r\n  - 黄金分割法求单峰单自变量极小值\r\n  - Fibonacci搜索法求单峰单自变量极小值\r\n  - 单纯形法求多自变量函数极小值\r\n\r\n- 常微分方程\r\n  - 4步Adams外推（ODE）\r\n  - 三步Adams内插公式（ODE）\r\n  - Euler法（ODE）\r\n  - Euler预估校正（ODE）\r\n  - 梯形法（ODE）\r\n  - 二级二阶Runge-Kutta法\r\n  - 四级四阶Runge-Kutta法\r\n  - 四阶Runge-Kutta-Fehlberg变步长\r\n  - Heun法\r\n  - Adams-Bashforth-Moulton预估校正法\r\n  - Milne-Simpson预估校正法\r\n  - Hamming预估校正法\r\n  - 差分法\r\n\r\n- 偏微分方程\r\n  - 双曲型偏微分方程差分解法（第一种差分格式）\r\n  - 双曲型偏微分方程差分解法（第二种差分格式）\r\n  - 抛物型偏微分方程差分解法（显式）\r\n  - 抛物型偏微分方程差分解法（隐式）\r\n  - 抛物型偏微分方程差分解法（六点对称）\r\n  - 椭圆型偏微分方程(Laplace)差分解法（五点格式）\r\n  - 椭圆型偏微分方程(Poisson)的差分解法（五点格式）\r\n  - 椭圆型偏微分方程(Helmholtz)的差分解法（五点格式）\r\n\r\n- 排序\r\n  - 冒泡排序\r\n  - 选择排序\r\n  - 插入排序\r\n  - 希尔（Shell）排序\r\n  - 归并排序\r\n  - 快速排序\r\n  - 堆排序\r\n  - 计数排序\r\n  - 桶排序\r\n  - 基数排序\r\n\r\n作者\r\n=====\r\n详见AUTHOR.MD文件\r\n\r\n许可证书\r\n=========\r\ngoNum是一款开源自由算法库，您可以根据自己的需求发布或者修改，但这一切需要在GNU GPL(General Public License) v3.0\r\n或者较新版本的许可下进行。关于此许可证内容详见根目录下LICENSE文件或者<http://www.gnu.org/licenses/>。\r\n\r\n程锋 版权所有 2018\r\n\r\n致谢\r\n=====\r\n00. 非常感谢家人朋友们的支持和理解，为此推辞了许多业余活动.\r\n01. 特别感谢Google提供如此美妙的编程语言，希望再接再励，继续改善使之丰富。\r\n10. 感谢某实验室提供的免费服务器。\r\n\r\n\r\n"]
rust_book_ru,The Rust Programming Language (на русском) (основной репозиторий теперь здесь: https://github.com/ruRust/rust_book_ru),205,https://github.com/kgv/rust_book_ru,master,['# Введение к русскоязычному переводу\n\nЭта книга представляет собой перевод «The Rust Programming Language». Оригинал\nкниги расположен [здесь][original].\n\nПеревод окончен и соответствует stable версии книги на момент выхода Rust 1.2 stable.\nМогут встречаться несоответсвия оригиналу книги, но написанное здесь актуально\nдля любого Rust 1.x, поскольку Rust гарантирует стабильность языка в пределах\nмажорной версии.\n\n**ВНИМАНИЕ!** Если вы видите несоответствие примеров или текста реальному\n  поведению, пожалуйста, создайте [задачу][error] или сразу делайте Pull Request\n  с исправлениями. Мы не кусаемся и рады исправлениям! :wink:\n\n* [Читать книгу](http://ruRust.github.io/rust_book_ru/)\n* [Скачать в PDF](https://raw.githubusercontent.com/ruRust/rust_book_ru/gh-pages/converted/rustbook.pdf)\n* [Скачать в EPUB](https://raw.githubusercontent.com/ruRust/rust_book_ru/gh-pages/converted/rustbook.epub)\n* [Скачать в MOBI](https://raw.githubusercontent.com/ruRust/rust_book_ru/gh-pages/converted/rustbook.mobi)\n\n# Полезные ссылки\n\nЧаты                                   | Ссылки\n---------------------------------------|--------\nдля обсуждения языка, получения помощи | [![Join the chat at https://gitter.im/ruRust/general](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/ruRust/general?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\nдля обсуждения самой книги и вопросов перевода | [![Join the chat at https://gitter.im/ruRust/rust_book_ru](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/ruRust/rust_book_ru?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n[![ruRust/rust_book_ru](http://issuestats.com/github/ruRust/rust_book_ru/badge/pr?style=flat)](http://issuestats.com/github/ruRust/rust_book_ru)\n[![ruRust/rust_book_ru](http://issuestats.com/github/ruRust/rust_book_ru/badge/issue?style=flat)](http://issuestats.com/github/ruRust/rust_book_ru)\n\n[Мы на Хабре](http://habrahabr.ru/post/266813/)\n\n# Соавторам\n\n## С чего начать\n\nЕсть некоторое количество очень простых проблем. Это\n[опечатки](https://github.com/ruRust/rust_book_ru/labels/%D0%BE%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%BA%D0%B0),\nи, взяв одну из таких задач, вы сможете легко поучаствовать в переводе\nи очень нам поможете.\n\nНе бойтесь code review, у нас не принято наезжать на новичков. :smile:\n\n## Сборка\n\nЕсли вы занялись инфраструктурой, вам понадобится проверять свою работу\nлокально.\n\nСейчас самый простой собрать книгу локально: это проделать те же действия, что\nделает Travis. Смотрите файл `.travis.yml`, разделы `install`, `before_script`,\n`script`, `after_success`. Они должны быть достаточно понятны сами по себе.\n\n## Тестирование\n\nЕсли вы изменили инфраструктуру, следует проверить изменения. Проверка зависит\nот компонента, в который вы внесли изменение.\n\nЕсли это стили и генерация книги - нужно сгенерировать книгу локально и\nпосмотреть, что всё работает как надо. Конвейер преобразования HTML-версии в\nдругие варианты проверяется так же.\n\nЕсли вы внесли изменения в скрипты, вызываемые Travis, или в сам `.travis.yaml`,\nпожалуйста, следите за статусом сборки - он отображается в PR. PR, который не\nпроходит сборку, принят не будет.\n\n## Где получить помощь\n\nУ этого репозитория есть чат-комната на Gitter. Если у вас возник\nвопрос по задаче или по тому, что вы взялись делать, как перевести\nкакой-то термин или как собрать книгу локально - вам\n[сюда](https://gitter.im/ruRust/rust_book_ru).\n\n## Для опытных\n\n[Правила перевода](https://github.com/ruRust/rust_book_ru/wiki/Правила).\n\n## Благодарности\n\nВыражаем благодарность [всем, кто принимал участие в создании этой\nкниги][authors].\n\nОт @kgv: «Хочу поблагодарить моих родителей: **Таню** и **Володю**. Без них не\nбыло бы этой книги».\n\n## Ошибки\n\nЕсли вы встретили ошибку или неточность, пожалуйста, [напишите о ней][error].\n\n## Ресурсы\n\n* rustbook расположен [здесь][rustbook]\n* репозиторий расположен [здесь][github]\n\n[authors]: https://github.com/ruRust/rust_book_ru/blob/master/AUTHORS.md\n[original]: https://doc.rust-lang.org/book\n[github]: https://github.com/ruRust/rust_book_ru\n[error]: https://github.com/ruRust/rust_book_ru/issues\n[rustbook]: http://ruRust.github.io/rust_book_ru\n']
naskah,Bahasa pemrograman dengan sintaks Bahasa Indonesia (Programming language with Indonesian syntax) 🇮🇩,154,https://github.com/pveyes/naskah,master,['# naskah [![Actions Status](https://github.com/pveyes/naskah/workflows/build/badge.svg)](https://github.com/pveyes/naskah/actions)\n\n> Bahasa pemrograman dengan sintaks Bahasa Indonesia\n\nDemo: https://naskah.vercel.app/\n\n## Tipe data\n\nSaat ini hanya 4 tipe data yang didukung oleh naskah:\n\n- angka `123`\n- huruf `"hello"`\n- boolean `benar` / `salah`\n- kosong `kosong`\n\n## Operator\n\nOperasi yang didukung oleh `naskah` adalah:\n\n- Penjumlahan `+`\n- Pengurangan `-`\n- Perkalian `*`\n- Pembagian `\\`\n- Sisa pembagian `%`\n- Pangkat `^`\n\nSelain itu ada juga operasi untuk membandingkan dua variabel / tipe data\n\n- Sama dengan `==`\n- Tidak sama dengan `!=`\n- Lebih dari `>`\n- Kurang dari `<`\n\n## Sintaks\n\n### Deklarasi variabel\n\n```\nmisal x = 4;\nmisal y = x;\n```\n\n### Percabangan\n\n```\njika x == 2 {\n\n}\n\njika x == kosong {\n\n}\n```\n\nUntuk kasus-kasus umum, naskah menyediakan sintaks khusus untuk pengecekan terhadap `kosong`, `benar` dan `salah`. Tidak perlu menulis operator `==`, cukup `x kosong`.\n\n```\njika x kosong {\n\n}\n```\n\n### Perulangan\n\nNaskah saat ini hanya mempunyai 1 tipe perulangan yang tidak pernah berhenti\n\n```\nulang {\n\n}\n```\n\nUntuk berhenti di dalam perulangan, dapat menggunakan sintaks `berhenti;`\n\n```\nulang {\n  jika x > 2 {\n    berhenti;\n  }\n}\n```\n\n## Lisensi\n\nBahasa pemrograman Naskah terlisensi dibawah lisensi MIT.\n']
Assembly,⚡ 亲手编写实现基于王爽老师《汇编语言》的300个汇编程序例程 | Implementation of 300 assembly program examples based on "Assembly Language" ,144,https://github.com/NekoSilverFox/Assembly,master,['<p align="center">\n <img width="100px" src="https://github.com/NekoSilverFox/NekoSilverfox/blob/master/icons/silverfox.svg" align="center" alt="Assembly" />\n <h1 align="center">Assembly</h2>\n <p align="center"><b>⚡ 亲手编写基于王爽老师《汇编语言》的300个汇编程序例程</b></p>\n</p>\n\n<div align=center>\n\n [![License](https://img.shields.io/badge/license-Apache%202.0-brightgreen)](LICENSE)\n\n<div align=left>\n\n---\n\nIn this folder, I recorded notes and codes for learning assembly language in the summer vacation of 2020. :P\n\n注：部分代码及练习基于王爽《汇编语言》第三版，具体题目及要求请见书中\n\n</br>\n \n**笔记请详见：**\n \n[这是 Word 格式的笔记呀](https://github.com/NekoSilverFox/Assembly/blob/master/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.docx)\n \n</br>\n  \n文件夹编号说明：\n\n其中，为了避免文件夹命名及编号混乱：【预留空位】指的是为以后复习或者相关新项目所预留出来的编号。\n\n---\n\n| 编号      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| 1 - 2     | 基础                                                         |\n| 3 - 17    | 基于loop指令的代码及练习                                     |\n| 18 - 20   | 【预留空位】loop指令预留空位                                 |\n| 21 - 27   | and和or指令                                                  |\n| 28 - 30   | 【预留空位】and和or指令                                      |\n| 31 - 32   | byte ptr 字节型数据 和 word ptr 字型数据                     |\n| 33 - 35   | 【预留空位】                                                 |\n| 36 - 40   | div除法操作                                                  |\n| 41 - 45   | div指令【预留空位】                                          |\n| 46 - 47   | 寻址方式在结构化数据访问中的应用                             |\n| 48 - 50   | 【预留空位】                                                 |\n| 51        | offset操作符                                                 |\n| 52 - 55   | 【预留空位】                                                 |\n| 56 - 65   | JMP指令                                                      |\n| 66        | jcxz条件转移指令                                             |\n| 67 - 69   | 【预留空位】                                                 |\n| 70        | LOOP循环指令                                                 |\n| 71 - 74   | 【预留空位】                                                 |\n| 74 - 77   | 向屏幕彩色输出【实验9】                                      |\n| 78 - 80   | 【预留空位】                                                 |\n| 82 - 83   | ret、retf指令                                                |\n| 84 - 85   | 【预留空位】                                                 |\n| 86 - 90   | 几种call的简介                                               |\n| 91 - 98   | call指令与ret的联合应用                                      |\n| 99 - 100  | 【预留空位】                                                 |\n| 101 - 102 | mul乘法指令                                                  |\n| 103 - 106 | 利用子程序的对字符串进行大小写转换                           |\n| 106 - 110 | 【预留空位】                                                 |\n| 111 - 117 | 设计一简化版（整理内存段中的数据、进行乘除法、将数值转化为对应的ASCII码） |\n| 118 - 119 | 【预留空位】                                                 |\n| 120 - 126 | 初步显示字符串                                               |\n| 127 - 129 | 【预留空位】                                                 |\n| 130 - 132 | adc指令                                                      |\n| 136       | sbb指令                                                      |\n| 140 - 146 | cmp条件判断指令                                              |\n| 150 - 151 | rep movsb、cld/std实现数据正向/逆向传送                      |\n| 160       | 以0结尾的字符串中小写字母转大写【综合运用】                  |\n| 170       | 错误信息写入中断向量表【内中断】                             |\n| 180 - 188 | 中断例程的运用                                               |\n| 199       | 使用加法和位移指令计算(ax)=(ax)x10                           |\n| 200 - 202 | 端口的初步造作                                               |\n| 205       | 以“年-月-日 时;分;秒”的格式，显示当前时间                    |\n| 220 - 224 | 键盘中断例程                                                 |\n| 240 - 248 | 通过标号定位数据、直接定址表                                 |\n| 260 - 261 | 接受键盘输入                                                 |\n| 300 - 310 | C/C++ 下汇编测试                                             |\n| 500       | 高级汇编例程                                                 |\n\n\n\n---\n\n编程小技巧：\n将ds与si配合使用\n将es与di配合使用\t<--- 虽然es和si可以配合使用，但是介于后面涉及的课程及指令，不建议使用 ds:di,、es:si ！！\n\n在对程序分段时，如果遇到寄存器冲突，可以先将冲突的寄存器push到栈中，需要时再pop出来\n\n如果合理的使用db, dw, dd ==> 看操作的寄存器，比如：操作的寄存器为16位，则应该用dw\n\n如果参数过多，要处理的数据使用较多的寄存器，那么可以先将数据进行结构化处理再进行编写代码，这样可以更好的处理数据\n\n将字符串显示在屏幕上（B800H）时，一定要注意将存放属性的高位字节写入数据，否则会造成无法显示\n将字符串显示在屏幕上（B800H）时，先输出余数，在对ax中的商是否为零进行判断，否则会造成以零为结尾的数值无法显示\n\n将int型数值转换为string字符串时，在进行除10取余时，每显示完一个字符，记得将储存高位字节的dx清零\n\n在编写子程序时，可在程序开头处将程序中用到的寄存器进行push，在ret前再进行pop，这样就不用考虑是否会影响到程序外的寄存器（注意push和pop的顺序）\n']
SkyCode-AI-CodeX-GPT3,SkyCode是一个多语言开源编程大模型，采用GPT3模型结构，支持Java, JavaScript, C, C++,  Python, Go, shell等多种主流编程语言，并能理解中文注释。模型可以对代码进行补全，拥有强大解题能力，使您从编程中解放出来，专心于解决更重要的问题。| SkyCode is an open source programming model, which adopts the GPT3 model structure. It supports Java, JavaScript, C, C++, Python, Go, shell and other languages, and can understand Chinese comments. ,205,https://github.com/SkyWorkAIGC/SkyCode-AI-CodeX-GPT3,main,['# SkyCode\n\nSkyCode是由奇点智源发布的多语言开源编程大模型，采用GPT3模型结构，使用海量的代码进行训练。支持Java, JavaScript, C, C++, Python, Go, shell等多种主流编程语言，并能理解中文注释。模型可以对代码进行补全，进行解题等操作，使您从编程中解放出来，专心于解决更大的问题。\n\n![image](https://user-images.githubusercontent.com/120169448/208900581-66f06b02-659b-4666-925e-8bd0138fd34b.png)\n![image](https://user-images.githubusercontent.com/120169448/208900631-c8eae4a3-0fd0-4b5a-a960-01e50c4fe1f1.png)\n\n#### Hugging Face 模型主页：https://huggingface.co/SkyWork/SkyCode\n\n# 项目亮点\n\n1. 技术优势一 ：涵盖多种编程语言\n   \n   不同的编程语言着重于解决不同平台、环境下的问题，不同的编程语言都有自己存在的理由。奇点智源SkyCode能够生成的代码，不仅包括使用广泛的JavaScript、python、Java、C等，还涵盖了php、go、swift等共计十余种编程语言，使不同语言的使用者都能来体验SkyCode强大的代码生成能力。\n\n2. 技术优势二：针对中文注释进行优化\n   \n   曾经在预训练大模型领域，一直是被英文社区主导着，依托于GPT3的代码生成模型有着同样的问题。奇点智源凭借深耕中文模型的经验，针对中文的特点，优化创新使用了独特的中文编码方式，更加符合中文的语言习惯，使得模型对中文注释的理解能力更为优秀。\n\n3. 技术优势三：极其出色的解题能力\n   \n   在体现代码生成模型解题能力的HumanEval数据集上，奇点智源SkyCode的解题能力也远高出其他开源模型。\n   \n   | model          | pass@1 | pass@10 | pass@100 |\n   |:-------------- | ------:|:-------:| -------- |\n   | GPT-Neo 1.3B   | 4.79%  | 7.47%   | 16.30%   |\n   | GPT-Neo 2.7B   | 6.41%  | 11.27%  | 21.37%   |\n   | GPT-J 6B       | 11.62% | 15.74%  | 27.74%   |\n   | SKY_code(2.6B) | 12.84% | 21.07%  | 35.97%   |\n   \n   可以看到，参数量2.6B的SkyCode在解题能力上不仅高出参数较少的GPT-Neo 1.3B许多，也远高于参数量相当的GPT-Neo 2.7B模型。即使对比参数量更高的GPT-J 6B模型，SkyCode的解题能力也更强。在更能体现解题能力上限的pass@100指标上，SkyCode超出GPT-J的净值为8.23%。\n\n\n# 奇点新闻\n\n- [2022.12.15] [昆仑天工AIGC发布会](https://live.vhall.com/v3/lives/subscribe/697547540)\n  \n\n——————————————————————————————————————————————————————————\n\n## 依赖\n\n```\n推荐\ntransformers>=4.18.0\n```\n\n## 模型使用\n\n```python\n# -*- coding: utf-8 -*-\nfrom transformers import GPT2LMHeadModel\nfrom transformers import AutoTokenizer\nfrom transformers import TextGenerationPipeline\n\nmodel = GPT2LMHeadModel.from_pretrained("SkyWork/SkyCode")\ntokenizer = AutoTokenizer.from_pretrained("SkyWork/SkyCode", trust_remote_code=True)\ntext_generator = TextGenerationPipeline(model, tokenizer, device=0)\ninput_str = "if __name__"\nmax_new_tokens = 40\nprint(text_generator(input_str, max_new_tokens=max_new_tokens, do_sample=True))\n```\n\n## huggingface模型主页\n\nhttps://huggingface.co/SkyWork/SkyCode\n\n\n# 版权许可\n\n[MIT License](LICENSE)\n\n# 加入开发者群\n#### 微信扫码，加入SkyCode开发者群：\n\n![code](https://user-images.githubusercontent.com/120169448/211475834-edce447b-15ed-4534-ba06-1589bb2151c2.jpg)\n\n#### 感兴趣别忘了star一下~\n\n![image](https://user-images.githubusercontent.com/120169448/222312376-9922637f-36e7-4212-b8ce-3d19fc2deb96.png)\n\n\n\n']
the-swift-programming-language-in-traditional-chinese,正體中文版,110,https://github.com/tommy60703/the-swift-programming-language-in-traditional-chinese,master,['《正體中文版蘋果 Swift 官方教學》\n=============================================\n\n正體中文版蘋果 Swift 官方教學《The Swift Programming Language》\n\n# 當前階段\n\n正在翻譯 Swift 2.0 版 (swift-2.0分支)，翻譯完成後會取代 master 並在 gitbook 上正式發佈。\n\n簡體中文版已由[numbbbbb]團隊翻譯完成，文字部分已經全部正體中文化。歡迎校對，可以隨意提 issue。\n\n# 譯者記錄\n\n* [簡體中文]\n* 簡轉繁：[tommy60703]\n* Swift 2.0：[tommy60703]\n* 校對：[jayhsu], [ckvir], [rsbrian], [hcjao], [petertom51], [rocooshiang], [yulin0629], [hugolu]\n\n# 貢獻力量\n\n如果想做出貢獻的話，你可以：\n\n- 幫忙校對，挑錯別字、語病等等\n- 提出修改建議\n- 提出術語翻譯建議\n\n# 翻譯建議\n\n如果你願意一起校對的話，請仔細閱讀：\n\n- 使用 markdown 進行翻譯，文件名必須使用英文，因為中文的話 gitbook 編譯的時候會出問題\n- 引號請使用「」和『』\n- fork 過去之後新建一個分支進行翻譯，完成後 pull request 這個分支，沒問題的話我會合併到 master 分支中\n- 有其他任何問題都歡迎發 issue，我看到了會盡快回覆\n\n謝謝！\n\n# 關於術語\n\n翻譯術語的時候請參考這個流程：\n\n- 盡量保證與台灣習慣術語和已翻譯的內容一致\n- 盡量先搜尋，一般來說程式語言的大部分術語是一樣的，可以參考[這個網站](http://jjhou.boolan.com/terms.htm)\n- 如果以上兩條都沒有找到合適的結果，請自己決定一個合適的翻譯或者直接使用英文原文，後期校對的時候會進行統一\n- 校稿時，若有發現沒有被翻譯成台灣術語的大陸術語，請發 issue\n- 可以主動提交替換過的文本的 pull request 給我\n\n對翻譯有任何意見都歡迎發 issue，我看到了會盡快回覆\n\n# 參考流程\n\n有些朋友可能不太清楚如何幫忙翻譯，我這裡寫一個簡單的流程，大家可以參考一下：\n\n1. 首先 fork 我的項目\n2. 把 fork 過去的項目也就是你的項目 clone 到你的本地\n3. 在命令行運行 `git branch develop` 來創建一個新分支\n4. 運行 `git checkout develop` 來切換到新分支\n5. 運行 `git remote add upstream https://github.com/tommy60703/the-swift-programming-language-in-traditional-chinese` 把我的庫添加為遠端庫\n6. 運行 `git remote update`更新\n7. 運行 `git fetch upstream master` 拉取我的庫的更新到本地\n8. 運行 `git rebase upstream/master` 將我的更新合並到你的分支\n\n這是一個初始化流程，只需要做一遍就行，之後請一直在 develop 分支進行修改。\n\n如果修改過程中我的庫有了更新，請重復 6、7、8 步。\n\n修改之後，首先 push 到你的 repo，然後登錄 GitHub，在你的 repo 的首頁可以看到一個 `pull request` 按鈕，點擊它，填寫一些說明資訊，然後提交即可。\n\n\n# 開源協議\n基於[WTFPL](http://en.wikipedia.org/wiki/WTFPL)協議開源。\n\n\n[簡體中文]:https://github.com/numbbbbb/the-swift-programming-language-in-chinese\n[tommy60703]:https://github.com/tommy60703\n[jayhsu]:https://github.com/jayhsu21\n[ckvir]:https://github.com/ckvir\n[hcjao]:https://github.com/hcjao\n[rsbrian]:https://github.com/briansheng\n[petertom51]:https://github.com/petertom51\n[rocooshiang]:https://github.com/rocooshiang\n[yulin0629]:https://github.com/yulin0629\n[hugolu]:https://github.com/hugolu\n']
go-dep-parser,Dependency Parser for Multiple Programming Languages,108,https://github.com/aquasecurity/go-dep-parser,main,['# go-dep-parser\nDependency Parser for Multiple Programming Languages\n']
sctp,SCTP library for the Go programming language,110,https://github.com/ishidawataru/sctp,master,['Stream Control Transmission Protocol (SCTP)\n----\n\n[![Build Status](https://travis-ci.org/ishidawataru/sctp.svg?branch=master)](https://travis-ci.org/ishidawataru/sctp/builds)\n\nExamples\n----\n\nSee `example/sctp.go`\n\n```go\n$ cd example\n$ go build\n$ # run example SCTP server\n$ ./example -server -port 1000 -ip 10.10.0.1,10.20.0.1\n$ # run example SCTP client\n$ ./example -port 1000 -ip 10.10.0.1,10.20.0.1\n```\n']
Practical-Design-Patterns,Practices of Design Patterns in programming languages,106,https://github.com/khajavi/Practical-Design-Patterns,master,['Design-Patterns\n===============\n<div dir="rtl">\n# هدف ما\nما می\u200cخواهیم مجموعهٔ به-روز و کاملی از الگوهای طراحی را ایجاد کنیم. مجموعه\u200cای که شامل مثال\u200cهای متنوع و کاربردی از تمام زبان\u200cهای برنامه\u200cنویسی باشد.\n\n# همکاری\nبرای شروع به همکاری\n- مخزن را [فورک کنید](https://help.github.com/articles/fork-a-repo)، یک انشعاب (Branch) درست کنید، شروع به کار کنید و کارتان را به مخزن اعمال کنید، آن انشعاب را به گیت\u200cهاب push کنید، و [درخواست Pull را ارسال کنید](https://help.github.com/articles/creating-a-pull-request).\n- یا درخواست\u200cتان را از طریق [issue](https://github.com/khajavi/Design-Patterns/issues) بیان کنید.\n- برای رسم دیاگرام\u200cهای UML از نرم\u200cافزار [Visual Paradigm](http://www.visual-paradigm.com/download/vpuml.jsp?edition=ce) استفاده شده است، در صورتی که می\u200cخواهید دیاگرامی اضافه کنید، برای هماهنگی تصاویر پیشنهاد می\u200cشود از همین نرم\u200cافزار استفاده کنید.\n\n# استفاده از مثال\u200cها\n- هر الگو یک پوشه به نام Classic دارد که نام کلاس\u200cهای آن از دیاگرام\u200cهای کتاب GoF گرفته شده است. مثال\u200cهای Classic ایدهٔ اولیه برای الگوها هستند و برای یادگیری ساختار الگوها مناسبند. اما برای آشنایی با کاربرد آن\u200cها مثال\u200cهای دیگری غیر از Classic درون پوشهٔ هر الگو گنجانده شده است.\n- برای سادگی بیشتر در مثال\u200cهای C++، مباحث مدیریت حافظه و جلوگیری از Memory Leak مطرح نشده است از این رو در صورتی که می\u200cخواهید این الگوها را در یک پروژهٔ واقعی استفاده کنید، حواستان باشد که اشیاء را در حافظه مدیریت کنید.\n\n<div dir="ltr">\n\n## Creational Patterns\n<div dir="rtl">\n- [Abstract Factory](Creational/AbstractFactory): بدون مشخص کردن کلاس\u200cهای کانکرت، واسطی برای ساخت خانواده\u200cای از اشیاء وابسته یا مرتبط با یکدیگر فراهم می\u200cکند.\n\n- [Builder](Creational/Builder): روند ساخت یک شیء پیچیده را از نمایش آن جدا می\u200cکند به طوری که یک روند ساخت مشترک می\u200cتواند برای ساخت انوع بازنمایی\u200cها به کار گرفته شود.\n\n- [Factory Method](Creational/FactoryMethod): واسطی برای ساخت اشیاء ایجاد می\u200cکند، اما به زیرکلاس\u200cها اجازه می\u200cدهد که تصمیم بگیرند که چه کلاسی را نمونه\u200cسازی کنند. این الگو اجازه می\u200cدهد تا نمونه\u200cبرداری کلاس، به زیرکلاس\u200cها معوق شود.\n\n- [Prototype](Creational/Prototype): انواع اشیائی که باید ساخته شوند را با استفاده از یک نمونهٔ اولیه، مشخص می\u200cکند و اشیاء جدید را با کپی کردن این نمونهٔ اولیه تولید می\u200cکند.\n\n- [Singleton](Creational/Singleton): تضمین می\u200cکند که کلاس تنها یک نمونه داشته باشد و دسترسی سراسری برای آن فراهم می\u200cکند.\n\n<div dir="ltr">\n\n## Structural Patterns\n<div dir="rtl">\n- [Adapter](Structural/Adapter): یک واسط را به واسط مورد نظر کلاینت تبدیل می\u200cکند و اجازه می\u200cدهد تا کلاس\u200cها با اینترفیس\u200cهای متفاوت و ناسازگار با یکدیگر کار کنند.\n\n- [Bridge](Structural/Bridge): لایهٔ انتزاع را از لایهٔ پیاده\u200cسازی جدا می\u200cکند، بنابراین دو کلاس می\u200cتوانند مستقلاً تغییر کنند.\n\n- [Composite](Structural/Composite): اشیاء را درون ساختار درختی ترکیب می\u200cکند تا سسله-مراتب جز-کل را ارائه کند. الگوی کامپوزت به کارخواه\u200cها اجازه می\u200cدهد تا با اشیاء تکی و با اشیائی که ترکیبی از اشیاء هستند، به یک صورت رفتار کند.\n\n- [Decorator](Structural/Decorator): وظایف و قابلیت\u200cهای بیشتری را به صورت داینامیک به شیء اضافه می\u200cکند. دکوریتورها برای توسعهٔ رفتارها و قابلیت\u200cها روش انعطاف\u200cپذیر جایزینی را به جای زیرکلاس\u200cسازی ارائه می\u200cدهند.\n\n- [Facade](Structural/Facade): واسط یکپارچه\u200cای را برای مجموعه\u200cای از واسط\u200cها در زیر سیستم، ارائه می\u200cدهد. این الگو واسط سطح-بالاتری را تعریف می\u200cکند که استفاده از زیرسیستم را ساده\u200cتر می\u200cکند.\n\n- [Flyweight](Structural/Flyweight): استفادهٔ دوبارهٔ بسیاری از اشیاء fine-grain را با اشتراک آن\u200cها در سیستم، آسان می\u200cکند.\n\n- [Proxy](Structural/Proxy): برای کنترل دسترسی به اشیاء، نماینده یا نگهدارنده\u200cای برای آن\u200cها ارائه می\u200cکند.\n\n<div dir="ltr">\n\n## Behavioural Patterns\n<div dir="rtl">\n- [Chain Of Responsibility](Behavioural/ChainOfResponsibility): با دادن بیشتر از یک شیء برای هندل کردن درخواست از جفتگری (کوپلینگ) فرستندهٔ درخواست و گیرندهٔ درخواست اجتناب می\u200cکند. اشیاء گیرنده را زنجیر می\u200cکند و درخواست را در امتداد زنجیر گذر می\u200cدهد تا زمانی که یکی از اشیاء آن را هندل کند.\n\n- [Command](Behavioural/Command): درخواست را به عنوان یک شیء کپسوله می\u200cکند، از این رو اجازه می\u200cدهد تا بتوانید کارخوه\u200cها را با درخواست\u200cها، صف\u200cها و یا لاگ\u200cهای متفاوت پارامتری کنید.\n\n- [Interpreter](Behavioural/Interpreter): یک بازنمایی برای گرامر زبان داده شده تعریف می\u200cکند و مفسر توسط این باز نمایی، جملات زبان را تفسیر می کند.\n\n- [Iterator](Behavioural/Iterator): روشی برای دستری به عناصر یک شیء اگریگیت فراهم می\u200cکند بدون اینکه اصول پیاده\u200cسازی و ساختمان دادهٔ لایهٔ زیرین اگریگیت را نمایش دهد.\n\n- [Mediator](Behavioural/Mediator): شیء\u200cای را تعریف می\u200cکند که نحوهٔ ارتباط بین مجوعه\u200cای از اشیاء را کپسوله می\u200cکند. این الگو با جلوگیری ارتباط صریح بین اشیاء از جفتگری ضعیف (loose coupling) پشتیبانی می\u200cکند.\n\n- [Memento](Behavioural/Memento): بدون تخلف از کپسوله\u200cسازی، وضعیت داخلی شیء ضبط و استخراج می\u200cکند از این رو شیء بعداً می\u200cتواند به این حالت برگردد.\n\n- [Observer](Behavioural/Observer): وابستگی یک-به-چند بین اشیاء تعریف می\u200cکند بنابراین وقتی یک شیء وضعیت\u200cاش را تغییر می\u200cدهد، تمامی اشیاء وابسته به آن از آن تغییر مطلع شده و به صورت خودکار به روز می\u200cشوند.\n\n- [State](Behavioural/State): به شیء این اجازه را می\u200cدهد که وقتی وضعیت درونی\u200cاش تغییر کرد، رفتارش را تغییر دهد. به نظر می\u200cرسد که شیء کلاس خود را عوض می\u200cکند.\n\n- [Strategy](Behavioural/Strategy): خانواده\u200cای از الگوریتم ها را تعریف می\u200cکند، هر یک را کپسوله می\u200cکند و آن\u200cها را جابه\u200cجا پذیر می\u200cکند. الگوی استراتژی اجازه می\u200cدهد که الگوریتم\u200cها مستقل از کارخواهی که از آن\u200cها استفاده می\u200cکند، تغییر کنند.\n\n- [Template Method](Behavioural/TemplateMethod): استخوان\u200cبندی و شالودهٔ اصلی عملیات الگوریتم را تعریف می\u200cکند، و پیاده\u200cسازی هر مرحله را به زیرکلاس\u200cها می\u200cسپارد. این الگو، به زیرکلاس\u200cها این اختیار را می\u200cدهد که تا خودشان، مراحل الگوریتم را پیاده کنند بدون اینکه ساختار الگوریتم را تغییر دهند.\n\n- [Visitor](Behavioural/Visitor): اعمالی که باید روی عناصری از شیء اجرا شود را ارائه می\u200cکند. این الگو اجازه را می\u200cدهد تا اعمال جدیدی تعریف کنید بدون اینکه کلاس\u200cهایی که این اعمال روی آن\u200cها انجام می\u200cشود را تغییر دهید.\n\n\n\n# سپاسگزاری\n- با تشکر از [استینلی شیکو](https://github.com/shyiko) که دیاگرام\u200cهای UML را رسم کرده است و اجازهٔ استفاده از آن\u200cها در پروژه را به من داد.\n- با تشکر از [شیانگ وانگ](http://www.cppblog.com/converse/) که ایدهٔ اصلی مثال\u200cهای سی\u200cپلاس\u200cپلاس بخش Classic از اوست، اکثر این مثال\u200cها در حقیقت ساده شده و مشتقی از کار شیانگ محسوب می\u200cشود که اجازهٔ استفاده از آن\u200cها را به من داد.\n\n# معرفی کتاب\n<div dir="ltr">\n- [Gang Of Four (GoF) : Design Patterns Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Help Ralph Johnson, and John Vlisides.](http://c2.com/cgi/wiki?GangOfFour)\n- [Head First Design Patterns by Eric and Elisabeth Freeman.](http://c2.com/cgi/wiki?HeadFirstDesignPatterns)\n']
Shellcode-Loader,Open repository for learning dynamic shellcode loading (sample in many programming languages),116,https://github.com/ReversingID/Shellcode-Loader,master,['# Shellcode Loader\n\nOpen repository for learning dynamic shellcode loading.\n\n### Disclaimer\n\nFor english version, see [README.EN.md](README.EN.md)\n\nRepository ini digunakan untuk menghimpun informasi tentang teknik memuat shellcode ke memory yang digunakan oleh implant. Repository ini terbuka untuk publik, dapat diakses oleh siapa saja baik oleh internal maupun di luar komunitas `Reversing.ID`.\n\n### Content\n\nUntuk memudahkan klasifikasi, repository ini dibagi menjadi beberapa kategori berdasarkan platform (OS) dan teknik memuat kode. Setiap direktori mengacu kepada sebuah teknik dan berisi informasi singkat serta implementasi dalam bahasa pemrograman tertentu (umumnya C/C++).\n\nCatatan: teknik-teknik akan difokuskan kepada arsitektur x86.\n\n### Shellcode Overview\n\n`Shellcode` adalah potongan kode/instruksi dengan tujuan spesifik untuk melakukan aksi tertentu. Dalam eksploitasi shellcode digunakan sebagai payload (muatan) untuk disuntikkan ke suatu sistem dengan batasan tertentu. \n\nSecara teori shellcode dapat melakukan aksi apapun. Awalnya shellcode hanyalah instruksi untuk memanggil shell. Shellcode kemudian berkembang dan memiliki tujuan bervariasi seperti menciptakan user, menghapus data, dll.\n\nUntuk melihat kumpulan shellcode, kunjungi [shellcodes repository](https://github.com/ReversingID/shellcodes).\n\nUntuk melakukan penyuntikan shellcode ke process, kunjungi [injection repository](https://github.com/ReversingID/injection).\n\nUntuk penyederhanaan, shellcode yang digunakan akan dibatasi hanya kepada kode berikut:\n\n```\n# 9090CCC3\n\n0000:  90      nop\n0001:  90      nop\n0002:  CC      in3\n0003:  c3      ret\n```\n\n### Techniques\n\nRepository ini akan membahas proses dasar dalam sebuah pemuatan shellcode, yakni:\n- `allocation`: strategi alokasi memory untuk menampung shellcode (sebagai kode).\n- `storage`: strategi penyimpanan shellcode.\n- `execution`: strategi eksekusi shellcode.\n- `writing`: strategi menulis kode ke memory (sendiri), baik secara langsung maupun melalui proses transformasi tertentu.\n\nSebagian teknik memanfaatkan API yang disediakan oleh OS, baik secara langsung maupun tak langsung.']
Awesome-Interviews,Awesome Interviews for Coder, Programming Language, Software Engineering, Web, Backend, Distributed Infrastructure, DataScience & AI | 面试必备,117,https://github.com/wx-chevalier/Awesome-Interviews,master,['![题图](https://i.postimg.cc/LXfPysx5/image.png)\n\n# Awesome Interviews\n\n古语有云，知行合一，学以致用，Awesome Interviews 系列不仅仅是为了应对面试，也是对整个 ITCS 体系融会贯通的程度的检验；同时 Awesome Interviews 也包含了笔者多年面试与考察候选人的心得体会。\n\n- 点面结合：网状问题点状问，点状问题网状问，如果是一个复杂的网状问题，你就考他是不是能够三言两语跟外行说清楚。如果是一个简单的问题呢？你就看他能不能把它还原成一个知识网络。\n- 正反结合：对于某个技术、框架，不仅要问它的优势，也要问在实际应用过程中感受到的痛点与不足。\n\n本篇也希望能够将面试扩展于算法之外，使得面试尽可能贴合日常工作所需。\n\n更多介绍与导览参阅 [INTRODUCTION](./INTRODUCTION.md)。\n\n# About\n\n## Acknowledgements\n\n- [反向面试](https://github.com/yifeikong/reverse-interview-zh)\n\n## Copyright & More | 延伸阅读\n\n[![技术视野](https://s3.ax1x.com/2021/02/21/yTSKdH.png)](https://github.com/wx-chevalier/Awesome-MindMaps)\n\n您还可以前往 [NGTE Books](https://ng-tech.icu/books-gallery/) 主页浏览包含知识体系、编程语言、软件工程、模式与架构、Web 与大前端、服务端开发实践与工程架构、分布式基础架构、人工智能与深度学习、产品运营与创业等多类目的书籍列表：\n\n[![NGTE Books](https://s2.ax1x.com/2020/01/18/19uXtI.png)](https://ng-tech.icu/books-gallery/)\n']
pakhi-bhasha,Dynamically typed bangla programming language written in rust,121,https://github.com/Shafin098/pakhi-bhasha,master,['## <a href="#">Introduction</a>\nPakhi is a dynamically typed, general purpose programming language with Bangla alphabet written in rust.\n## <a href="#">Language basics</a>\n***\n#### <a href="#">PrimitiveTypes</a>\n- __সংখ্যা_\n- __বুলিয়ান_\n- __স্ট্রিং_\n- __লিস্ট_\n- __রেকর্ড_\n- __ফাং_\n- __শূন্য_\n#### <a href="#">Variable declaration</a>\n```\nনাম মাস = ১;\n```\n#### <a href="#">Print statement</a>\n```\nদেখাও মাস;\n```\n#### <a href="#">If-else statement</a>\n```\nযদি মাস == ১ {\n    দেখাও "জানুয়ারি";\n} অথবা {\n    দেখাও "জানা নেই";\n}\n```\n#### <a href="#">List</a>\n```\nনাম সংখ্যা = [১, ২, ৩, ৪, ৫];\nদেখাও সংখ্যা[০];\n```\n#### <a href="#">Record</a>\n```\nনাম তথ্য =  @{\n    "নাম" -> "সিফাত",\n    "বয়স" -> ৪২,\n    "ফোন-নাম্বার" -> ["০১৭১১১১১১১১", "০১৭৩৩৩৩৩৩৩৩"],\n};\nদেখাও তথ্য["নাম"];\nদেখাও তথ্য["বয়স"];\nদেখাও তথ্য["ফোন-নাম্বার"];\n```\n#### <a href="#">Loop statement</a>\n```\nনাম সংখ্যা = [১, ২, ৩, ৪, ৫];\nনাম ইন্ডেক্স = ০;\nনাম যোগফল = ০;\nলুপ {\n    যদি ইন্ডেক্স > ৪ {\n        থামাও;\n    }\n    যোগফল = যোগফল + সংখ্যা[ইন্ডেক্স];\n    ইন্ডেক্স = ইন্ডেক্স + ১;\n} আবার;\n_দেখাও "ফলাফল = ";\nদেখাও যোগফল;\n```\n#### <a href="#">Function declaration and function call</a>\n```\nফাং জোড়(সংখ্যা) {\n  যদি সংখ্যা % ২ == ০ {\n    দেখাও "সংখ্যাটি জোড়";\n  } অথবা {\n    দেখাও "সংখ্যাটি বিজোড়";\n  }\n} ফেরত;\n\nনাম স = ৪২;\nজোড়(স);\n```\n#### <a href="#">Importing modules</a>\nEvery pakhi source file is a module. Module can be imported with realtive path or absolute path.<br>\n*Module import syntax: ```মডিউল মডিউল-নাম = "মডিউল-পাথ";```*<br>\n*Module use syntax: ```মডিউল-নাম/মডিউলের-ফাংশন();```*\n```\n# এটা হচ্ছে রুট মডিউল ফাইল: main.pakhi #\nমডিউল ম্যাথ = "math.pakhi";\nনাম বাহু = ৩;\nনাম ক্ষেত্রফল = ম্যাথ/বর্গ(বাহু);\nদেখাও ক্ষেত্রফল;\n```\n```\n# \nএটা হচ্ছে ম্যাথ মডিউল ফাইল: math.pakhi\nরুট মডিউল এই ফাইল এর বর্গ ফাংশনকে ইম্পোর্ট করেছে। \n#\nফাং বর্গ(সংখ্যা) {\n    ফেরত সংখ্যা * সংখ্যা;\n} ফেরত;\n```\n#### <a href="#">Comment block</a>\n```\n# এক লাইন কমেন্ট #\n\n# \nমালটি লাইন\nকমেন্ট\n#\n\n# রেকর্ড ডিক্লেয়ার করা #\nনাম তথ্য =  @{\n    "নাম" -> "সিফাত",\n    "বয়স" -> ৪২,\n    "ফোন-নাম্বার" -> ["০১৭১১১১১১১১", "০১৭৩৩৩৩৩৩৩৩"],\n};\n#\nরেকর্ড থেকে ব্যক্তির\nনাম, বয়স, ফোন তথ্য\nপ্রিন্ট করা\n#\nদেখাও তথ্য["নাম"];\nদেখাও তথ্য["বয়স"];\nদেখাও তথ্য["ফোন-নাম্বার"];\n```\n#### <a href="#">Builtin functions and constants</a>\n***\n* [_ডাইরেক্টরি](user_docs/built-in_functions_and_constants.md)\n* [_প্ল্যাটফর্ম](user_docs/built-in_functions_and_constants.md)\n* [_রিড-লাইন()](user_docs/built-in_functions_and_constants.md)\n* [_স্ট্রিং(মান)](user_docs/built-in_functions_and_constants.md)\n* [_সংখ্যা(মান)](user_docs/built-in_functions_and_constants.md)\n* [_লিস্ট-পুশ(লিস্ট, মান)](user_docs/built-in_functions_and_constants.md)\n* [_লিস্ট-পুশ(লিস্ট, ইন্ডেক্স, মান)](user_docs/built-in_functions_and_constants.md)\n* [_লিস্ট-পপ(লিস্ট)](user_docs/built-in_functions_and_constants.md)\n* [_লিস্ট-পপ(লিস্ট, ইন্ডেক্স)](user_docs/built-in_functions_and_constants.md)\n* [_লিস্ট-লেন(লিস্ট)](user_docs/built-in_functions_and_constants.md)\n* [_এরর("এরর মেসেজ")](user_docs/built-in_functions_and_constants.md)\n* [_স্ট্রিং-স্প্লিট(string, split-by)](user_docs/built-in_functions_and_constants.md)\n* [_স্ট্রিং-জয়েন(list-of-string, join-by)](user_docs/built-in_functions_and_constants.md)\n* [_টাইপ(value)](user_docs/built-in_functions_and_constants.md)\n* [_রিড-ফাইল("ফাইল-প্যাথ")](user_docs/built-in_functions_and_constants.md)\n* [_রাইট-ফাইল("ফাইল-প্যাথ", "কন্টেন্ট")](user_docs/built-in_functions_and_constants.md)\n* [_ডিলিট-ফাইল("ফাইল-প্যাথ", "কন্টেন্ট")](user_docs/built-in_functions_and_constants.md)\n* [_নতুন-ডাইরেক্টরি("ডাইরেক্টরি-প্যাথ")](user_docs/built-in_functions_and_constants.md)\n* [_রিড-ডাইরেক্টরি("ডাইরেক্টরি-প্যাথ")](user_docs/built-in_functions_and_constants.md)\n* [_ডিলিট-ডাইরেক্টরি("ডাইরেক্টরি-প্যাথ")](user_docs/built-in_functions_and_constants.md)\n* [_ফাইল-নাকি-ডাইরেক্টরি("প্যাথ")](user_docs/built-in_functions_and_constants.md)\n\n## How to get pakhi on my computer?\n* Download only [pakhi-setup.exe](https://github.com/Shafin098/pakhi-bhasha/releases) from Assets\n* Complete setup\n* Write a pakhi program (Use any example from above)\n* Open Pakhi and browse source file\n* Run your program (extension should be .pakhi)\n* To run pakhi program from cmd or powershell add ```C:\\Program Files\\Pakhi\\bin``` to your path environment variable. ***Note: Bangla text will not show properly***\n## Supported by JetBrains\n<a href="https://www.jetbrains.com/?from=pakhi-bhasha" target="_blank"><img src="https://raw.githubusercontent.com/Shafin098/pakhi-bhasha/master/svg/jetbrains.svg?raw=true"></a>\n']
C_Programming_Language,C语言程序设计,56,https://github.com/JackChan1999/C_Programming_Language,master,['对于一个开发者而言，能够胜任系统中任意一个模块的开发是其核心价值的体现。\n\n对于一个架构师而言，掌握各种语言的优势并可以运用到系统中，由此简化系统的开发，是其架构生涯的第一步。\n\n对于一个开发团队而言，能在短期内开发出用户满意的软件系统是起核心竞争力的体现。\n\n每一个程序员都不能固步自封，要多接触新的行业，新的技术领域，突破自我。\n\n## 目录\n\n* [前言](README.md)\n* [C语言学习之路](C语言学习之路.md)\n* [第1章 编程基础](0. 编程基础/README.md)\n    * [与编程相关的计算机硬件](0. 编程基础/6. 与编程相关的计算机硬件.md)\n    * [载入内存，让程序运行起来](0. 编程基础/7. 载入内存，让程序运行起来.md)\n    * [二进制思想以及数据的存储](0. 编程基础/8. 二进制思想以及数据的存储.md)\n* [第2章 初探C语言](1. 初探C语言/README.md)\n    * [C语言初探](1. 初探C语言/C语言初探.md)\n    * [使用IDE之前需要了解的一些概念](1. 初探C语言/使用IDE之前需要了解的一些概念.md)\n    * [C语言编译器和IDE的选择](1. 初探C语言/C语言编译器和IDE的选择.md)\n    * [最详细的VS2015安装教程](1. 初探C语言/最详细的VS2015安装教程.md)\n    * [在VS2015下运行C语言程序](1. 初探C语言/在VS2015下运行C语言程序.md)\n    * [Dev C++安装教程](1. 初探C语言/Dev C++安装教程.md)\n    * [在Dev C++下运行C语言程序](1. 初探C语言/在Dev C++下运行C语言程序.md)\n    * [C和C++编程规范](1. 初探C语言/C和C++编程规范.md)\n* [第3章 数据类型和运算符](2. 数据类型和运算符/README.md)\n    * [数据类型](2. 数据类型和运算符/数据类型.md)\n    * [void类型](2. 数据类型和运算符/void类型.md)\n    * [变量和常量](2. 数据类型和运算符/变量和常量.md)\n    * [宽窄字符](2. 数据类型和运算符/宽窄字符.md)\n    * [关键字](2. 数据类型和运算符/关键字.md)\n    * [数据存储的原理](2. 数据类型和运算符/数据存储的原理.md)\n    * [浮点数的存储原理](2. 数据类型和运算符/浮点数的存储原理.md)\n    * [强制类型转换](2. 数据类型和运算符/强制类型转换.md)\n    * [printf()详解](2. 数据类型和运算符/printf函数详解.md)\n    * [scanf()详解](2. 数据类型和运算符/scanf函数详解.md)\n    * [运算符与表达式](2. 数据类型和运算符/运算符与表达式.md)\n* [第4章 结构化程序设计](3. 结构化程序设计/README.md)\n    * [流程控制](3. 结构化程序设计/流程控制.md)\n    * [顺序结构](3. 结构化程序设计/顺序结构.md)\n    * [语句和逻辑结构](3. 结构化程序设计/语句和逻辑结构.md)\n    * [if分支](3. 结构化程序设计/if分支.md)\n    * [switch多分支](3. 结构化程序设计/switch多分支.md)\n    * [for循环](3. 结构化程序设计/for循环.md)\n    * [while循环](3. 结构化程序设计/while循环.md)\n    * [递归](3. 结构化程序设计/递归.md)\n    * [break关键字](3. 结构化程序设计/break关键字.md)\n    * [continue关键字](3. 结构化程序设计/continue关键字.md)\n    * [goto关键字](3. 结构化程序设计/goto关键字.md)\n* [第5章 函数](4. 函数/README.md)\n    * [函数指针](4. 函数/函数指针.md)\n    * [库函数](4. 函数/库函数.md)\n* [第6章 数组](5. 数组/README.md)\n    * [数组](5. 数组/数组.md)\n    * [二维数组](5. 数组/二维数组.md)\n    * [数组与指针](5. 数组/数组与指针.md)\n    * [动态数组](5. 数组/动态数组.md)\n* [第7章 指针](6. 指针/README.md)\n    * [1分钟彻底理解C语言指针的概念](6. 指针/1分钟彻底理解C语言指针的概念.md)\n    * [指针](6. 指针/指针.md)\n    * [指针地址与取值运算符](6. 指针/指针地址与取值运算符.md)\n    * [指针的本质](6. 指针/指针的本质.md)\n    * [野指针和空指针](6. 指针/野指针和空指针.md)\n    * [void指针](6. 指针/void指针.md)\n    * [指针的强制类型转换](6. 指针/指针的强制类型转换.md)\n    * [玩转多级指针](6. 指针/玩转多级指针.md)\n    * [指针与数组](6. 指针/指针与数组.md)\n    * [指针与函数](6. 指针/指针与函数.md)\n    * [函数接口的传入参数与传出参数](6. 指针/函数接口的传入参数与传出参数.md)\n    * [回调函数](6. 指针/回调函数.md)\n    * [征服指针](6. 指针/征服指针.md)\n    * [指针与内存](6. 指针/指针与内存.md)\n    * [指针知识体系搭建-1](6. 指针/指针知识体系搭建-1.md)\n    * [指针知识体系搭建-2](6. 指针/指针知识体系搭建-2.md)\n    * [句柄handle](6. 指针/句柄handle.md)\n    * [句柄是什么？Windows结构体里面句柄的作用](6. 指针/句柄是什么？Windows结构体里面句柄的作用.md)\n    * [指针的应用场景](6. 指针/指针的应用场景.md)\n    * [关于指针的经典语录](6. 指针/关于指针的经典语录.md)\n* [第8章 C语言与汇编](7. C语言与汇编/README.md)\n    * [汇编语言](7. C语言与汇编/汇编语言.md)\n    * [C语言与汇编之计算机结构](7. C语言与汇编/C语言与汇编之计算机结构.md)\n    * [C语言与汇编之用汇编写一个Helloword](7. C语言与汇编/C语言与汇编之用汇编写一个Helloword.md)\n    * [C语言与汇编之寄存器和寻址方式](7. C语言与汇编/C语言与汇编之寄存器和寻址方式.md)\n    * [C语言与汇编之函数调用的本质](7. C语言与汇编/C语言与汇编之函数调用的本质.md)\n* [第9章 C语言与内存](8. C语言与内存/README.md)\n    * [C语言与内存](8. C语言与内存/0. C语言与内存.md)\n    * [C语言指针初步](8. C语言与内存/1. C语言指针初步.md)\n    * [C语言指针进阶](8. C语言与内存/2. C语言指针进阶.md)\n    * [C语言指针举例](8. C语言与内存/3. C语言指针举例.md)\n    * [C语言指针修饰符const](8. C语言与内存/4. C语言指针修饰符const.md)\n    * [C语言const举例](8. C语言与内存/5. C语言const举例.md)\n    * [C语言volatile与typedef](8. C语言与内存/6. C语言volatile与typedef.md)\n    * [C语言运算符标签操作](8. C语言与内存/7. C语言运算符标签操作.md)\n    * [C语言运算符加减举例](8. C语言与内存/8. C语言运算符加减举例.md)\n    * [C语言指针越界访问举例](8. C语言与内存/9. C语言指针越界访问举例.md)\n    * [C语言指针逻辑运算符](8. C语言与内存/10. C语言指针逻辑运算符.md)\n    * [C语言多级指针](8. C语言与内存/11. C语言多级指针.md)\n    * [C语言多级指针举例](8. C语言与内存/12. C语言多级指针举例.md)\n    * [C语言数组](8. C语言与内存/13. C语言数组.md)\n    * [C语言结构体字节对齐](8. C语言与内存/14. C语言结构体字节对齐.md)\n    * [C语言内存分布思想概述](8. C语言与内存/15. C语言内存分布思想概述.md)\n    * [C语言只读空间](8. C语言与内存/16. C语言只读空间.md)\n    * [C语言内存分布之数据段](8. C语言与内存/17. C语言内存分布之数据段.md)\n    * [C语言内存分布之堆空间](8. C语言与内存/18. C语言内存分布之堆空间.md)\n    * [内存结构](8. C语言与内存/内存结构.md)\n* [第10章 字符串](9. 字符串/README.md)\n    * [字符串](9. 字符串/字符串.md)\n    * [常用的字符串函数-1](9. 字符串/常用的字符串函数-1.md)\n    * [常用的字符串函数-2](9. 字符串/常用的字符串函数-2.md)\n    * [封装字符串](9. 字符串/封装字符串.md)\n    * [字符串案例](9. 字符串/案例.md)\n* [第11章 编译和预处理](10. 编译和预处理/README.md)\n* [第12章 结构体和共用体](11. 结构体和共用体/README.md)\n    * [结构体](11. 结构体和共用体/结构体.md)\n    * [共用体](11. 结构体和共用体/共用体.md)\n    * [offsetof宏](11. 结构体和共用体/offsetof宏.md)\n    * [container_of宏](11. 结构体和共用体/container_of宏.md)\n    * [学生成绩管理系统](11. 结构体和共用体/学生成绩管理系统.md)\n* [第13章 基本数据结构](12. 基本数据结构/README.md)\n    * [链表](12. 基本数据结构/链表.md)\n    * [栈](12. 基本数据结构/栈.md)\n    * [队列](12. 基本数据结构/队列.md)\n    * [排序与查找算法](12. 基本数据结构与算法/排序与查找算法.md)\n* [第14章 静态库和动态库](13. 静态库和动态库/README.md)\n    * [静态库](13. 静态库和动态库/静态库.md)\n    * [共享库](13. 静态库和动态库/共享库.md)\n    * [动态库](13. 静态库和动态库/动态库.md)\n    * [接口的封装和设计](13. 静态库和动态库/接口的封装和设计.md)\n    * [动态库的使用](13. 静态库和动态库/动态库的使用.md)\n    * [动态库升级成框架案例](13. 静态库和动态库/动态库升级成框架案例.md)\n* [第15章 makefile](14. makefile/README.md)\n    * [makefile基础](14. makefile/makefile基础.md)\n    * [makefile之隐含规则和模式规则](14. makefile/makefile之隐含规则和模式规则.md)\n    * [makefile之变量](14. makefile/makefile之变量.md)\n* [第16章 网络编程](15. 网络套接字/README.md)\n    * [网络套接字编程](15. 网络套接字/网络套接字编程.md)\n* [第17章 文件操作](16. 文件操作/README.md)\n    * [配置文件读写](16. 文件操作/配置文件读写.md)\n    * [文件加密](16. 文件操作/文件加密.md)\n    * [图书管理系统](16. 文件操作/图书管理.md)\n* [第18章 综合项目](17. 综合项目/README.md)\n    * [程序调试](17. 综合项目/程序调试.md)\n    * [趣味俄罗斯方块](17. 综合项目/趣味俄罗斯方块.md)\n    * [贪吃蛇](17. 综合项目/贪吃蛇.md)\n    * [黑白棋](17. 综合项目/黑白棋.md)\n    * [计数器](17. 综合项目/计数器.md)\n    * [迷宫游戏](17. 综合项目/迷宫游戏.md)\n    * [扫雷](17. 综合项目/扫雷.md)\n    * [学生信息管理学系统](17. 综合项目/学生信息管理学系统.md)\n    * [学生成绩管理系统](17. 综合项目/学生成绩管理系统.md)\n    * [快译通](17. 综合项目/快译通.md)\n    * [电子词典](17. 综合项目/电子词典.md)\n    * [程序调试](17. 综合项目/程序调试.md)\n* [第19章 面向对象编程](18. 面向对象/README.md)\n    * [面向对象编程](18. 面向对象/面向对象编程.md)\n    * [封装与继承](18. 面向对象/封装与继承.md)\n    * [继承详解](18. 面向对象/继承详解.md)\n    * [虚函数与多态](18. 面向对象/虚函数与多态.md)\n    * [用C语言模拟实现虚函数](18. 面向对象/用C语言模拟实现虚函数.md)\n    * [面向接口编程](18. 面向对象/面向接口编程.md)\n    * [单链表实现](18. 面向对象/单链表实现.md)\n    * [配置文件解析](18. 面向对象/配置文件解析.md)\n* [第20章 设计模式](19. 设计模式/README.md)\n    * [C语言设计模式](19. 设计模式/C语言设计模式.md)\n    * [单例模式](19. 设计模式/单例模式.md)\n    * [原型模式](19. 设计模式/原型模式.md)\n    * [组合模式](19. 设计模式/组合模式.md)\n    * [模板模式](19. 设计模式/模板模式.md)\n    * [工厂模式](19. 设计模式/工厂模式.md)\n    * [抽象工厂模式](19. 设计模式/抽象工厂模式.md)\n    * [责任链模式](19. 设计模式/责任链模式.md)\n    * [迭代器模式](19. 设计模式/迭代器模式.md)\n    * [外观模式](19. 设计模式/外观模式.md)\n    * [代理模式](19. 设计模式/代理模式.md)\n    * [享元模式](19. 设计模式/享元模式.md)\n    * [装饰模式](19. 设计模式/装饰模式.md)\n    * [适配器模式](19. 设计模式/适配器模式.md)\n    * [策略模式](19. 设计模式/策略模式.md)\n    * [中介者模式](19. 设计模式/中介者模式.md)\n    * [建造者模式](19. 设计模式/建造者模式.md)\n    * [桥接模式](19. 设计模式/桥接模式.md)\n    * [观察者模式](19. 设计模式/观察者模式.md)\n    * [备忘录模式](19. 设计模式/备忘录模式.md)\n    * [解析器模式](19. 设计模式/解析器模式.md)\n    * [命令模式](19. 设计模式/命令模式.md)\n    * [状态模式](19. 设计模式/状态模式.md)\n    * [访问者模式](19. 设计模式/访问者模式.md)\n    * [泡妞与设计模式](19. 设计模式/泡妞与设计模式.md)\n\n## 关注我\n\n- Email：<815712739@qq.com>\n- CSDN博客：[Allen Iverson](http://blog.csdn.net/axi295309066)\n- 新浪微博：[AndroidDeveloper](http://weibo.com/u/1848214604?topnav=1&wvr=6&topsug=1&is_all=1)\n- GitHub：[JackChan1999](https://github.com/JackChan1999)\n- GitBook：[alleniverson](https://www.gitbook.com/@alleniverson)\n- 个人博客：[JackChan](https://jackchan1999.github.io/)\n']
the-swift-programming-language-in-portuguese-br,Tradução pt-BR do livro oficial do Swift,91,https://github.com/CocoaHeadsBrasil/the-swift-programming-language-in-portuguese-br,master,['\n# The Swift Programming Language - Tradução Português (BR)\n\n![](artes/hero.png)\n\nEsse projeto é uma iniciativa do CocoaHeads Brasil que tem como objetivo traduzir o livro oficial de Swift da Apple para o Português Brasileiro. \n\nLink do livro original: [Swift.org](https://swift.org/documentation/TheSwiftProgrammingLanguage(Swift3.1).epub)\n\n---\n\n### Como contribuir?\n\n#### Passos para começar a ajudar:\n\n1. Os capítulos disponíveis para tradução serão criados como issues no GitHub;\n2. Os arquivos *.md* estão criados com o nome de cada capítulo. Ex.: `bemvindo/sobre.md`\n3. Caso queira contribuir com a tradução, crie uma issue com o formato `<seção> - <capítulo>` (ex.: `Bem-vindo ao Swift - Sobre o Swift`), adicione a tag `tradução` e comente na issue avisando, para não haver traduções múltiplas do mesmo arquivo.\n4. Crie uma branch para determinado arquivo que queira traduzir e faça o Pull Request.\n\n#### Formatação do Markdown:\n\n1. Palavras em inglês que não forem traduzidas, colocar em itálico;\n2. Código inline colocar entre crases para ficar alo como: defina um constante de tipo `String` e valor `"John Appleseed"`;\n3. Código em bloco deve conter syntax highlight do Swift;\n4. Traduzir termo técnico apenas se fizer sentido. Se for prejudicar o entendimento, é preferível manter o termo original. ex.: Closures. Existe uma ferramenta para [tradução de terminologias da Microsoft](http://www.microsoft.com/Language/pt-br/Search.aspx); se fizer sentido utiliza-la para tirar dúvidas, utilize-a!\n5. Notas de rodapé devem ser criadas como quote do markdown, usando o sinal de `>` na frente;\n6. **Não esqueça** de habilitar o verificador ortográfico do seu editor. Isso poupa **muito** tempo de que está revisando. Editores preferidos: [MacDown](http://macdown.uranusjr.com/) ou [Mou](http://25.io/mou/).\n\nCaso queira visualizar como está ficando o texto, basta utilizar o Gitbook. Para isso, siga as instruções na nossa [página do wiki]\n(https://github.com/CocoaHeadsBrasil/the-swift-programming-language-in-portuguese-br/wiki). \n\n### Processo de avaliação da tradução\n\n1. Crie um Pull Request com o título no formato: `<seção> - <capítulo>` (ex.: `Bem-vindo ao Swift - Sobre o Swift`) e adicione as tags `tradução` && (`parcial` || `completa`)\n2. Um (ou mais de um) revisor verifica o Pull Request;\n3. Se achado erro de tradução ou erro de português, o revisor comenta na linha;\n4. O criador do PR corrige ou responde se achar que não faz sentido, se discorda ou se tiver algo mais a acrescentar;\n5. Se o criador do PR enviar alguma atualização, voltamos para o item (1);\n6. Se a tradução estiver OK, o revisor comenta no final do PR com um :+1:;\n7. Após ao menos 2 revisões feitas, é feito o merge da tradução.\n\n### Licença\n\n<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Licença Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">The Swift Programming Language - Tradução Português (BR)</span> de <a xmlns:cc="http://creativecommons.org/ns#" href="www.cocoaheads.com.br" property="cc:attributionName" rel="cc:attributionURL">CocoaHeads Brasil</a> está licenciado com uma Licença <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons - Atribuição-CompartilhaIgual 4.0 Internacional</a>.<br />Baseado no trabalho disponível em <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/CocoaHeadsBrasil/the-swift-programming-language-in-portuguese-br" rel="dct:source">https://github.com/CocoaHeadsBrasil/the-swift-programming-language-in-portuguese-br</a>.\n\n\n\n']
KoPL,Knowledge Oriented Programming Language,62,https://github.com/THU-KEG/KoPL,main,["# KoPL: 面向知识的推理问答编程语言 \n\n[安装](#安装) | [快速开始](#快速开始) | [文档](#文档) | [网站](#网站)\n\nKoPL全称 Knowledge oriented Programing Language, 是一个为复杂推理问答而设计的编程语言。我们可以将自然语言问题表示为由基本函数组合而成的KoPL程序，程序运行的结果就是问题的答案。目前，KoPL的27个基本函数覆盖对多种知识元素（如概念、实体、关系、属性、修饰符等）的操作，并支持多种问题类型（如计数、事实验证、比较等）的查询。KoPL提供透明的复杂问题推理过程，易于理解和使用。KoPL面向知识库、文本等不同形式的知识资源，可扩展性强。\n\n下面的代码演示了如何使用Python代码，实现对一个自然语言问题的推理问答。\n\n```python\nfrom kopl.kopl import KoPLEngine\nfrom kopl.test.test_example import example_kb\n\nengine = KoPLEngine(example_kb) # 创建可以在example_kb这个知识库上进行操作的engine示例\n\n# 查询问题：Who is taller, LeBron James Jr. or his father?\nans = engine.SelectBetween( # 在两个实体中，查询'height'更大的实体\n  engine.Find('LeBron James Jr.'), # 找到实体'LeBron James Jr'\n  engine.Relate( # 找到与'LeBron James Jr'的'father\n    engine.Find('LeBron James Jr.'), # 找到实体'LeBron James Jr'\n    'father', # 关系标签\n    'forward' # ’forward‘代表'LeBron James Jr'为头实体\n  ),\n  'height', # 属性标签\n  'greater' # 查询属性值更大的实体\n)\n\nprint(ans) # ans是实体名字列表\n\n```\n\n在这个示例里，我们查询LeBron James Jr.和他的父亲谁更高，KoPL程序给出了正确的答案: LeBron James！\n\n# 安装\n\nKoPL支持Linux (e.g., Ubuntu/CentOS)，macOS，Windows。\n\n其依赖为：\n\n* python >= 3.6\n\n* tqdm >= 4.62\n\n\nKoPL提供pip安装, 下面将展示Ubuntu的安装命令:\n\n```bash\n  $ pip install KoPL tqdm\n```\n\n运行下面的代码\n\n```python\nimport kopl\n\nfrom kopl.test.test_example import *\n\nrun_test()\n```\n如果测试运行成功，恭喜您已经安装成功。\n\n# 快速开始\n您可以准备自己的知识库，使用KoPL实现推理问答。知识库的格式请参考 [知识库](https://kopl.xlore.cn/doc/4_helloworld.html#id1)。\n更多使用KoPL程序进行的简单问答请参考 [简单问答](https://kopl.xlore.cn/doc/5_example.html#id2)，复杂问答请参考 [复杂问答](https://kopl.xlore.cn/doc/5_example.html#id8)。\n\n您也可以使用我们为您提供的[查询服务](https://kopl.xlore.cn/queryService)，快速开启KoPL之旅。\n\n# 文档\n我们为您提供了KoPL[文档](https://kopl.xlore.cn/doc/index.html)，详细介绍了KoPL面向的知识元素，KoPL的基本函数，KoPL引擎的API。\n\n# 网站\nhttps://kopl.xlore.cn\n"]
gocodelabru,Coding simple database for geospatial data using Go programming language workshop in Russian language,63,https://github.com/maddevsio/gocodelabru,master,['# Делаем простую базу для гео данных\n\nПривет, гофер. Ну если ты не гофер и хочешь им стать, тоже привет.  Я предлагаю в этой кодлабе совместить две вещи. Изучить как язык Go и может быть освоить для себя пару новых вешей.\n\n# Аудитория\nCodelab расчитана на людей, у которых есть опыт в программировании и которые хотят попробовать Go. Это может быть люди, пишушие на PHP/Python/Ruby. Для пишуших на C/C++ Codelab будет врятли полезен\n\n# Поднимаем окружение\nТебе понадобится следующее:\n\n1. Установленный язык [Go](https://golang.org/)\n2. Настроенный `GOPATH` :trollface: (Для 1.8 не актуально)\n3. Ты знаком с базовыми вещами в Go. [Тур по Go](https://tour.golang.org/) может хорошо в этом помочь\n\n# Цель лабораторной\n\nУ этой лабораторной работы две цели:\n\n1. Получить опыт в Go\n2. Научиться понимать как примерно работают key-value хранилища(redis, memcached)\n3. Как работают некоторые индексы.\n\nПо итогу БД будет уметь следующие вещи:\n\n* Быстрый поиск по ключу;\n* Поиск мест, рядом с вами;\n* HTTP интерфейс к БД;\n* LRU/expire механизмы для хранения данных;\n\nПо Go получите следующие знания:\n\n* Как работает concurrency;\n* Поработаете с базовыми синтаксическими вещами;\n* Опыт тестирования в go;\n* Базовые вещи с Makefile;\n\n# Содержание\n\nЭтот воркшоп разделен на несколько частей.\n\n* [Шаг 0. Постановка задачи](step00/README.md)\n* [Шаг 1. Что нужно знать о тестировании и написании тестов в Go.](step01/README.md)\n* [Шаг 2. Hello world](step02/README.md)\n* [Шаг 3. Проектируем HTTP API](step03/README.md)\n* [Шаг 4. Делаем HTTP API](step04/README.md)\n* [Шаг 5. Разбиваем main.go на несколько пакетов](step05/README.md)\n* [Шаг 6. Makefile, конфигурация и флаги](step06/README.md)\n* [Шаг 7. Добавляем хранилище для данных и ищем ближайших водителей наивным путем](step07/README.md)\n* [Шаг 8. Пишем первый бенчмарк и зачем он](step08/README.md)\n* [Шаг 9. Что такое R-tree и почему оно эффективнее наивной реализации](step09/README.md)\n* [Шаг 10. Имплементируем LRU (часть 1)](step10/README.md)\n* [Шаг 11. Имплементируем LRU (часть 2)](step11/README.md)\n* [Шаг 12. Делаем хранилище консистентным. Внедряем LRU](step12/README.md)\n* [Шаг 13. Внедряем хранилище в API](step13/README.md)\n* [Шаг 14. Вы прошли курс. Поздравляю](step14/README.md)\n\n## Комьюнити и ресурсы\n\nЕсть несколько мест, где вы можете найти информацию про Go:\n\n- [golang.org](https://golang.org)\n- [godoc.org](https://godoc.org) тут вы можете найти документацию по любому пакету\n- [Блог языка Go](https://blog.golang.org)\n\nОдно из самых замечательных качеств языка Go - это его сообщество.\n### Сообщества и каналы в телеграм\n\n1. [@bishkekgophers](https://telegram.me/bishkekgophers) - Гоферы Бишкека\n2. [@devkg](https://telegram.me/devkg) - Программисты Кыргызстана\n3. [@maddevsio](https://telegram.me/maddevsio) - канал нашей компании, где мы делимся всякими интересными штуками. Очень часто говорим про Go\n\n### Сообщества в Slack\n\n1. [golang-ru.slack.com](golang-ru.slack.com) - Рускоязычное сообщество гоферов\n2. [gophers.slack.com](gophers.slack.com) - Англоязычное сообщество гоферов. Инвайт получить тут [https://invite.slack.golangbridge.org/](https://invite.slack.golangbridge.org/)\n\n\n### Подкасты\n\n1. [GolangShow](https://golangshow.com) - Русскоязычный подкаст о языке Go\n2. [Gotime](http://gotime.fm) - Англоязычный подкаст о языке Go\n\n### Остальное\n- [Go Форум](https://forum.golangbridge.org/)\n- [@golang](https://twitter.com/golang) and [#golang](https://twitter.com/search?q=%23golang) on Twitter.\n- [Go+ community](https://plus.google.com/u/1/communities/114112804251407510571) on Google Plus.\n\n### Благодарности\n\n1. Francesc Campoy за его воркшоп [Building Web Applications with Go](https://github.com/campoy/go-web-workshop/)\n2. Ashley McNamara за картинку в 10м шаге. Вы можете посмотреть и другие работы в [репо](https://github.com/ashleymcnamara/gophers)\n3. [Елене Граховац](https://twitter.com/webdeva) за ревью и фидбек\n']
mastering-dart,Repo for Teach Yourself mastering dart programming language,50,https://github.com/perymerdeka/mastering-dart,main,['# mastering-dart\nRepo for Teach Yourself mastering dart programming language\n\n## Chapter\n\n1. [Membuat Aplikasi Pertama Menggunakan Dart](aplikasi_pertama/README.md) \n2. [Percabangan](percabangan/README.md)\n3. [Perulangan](perulangan/README.md)\n4. [Fungsi, Parameter dan lambda Expression](fungsi/README.md)\n5. [List, Set dan Mapping](mapping/README.md)\n6. [Class dan Object](class_objects/README.md)\n7. [Enkapsulasi](enkapsulasi/README.md)\n8. [Pewarisan/Inheritence, keyword `is` dan`as` ](inherit/README.md)\n9. [Abstract Class dan Interface](absract_class/README.md)\n10. [Mixins](mixins/README.md)\n11. [Constructor](constructors/README.md)\n12. [Parameter Underscore](underscore_parameter/README.md)\n13. [Static Keywords](static_keywords/README.md)\n14. [Async Await dan Future](async_await/README.md)\n15. [Final dan Const](final_const/README.md)\n16. [Generic dan Generic Type](generic/README.md)\n17. [Enum dan Cascade Notation](enums/README.md)\n18. [Required, Assert dan Try Catch](reuireds/README.md)\n19. [Custom Sort dan ForEach](custom_sort/README.md)\n20. [Solid Principle](solid_principle/README.md)\n21. [Operator Override](operator_overriding/README.md)\n22. [Singleton](singleton/README.md)\n23. [Future Or](furure_or/README.md)\n24. [tipe data `dynamic` dan `var`](dynamic_vars/README.md) <- update tgl: 14 juli 2021\n\n\n### Referensi dan Sumber Belajar\n\n#### Flutter\n\n* Channel youtube (rekomendasi) : https://www.youtube.com/user/kh3w4nx1ng\n* Dokumentasi Flutter: https://flutter.dev/docs\n* Komunitas flutter (telegram): https://t.me/flutter_id\n* Artikel update: https://t.me/flutterDev \n* Forum Diskusi: https://github.com/flutter/flutter\n* Medium Publisher: https://medium.com/flutter-community\n\n#### Dart\n* [Dokumentasi Dart](https://dart.dev/guides/)\n* [playlist untuk belajar dart](https://www.youtube.com/playlist?list=PLZQbl9Jhl-VDeCuNNp7C2SR1lFsIjQRQo)\n']
deeplang,DeepLang is a new language for IoT device programming.,72,https://github.com/deeplang-org/deeplang,master,['<a href = "https://github.com/deeplang-org/deeplang">\n<img width = "40%" height = "auto" src = "./assets/banner.jpg" alt = "Deeplang: a new programming language for IoT">\n</a>\n\n# Deeplang 简介\n\nDeeplang语言是一种自制编程语言，由来自浙大、中科大、帝国理工等高校的学生共同完成。\n\n我们致力于将Deeplang语言打造为具有鲜明内存安全特性的面向IoT场景的语言，设计过程中参考Rust的安全机制，但又根据IoT场景的特性选择了更合适的解释执行模式。Deeplang是一种静态类型、强类型语言，参考C-style设计语法，同时支持过程式、逻辑式和函数式的混合范式。\n\nDeeplang的独特安全特性帮助其具有一定的竞争力。作者正在持续的开发和迭代中。\n\n---\n\n## 目录\n\n1. [注释](#注释)\n1. [程序入口](#程序入口)\n1. [表达式](#表达式)\n1. [控制语句](#控制语句)\n1. [模式匹配](#模式匹配)\n1. [函数](#函数)\n1. [内建类型](#内建类型)\n1. [类型定义](#类型定义)\n1. [接口声明](#接口实现)\n1. [接口实现](#接口实现)\n1. [命名规范与作用域规则总结](#命名规范与作用域规则总结)\n1. [仍在设计中的特性](#仍在设计中的特性)\n\n## 注释\n\n单行注释\n\n``` dp\n// code\n```\n\n多行注释\n\n``` dp\n/*\ncode\ncode\n*/\n```\n\n## 程序入口\n\n在Deeplang程序中，顶层代码没有表达式，只有各类定义。\n具体来说，Deeplang有如下的顶层代码：\n\n- 类型定义\n- 接口声明\n- 接口实现\n- 全局变量定义\n- 函数定义\n\n整个程序的运行入口有且只有一个，就是以main作为名字的函数。\n\n## 表达式\n\nDeeplang和C、Java等语言一样，采用了表达式和语句二分的设计。\n\nDeeplang中有以下几种表达式：\n\n- 字面量，包括整数、浮点数、单个字符和字符串\n- 变量名字。变量名字必须以小写字母开头。\n- 一元操作符和二元操作符，如`! x`、`1 + 2`等。\n- 元组，如`(1, "2", (3, 4))`\n- 数组，如`[1, 1, 4, 5, 1, 4]`\n- 代数数据类型（和类型），形如`<分支名字>(<值列表>)`。详见[类型定义的部分](#类型定义)。\n- 创建结构体，形如是`<类型名字> { <域名字>: <值>, ... }`。\n- 获取结构体中的域，如`point.x`。\n- 函数调用，形如`<函数名字>(<参数列表>)`。\n- 调用方法，形如`<表达式>.<方法名字>(<参数列表>)`。Deeplang中没有类系统，方法调用的解析是静态的。多态可以通过接口实现。\n- 表达式层级的条件。语法待定。\n- 表达式层级的模式匹配。语法待定。\n\n## 控制语句\n\nDeeplang中有以下的控制语句：\n\n- 每个表达式都是控制语句。表达式的结果会被丢弃。\n- 可以将多条控制语句有分号连接、用花括号括起，按顺序执行，变成一条语句。\n- 声明变量`let <pattern> [= <rhs>]`。其中`<pattern>`是一个**带类型标注的**[模式](#模式匹配)，`<rhs>`是一个表达式。通过支持等于号左侧出现任意pattern，可以实现如`let (x, y) = some_pair`的便利解构。\n- 条件语句`if (<条件>) <分支1> else <分支2>`。\n- 传统for循环，如：\n    ```\n        for ({let mut i: I32 = 0}; i < 10, i += 1) {\n            foo();\n        }\n    ```\n  与大部分语言不同，循环初始化部分的语句必须用花括号括起。\n- 基于迭代器的for循环，如：\n\n  ```Deeplang\n          for (<pattern> : iterable) {\n              ...\n          }\n  ```\n\n  这类for循环的具体语义取决于（尚未完成的）标准库中的迭代器设计。\n- while循环，形如：\n\n  ```Deeplang\n          while (<循环继续条件，表达式>)\n            <循环体，必要时由花括号括起>\n  ```\n\n- 模式匹配语句，例如：\n\n  ```Deeplang\n        match (optional_integer) {\n            Some(x) => { return x }\n            None    => { return 0 }\n        }\n  ```\n\n- 特殊控制语句，如`return`，`break`和`continue`。\n\n## 模式匹配\n\nDeeplang中支持一套模式匹配系统，包括如下几种可以用于匹配的模式：\n\n- 下划线`_`，匹配任何值。\n- 变量`[mut] <变量名> [: <类型>]`，匹配任何值，并将`<变量名>`绑定到匹配到的值。新的变量默认是不可变的，除非在变量名前加上`mut`前缀。\n- `as`模式，形如如`<pattern> as [mut] <variable> [: <类型]`。如果匹配的值能够与`<pattern>`匹配，将`<variable>`绑定到该值。`variable`同样可以用`mut`修饰。\n- ADT模式，如`None`，`Some(x)`，`Some(Some(y))`等。\n- 结构体模式，形如`<类型名字> { <结构体的域> : <匹配这个域的值的模式>, ... }`。不需要匹配所有的域，没有在模式中出现的域将被无视。\n- 元组解包模式，如`(a, (b, c), d)`等。\n\n## 函数\n\n函数的签名形如`fun <函数名字>(<参数列表>) -> <返回值类型>`，其中参数列表用逗号隔开。目前参数类型和返回值类型都必须显式标注。一些函数定义的例子如下：\n\n```dp\nfun foo(bar: Bar) -> Foo {\n   ...\n}\n```\n\n```dp\nfun multiParam(x: i32, y: i32) {\n    ...\n}\n```\n\n## 内建类型\n\nDeeplang中有如下的内建类型：\n\n```Deeplang\nBool\n(...)                // tuple type\n()                   // empty tuple alias Unit type\nI8, I16, I32, I64\nU8, U16, U32, U64\nF32, F64\nChar                 // 16bit\n[T; N]               // T-array of length N\n```\n\n暂时还没有List的类型。\n\n## 自定义类型\n\nDeeplang中支持两种自定义类型：结构体和代数数据类型(ADT)。Deeplang中类型名字必须以大写字母开头。\n\n### 结构体类型定义\n\n```Deeplang\ntype <类型名字> {\n    <域名字> : <域类型>,\n    ...\n}\n```\n\n结构体的域的名字都必须以小写字母开头。\n\n使用结构体定义新类型的一些例子如下：\n\n```Deeplang\ntype Color {\n    r : U8,\n    g : U8,\n    b : U8\n}\n```\n\n```Deeplang\ntype Point {\n    x : F32,\n    y : F32,\n    z : F32\n}\n```\n\n此外，结构体定义还支持委托。在结构体类型的声明中，可以加入形如`as <域名字> : <委托的类型>`的声明。\n\n例如，在声明：\n\n```Deeplang\ntype S2 {\n    as s1 : S1\n}\n```\n\n中，类型`S2`会有一个名为`s1`、类型为`S1`的域。此外，`S1`中的所有域都将被“委托”到`S2`中。也就是说，对于`S1`中的每一个域`x`，\n`S2`中也会有一个对应的域`x`，且`S2.x = S2.s1.x`。\n\n下面的例子展示了委托的使用方法：\n\n```Deeplang\ntype ColoredPoint {\n    as position : Point,\n    color : Color\n}\n```\n\n```Deeplang\nlet cp : ColoredPoint = ...;\ncp.color;     // of type Color\ncp.position;  // of type Point\ncp.x          // of type F32, same as cp.position.x\n```\n\n### ADT类型定义\n\n```Deeplang\ntype <类型名字> [\n    <分支名字>[(<类型参数列表>)],\n    ...\n]\n```\n\n每个ADT必须有至少一个分支，而每个分支的参数类型列表是可选的。如果没有参数，则不写`()`。\n\nADT中分支的名字必须以大写字母开头。分支的类型参数列表中，可以给参数加上名字。但这些名字只有注释作用，没有实际语义。\n\n使用ADT定义新类型的一个例子如下：\n\n```Deeplang\ntype Shape [\n    Rectangle(width : U32, height : U32),\n    Circle(radius : U32),\n    Nothing\n]\n```\n\n可以通过模式匹配来对一个ADT值的不同分支作出不同的处理。\n\n## 接口声明\n\n在Deeplang中，方法调用的解析是静态的，多态需要通过接口来实现的。\n\n接口声明形如：\n\n```Deeplang\ninterface <接口名字> extends <依赖的接口列表> {\n    fun <方法名字>(参数列表) -> <返回值类型>;\n    ...\n}\n```\n\n通过为一个类型实现该接口，可以使该类型的值支持接口中的方法的调用。在接口声明内部，可以通过`This`来指代实现该接口的类型自身。下面是一些接口声明的例子：\n\n```Deeplang\ninterface Eq {\n    fun equals(this, other : This) : Bool;\n}\n```\n\n```Deeplang\ntype Order [ Eq, Lt, Gt ]\n\ninterface Ordered extends Eq {\n    fun compare(this, other : This) : Order;\n}\n\ninterface Add {\n    fun add(this, other : This) : This;\n}\ninterface Mul {\n    fun mul(this, other : This) : This;\n}\n```\n\n假设`I`是一个接口，那么`I`也可以被用作类型，此时它表示任意实现了接口`I`的类型。当需要表达“同时实现了若干个接口的类型”时，可以利用一个没有方法的空接口以及接口的依赖列表来实现，例如：\n\n```Deeplang\n// 接口Number等价与接口Ordered + Add + Mul\ninterface Number extends Ordered, Add, Mul {\n}\n```\n\n```Deeplang\nfun some_function(a : Number, b : Number) : Number {\n    if (equals(a, b))\n        return add(a, a);\n    else\n        return mul(a, a);\n}\n```\n\n## 接口实现\n\n在Deeplang中，为一个类型`T`实现接口`I`的语法如下：\n\n```Deeplang\nimpl I for T {\n    fun <方法名字>(<参数列表>) -> <返回值类型> {\n        <方法的实现>\n    }\n}\n```\n\n在方法的实现中，可以用`this`来访问方法的调用者。除了实现接口外，也可以直接为一个类型实现一些方法，语法为：\n\n```Deeplang\nimpl T {\n    ... // 同上\n}\n```\n\n在这种`impl`块中实现的方法将能够被类型为`T`的值调用。下面是一个通过接口来模拟鸭子类型的例子：\n\n```Deeplang\ninterface Quack {\n    quack() -> ();\n}\n\n```Deeplang\n    type Duck [ RubberDuck ]\n    impl Quack for Duck {\n        fun quack() -> () {\n            print("quaaaack");\n        }\n    }\n\n    type Bird [ Snidget ]\n    impl Quack for Bird {\n        fun quack() -> () {\n            print("bird quaaaack");\n        }\n    }\n\n    fun sound(animal: Quack) -> () {\n        animal.quack();\n    }\n\n    fun main() -> () {\n        let duck: Duck = Duck();\n        let bird: Bird = Bird();\n\n        // type checking pass\n        sound(duck); // quaaaak\n        sound(bird); // bird quaaaak\n    }\n```\n\n# 命名规范与作用域规则总结\n以下名字必须以小写字母开头：\n\n- 变量、函数的名字\n- 结构体的域的名字\n\n以下名字必须以大写字母开头：\n\n- 类型、接口的名字\n- 代数数据类型的分支的名字\n\n除此之外，名字中可以包含下划线、字母和数字（首字母不能为数字）。上述“首字母”指的都是第一个非下划线的字母，也就是说不管是哪一种名字，都允许以若干个下划线开始，但只有下划线的名字是不被允许的。上述命名规范是语法的一部分，而不是一种软性的建议。违反上述命名规范的程序是语法错误的。但除了首字母外，Deeplang的使用者可以自由选择名字其他部分的命名规范，例如选择驼峰命名法或下划线命名法。\n\nDeeplang中的各种名字处于不同的命名空间中。不同命名空间中的名字互不干涉。每种名字所处的命名空间及对应的作用域规则如下：\n\n- 函数的名字处于独立的命名空间，且不允许重名。\n- 方法名字本身没有一个全局的命名空间。因此不同的接口、不同的类型中可以声明/实现同名的方法。但是，同一个类型实现的方法不允许重名。\n- 结构体的域的名字不能和该结构体实现的方法重名。但不同结构体之间可以有同名的域。\n- 类型名字处于独立的命名空间，且不允许重名。\n- 接口名字处于独立的命名空间，且不允许重名。\n- 代数数据类型的分支名字处于独立的命名空间，且不允许重名。\n\n变量的作用域规则比较复杂，这里用如下的例子来展示：\n```\nfun (x1 : A) {\n    // 作用域S1\n    let x2 : B = ...;\n\n    for ({let x3 : C = ...}; ...) {\n        // 作用域S2，嵌套于S1中，与S3平行\n    }\n\n    for ({let x4 : D = ...}; ...) {\n        // 作用域S3，嵌套于S1中，与S2平行\n    }\n}\n```\n所有局部变量，包括函数的参数，处于同一个命名空间中。同一个局部作用域内，不允许有重名/覆盖定义。因此，上述例子中，`x1`和`x2`不能重名。但是对于嵌套的局部作用域，内层作用域可以覆盖外层作用域的名字。在上面的例子中，`x3`、`x4`都可以与`x1`或`x2`重名，并会在各自的作用域内覆盖掉`x1`/`x2`的定义。互不嵌套的作用域互不干扰。所以上述作用域`S2`、`S3`互不干涉，`x3`和`x4`可以重名。\n## 仍在设计中的特性\n\nDeeplang目前正处于活跃开发中。上述的设计和特性都尚未稳定，随时可能被更改。下面是一些仍在讨论中的特性，它们可能会在未来成为语言的一部分。\n\n### 数组宏\n\nDeeplang是一门面向IoT的语言，在IoT编程中一个十分重要的应用场景就是对各类二进制协议的高效解析。关于Deeplang中如何支持这一场景仍在讨论中。其中一个语言层面的方案是支持内建的数组操作宏，例如：\n\n```dp\nlet arr: [i32; 100] = [];\narr@match([s] == 1, [s + 10] == 1);\n```\n']
LeNet-5,LeNet-5,Use C Program Language Without Any 3rd Library,61,https://github.com/fan-wenjie/LeNet-5,master,['\ufeff# LeNet-5神经网络\n\n### 介绍\n根据YANN LECUN的论文《Gradient-based Learning Applied To Document Recognition》设计的LeNet-5神经网络，C语言写成，不依赖任何第三方库。\nMNIST手写字符集初代训练识别率97%，多代训练识别率98%。\n\n### DEMO\nmain.c文件为MNIST数据集的识别DEMO，直接编译即可运行，训练集60000张，测试集10000张。\n\n### 项目环境\n该项目为VISUAL STUDIO 2015项目，用VISUAL STUDIO 2015 UPDATE1及以上直接打开即可编译。采用ANSI C编写，因此源码无须修改即可在其它平台上编译。\n如果因缺少openmp无法编译，请将lenet.c中的#include&lt;omp.h&gt;和#pragma omp parallel for删除掉即可。\n\n### API\n#####批量训练\nlenet:  LeNet5的权值的指针，LeNet5神经网络的核心\n\ninputs： 要训练的多个图片对应unsigned char二维数组的数组,指向的二维数组的batchSize倍大小内存空间指针。在MNIST测试DEMO中二维数组为28x28，每个二维数组数值分别为对应位置图像像素灰度值\n\nresMat：结果向量矩阵\n\nlabels：要训练的多个图片分别对应的标签数组。大小为batchSize\n\nbatchSize:批量训练输入图像（二维数组）的数量\n\nvoid TrainBatch(LeNet5 *lenet, image *inputs, const char(*resMat)[OUTPUT],uint8 *labels, int batchSize);\n\n#####单个训练\nlenet:  LeNet5的权值的指针，LeNet5神经网络的核心\n\ninput： 要训练的图片对应二维数组\n\nresMat：结果向量矩阵\n\nlabel: 要训练的图片对应的标签\n\nvoid Train(LeNet5 *lenet, image input, const char(*resMat)[OUTPUT],uint8 label);\n\n#####预测\nlenet:  LeNet5的权值的指针，LeNet5神经网络的核心\n\ninput:  输入的图像的数据\n\nlabels: 结果向量矩阵指针\n\ncount:\t结果向量个数\n\nreturn  返回值为预测的结果\n\nint Predict(LeNet5 *lenet, image input, const char(*labels)[LAYER6], int count);\n\n#####初始化\nlenet:  LeNet5的权值的指针，LeNet5神经网络的核心\n\nvoid Initial(LeNet5 *lenet);']
osnotes,Some notes or translations about operating system or programming language.,69,https://github.com/wyfcyx/osnotes,master,['## Translation List\n[200 行代码讲透 Rust Future](https://github.com/wyfcyx/osnotes/blob/master/pl/Rust/future-in-200-lines.md): 翻译完成\n']
rust-book,Rust 程式語言 正體中文版 (The Rust Programming Language, Traditional Chinese),83,https://github.com/askeing/rust-book,master,['# Rust 程式語言 正體中文版\n\n**持續翻譯中...**\n\n您可於 [http://askeing.github.io/rust-book/](http://askeing.github.io/rust-book/) 瀏覽本書。\n\n## 原始檔\n\n本書為 "[The Rust Programming Language](https://doc.rust-lang.org/book/)" 的正體中文翻譯。\n\n可在 [Rust](https://github.com/rust-lang/rust) 專案的 `src/doc/book/` 目錄下取得原始檔案。\n\n## 建置本書\n\n建置本書的話需要 [mdBook] 工具，可以用以下指令安裝：\n\n```bash\n$ cargo install mdbook\n```\n\n[mdBook]: https://github.com/azerupi/mdBook\n\n然後可以用以下指令建置本書：\n\n```bash\n$ mdbook build\n```\n\n輸出的網頁會放在 `book` 目錄下，可以開啟瀏覽器檢視結果。\n\n```bash\n$ firefox book/index.html\n```\n\n## 中英對照\n\n[中英文字彙對照表](src/MappingTable.md)\n\n## 貢獻本專案\n\n翻譯前請參考 [中英文字彙對照表](src/MappingTable.md) 及 [中文文案排版指南](https://github.com/sparanoid/chinese-copywriting-guidelines) 進行翻譯。\n\n目前的翻譯進度及認領請到 [已翻譯清單 & 章節認領區](https://github.com/askeing/rust-book/issues/16) 查詢。\n\n## 貢獻名單\n\n[貢獻名單](src/CONTRIBUTORS.md)\n']
Adept,The Adept Programming Language,86,https://github.com/AdeptLanguage/Adept,master,['<img src="https://raw.github.com/AdeptLanguage/Adept/master/.github/README_logo.png" width="275" height="240">\n\n## Adept\nA blazing fast language for general purpose programming.\n\n[Download Adept v2.7 for Windows](https://github.com/IsaacShelton/Adept/releases)\n\n[Download Adept v2.7 for MacOS](https://github.com/IsaacShelton/Adept/releases)\n\n[Download Adept v2.7 Cross-Compilation Extensions](https://github.com/IsaacShelton/AdeptCrossCompilation/releases/)\n\n## Resources\n[Adept v2.6 Documentation (v2.7 in progress)](https://github.com/AdeptLanguage/Adept/wiki)\n\n[Adept v2.7 Vim Syntax Highlighting](https://github.com/IsaacShelton/AdeptVim)\n\n[Adept v2.7 VS-Code Syntax Highlighting](https://github.com/IsaacShelton/AdeptVSCode)\n\n[Adept v2.7 VS-Code Basic Syntax Checking](https://github.com/IsaacShelton/AdeptVSCodeLanguage)\n\n[Adept v2.7 Standard Library](https://github.com/AdeptLanguage/AdeptImport)\n\n[Adept v2.7 Working with Domestic and Foreign Libraries](https://github.com/IsaacShelton/AdeptWorkingWithC)\n\n[Adept v2.7 MacOS Homebrew Tap](https://github.com/AdeptLanguage/homebrew-tap)\n\n## Command-Line Usage\n\n`adept [filename] [options]`\n\n- filename - default is \'main.adept\'\n- options - secondary compiler options\n\nYou can optionally use `adept2-7` instead of `adept` if you have multiple versions installed.\n\n## Basic Functionality\n\n### Hello World\n\n```\nimport basics\n\nfunc main {\n    print("Hello World!")\n}\n```\n\n### Variables\n\n```\nimport basics\n\nfunc main {\n    name String = "Alan"\n    age int = 36\n    height uint = 189\n    \n    print("Name is " + name)\n    print("Age is " + age)\n    print("Height is " + height + " cm")\n}\n```\n\n### Functions\n\n```\nimport basics\n\nfunc main {\n    greet("Alice")\n}\n\nfunc greet(name String) {\n    print("Hello " + name)\n}\n```\n\n### Records\n\n```\nimport basics\n\nrecord Person (name String, age int) {\n    func print {\n        print(this.name + " is " + this.age + " years old")\n    }\n}\n\nfunc main {\n    Person("John Smith", 36).print()\n}\n```\n\n### Structs\n\n```\nimport basics\n\nstruct Configuration (\n    filename String,\n    numBatteries int,\n    numPorts int,\n){\n    constructor(filename String) {\n        this.filename = filename.commit()\n        this.numBatteries = 4\n        this.numPorts = 10\n    }\n}\n\nfunc toString(config Configuration) String {\n    return config.filename + ":" + config.numBatteries + ":" + config.numPorts\n}\n\nfunc main {\n    print(Configuration("settings.config"))\n}\n```\n\n### Pointers\n\n```\nimport basics\n\nfunc main {\n    x, y int = 0\n\n    x++\n    y++\n    addOneTo(&x)\n\n    print("x = " + x)\n    print("y = " + y)\n}\n\nfunc addOneTo(pointerToNumber *$T~__number__) {\n    (*pointerToNumber)++\n}\n```\n\n### Conditionals and Loops\n\n```\nimport basics\n\nfunc main {\n    name String = scan("What is your name? ")\n    age int = scanInt("How old are you? ")\n    \n    // If conditional\n    if name == "Isaac" {\n        print("Hello Isaac :)")\n    } else {\n        print("Nice to meet you " + name)\n    }\n    \n    // Unless conditional\n    unless age > 21 {\n        print("You are too young to drink")\n    }\n    \n    // While loops\n    while age < 18 {\n        print("**birthday**")\n        age += 1\n    }\n    \n    print("You are now old enough to smoke")\n    \n    // Until loops\n    until age >= 21 {\n        print("**birthday**")\n        age += 1\n    }\n    \n    print("You are now old enough to drink")\n}\n```\n\n### Lists\n\n```\nimport basics\n\nrecord Invitation (to, from String, priority int)\n\nfunc main {\n    invites <Invitation> List\n    invites.add(Invitation("Isaac", "Peter", 4))\n    invites.add(Invitation("Mr. Smith", "Mrs. Smith", 12))\n    invites.add(Invitation("James", "Paul", 3))\n\n    each Invitation in invites {\n        printf("invites[%zu] = %S\\n", idx, toString(it))\n    }\n}\n\nfunc toString(invite Invitation) String {\n    return invite.to + " invited " + invite.from + " with priority " + invite.priority\n}\n```\n\n### Ownership\n\n```\n/*\n    For values that use ownership-based memory management\n    (e.g. String, List, Grid)\n    \n    we must transfer ownership if we want to keep them\n    alive for longer than their owner\'s scope\n*/\n\nimport basics\n\nfunc main {\n    everyone <String> List = getEveryoneAttending()\n    \n    each fullname String in everyone {\n        print("=> " + fullname)\n    }\n}\n\nfunc getEveryoneAttending() <String> List {\n    everyone <String> List\n\n    person1 String = getFullnameReturnImmediately("Alice", "Golden")\n    person2 String = getFullnameStoreAndThenLaterReturn("Bob", "Johnson")\n\n    // Commit ownership of strings held by \'person1\' and \'person2\'\n    // to be managed by the list\n    everyone.add(person1.commit())\n    everyone.add(person2.commit())\n\n    // Commit ownership of the list to the caller\n    return everyone.commit()\n}\n\nfunc getFullnameReturnImmediately(firstname, lastname String) String {\n    // \'.commit()\' is not necessary here\n    return firstname + " " + lastname\n}\n\nfunc getFullnameStoreAndThenLaterReturn(firstname, lastname String) String {\n    fullname String = firstname + " " + lastname\n    \n    // Ownership of the result is held by \'fullname\',\n    // so we must transfer ownership to the caller in order\n    // to keep it alive after this function returns\n\n    // \'.commit()\' is necessary here\n    return fullname.commit()\n}\n```\n\n### Loop Labels\n\n```\nimport basics\n\nfunc main {\n    print(makeNumericSkewer())\n    print(makeAlphabetSkewer())\n}\n\nfunc makeNumericSkewer String {\n    // Example output: `0-2-4-6-8-10-13-16-19-22-25-28`\n\n    skewer String\n\n    while continue preparing {\n        skewer.append(skewer.length)\n\n        if skewer.length < 30 {\n            skewer.append("-")\n            continue preparing\n        }\n    }\n\n    return skewer\n}\n\nfunc makeAlphabetSkewer String {\n    // Example output: `a-c-e-g-i-k-m-o-q-s-u-w-y`\n\n    skewer String\n\n    while still_making_skewer : skewer.length < 30 {\n        skewer.append(\'a\'ub + skewer.length as ubyte)\n\n        if skewer[skewer.length - 1] == \'y\'ub {\n            break still_making_skewer\n        }\n\n        skewer.append("-")\n    }\n\n    return skewer\n}\n```\n\n### Named Expressions and Global Variables\n\n```\nimport basics\n\n// Will be re-evaluated with each use\ndefine GREETING = "Welcome"\ndefine STRANGER_NAME = "guest"\ndefine WELCOME_MESSAGE = GREETING + " " + STRANGER_NAME + "!"\n\n// Will only be evaluated once when the program starts\nARCH_STRING String = #get __arm64__ ? "arm64" : #get __x86_64__ ? "x86_64" : "other"\n\nfunc main {\n    print(WELCOME_MESSAGE)\n    print("You are using architecture: " + ARCH_STRING)\n}\n```\n\n### Low-Level Dynamic Allocation\n\n```\nimport \'sys/cstdio.adept\'\nimport \'sys/cstdlib.adept\'\nimport \'sys/cstring.adept\'\n\nfunc main int {\n    withMallocAndFree(\'Will\', \'Johnson\')\n    withNewAndDelete(\'John\', \'Wilson\')\n    return 0\n}\n\nfunc withMallocAndFree(firstname, lastname *ubyte) void {\n    // Manual C-String manipulation using malloc, free, and sprintf\n    \n    fullname *ubyte = malloc(strlen(firstname) + strlen(lastname) + 2)\n    defer free(fullname)\n\n    sprintf(fullname, \'%s %s\', firstname, lastname)\n    printf(\'Fullname is: %s\\n\', fullname)\n}\n\nfunc withNewAndDelete(firstname, lastname *ubyte) void {\n    // Manual C-String manipulation using new, delete, and sprintf\n    \n    fullname *ubyte = new ubyte * (strlen(firstname) + strlen(lastname) + 2)\n    defer delete fullname\n\n    sprintf(fullname, \'%s %s\', firstname, lastname)\n    printf(\'Fullname is: %s\\n\', fullname)\n}\n```\n\n### Command-Line Arguments\n```\nimport basics\n\nfunc main(argc int, argv **ubyte) {\n    // C-Style\n    // Print out each argument specified\n    each *ubyte in [argv, argc] {\n        printf("args[%zu] = %s\\n", idx, argv[idx])\n    }\n\n    // Collect arguments into string list\n    args <String> List = Array(argv, argc).map(func &stringConstant)\n\n    // Adept-style\n    // Print out arguments again, except in cleaner way\n    each String in args {\n        printf("args[%zu] = %S\\n", idx, it)\n    }\n\n    if args.contains("-h") || args.contains("--help") {\n        print("You asked for help, but I have no help to show you")\n    }\n}\n```\n\n### Function Pointers\n\n```\nimport basics\nimport random\n\nfunc sum(a, b int) int = a + b\nfunc mul(a, b int) int = a * b\n\nfunc main {\n    randomize()\n\n    doCalculation func(int, int) int = null\n    \n    if normalizedRandom() < 0.5 {\n        doCalculation = func &sum\n    } else {\n        doCalculation = func &mul\n    }\n\n    print("Result of 8 and 13 is " + doCalculation(8, 13))\n}\n```\n\n### Defer Statements\n\n```\nimport basics\n\nfunc main {\n    defer print("I will be printed last")\n    defer print("I will be printed second")\n    defer print("I will be printed first")\n    print("I will be printed before anyone else")\n}\n```\n\n### Undef Keyword\n\n```\nimport \'sys/cstdio.adept\'\n\nfunc main(argc int, argv **ubyte) int {\n    // Will be initialized to 0\n    zero_value int\n\n    // Will be initialized to null\n    null_pointer *ulong\n\n    // Will be undefined (left uninitialized)\n    undefined_value int = undef\n    undefined_pointer *ulong = undef\n\n    printf(\'%d == 0, %d == ?\\n\', zero_value, undefined_value)\n    printf(\'%p == null, %p == ?\\n\', null_pointer, undefined_pointer)\n    return 0\n}\n```\n\n### Pragma Directives\n\n```\npragma compiler_version \'2.7\'\npragma project_name \'my_cool_project\'\npragma optimization aggressive\n\nimport basics\n\nfunc main {\n    print("Hello World")\n}\n```\n\n### Primitive Types\n\n```\nfunc main {\n    // 8-bit Types\n    a_bool   bool   = false\n    a_byte   byte   = 0sb\n    a_ubyte  ubyte  = 0ub\n\n    // 16-bit Types\n    a_short  short  = 0ss\n    a_ushort ushort = 0us\n\n    // 32-bit Types\n    an_int   int    = 0si\n    a_uint   uint   = 0ui\n    a_float  float  = 0.0f\n\n    // 64-bit Types\n    a_long   long   = 0sl\n    a_ulong  ulong  = 0ul\n    a_double double = 0.0d\n    a_usize  usize  = 0uz\n\n    // 64-bit or 32-bit depending on the system\n    a_ptr    ptr    = null\n    int_ptr  *int   = null\n\n    return 0\n}\n```\n\n### Type Casting\n\n```\nimport basics\n\nfunc main {\n    value int = 1234\n    \n    // x as Type   is equivalent to   cast Type x\n    \n    // Primitive value casting\n    result1 double = value as double\n    result2 double = cast double value\n    \n    // Arbitrary pointer casting\n    result3 *uint = &value as *uint\n    result4 *uint = cast *uint &value\n    \n    // Expression result casting\n    result5 usize = (value + 1) as usize\n    result6 usize = cast usize (value + 1)\n}\n```\n\n### Runtime Type Information\n\n```\nimport basics\n\nfunc main {\n    print("Every type used in this program: ")\n    \n    each *AnyType in [__types__, __types_length__] {\n        print(" => " + stringConstant(it.name))\n    }\n    \n    print("...")\n    print("Each member of type \'String\':")\n    \n    string_type *AnyStructType = typeinfo String as *AnyStructType\n    repeat string_type.length {\n        field_name String = stringConstant(string_type.member_names[idx])\n        field_type String = stringConstant(string_type.members[idx].name)\n        print(" => " + field_name + " " + field_type)\n    }\n}\n```\n\n### Conditional Compilation\n\n```\n#default should_fake_windows   false\n#default should_fake_macos     false\n#default enable_secret_feature false\n\n#if enable_secret_feature\n    #print "Doing super secret feature stuff..."\n    #set should_fake_windows true\n    #set should_fake_macos   true\n#end\n\nimport basics\n\nfunc main {\n    #if should_fake_windows && should_fake_macos\n        print("Hello from Windows and MacOS???")\n    #elif __windows__ || should_fake_windows\n        print("Hello on Windows!")\n    #elif __macos__ || should_fake_macos\n        print("Hello on MacOS!")\n    #end\n}\n```\n\n### Polymorphism\n\n```\nimport basics\n\nfunc sum(a, b $T) $T = a + b\n\nfunc main {\n    print(sum(8, 13))\n    print(sum(3.14159, 0.57721))\n    print(sum(\' \'ub, \'!\'ub))\n    print(sum(true, false))\n    print(sum("Hello", " World"))\n}\n```\n\n### Polymorphic Structures\n\n```\nimport basics\n\nrecord <$T> Couple (first, second $T)\n\nfunc main {\n    coord <int> Couple\n    coord.first = 3\n    coord.second = 4\n    print("Distance is: " + coord.distance())\n    \n    socks <String> Couple = Couple("Left Sock", "Right Sock")\n    print(socks)\n}\n\nfunc toString(couple <$T> Couple) String {\n    return toString(couple.first) + " " + toString(couple.second)\n}\n\nfunc distance(this *<$T~__number__> Couple) $T {\n    const x double = cast double this.first\n    const y double = cast double this.second\n    return sqrt(x * x + y * y) as $T\n}\n```\n\n### Delayed Method Declaration\n\n```\nimport basics\n\nrecord Unit (hp int) {\n    func damage(atk int) {\n        this.hp -= atk\n    }\n}\n\nfunc heal(this *Unit, pts int) {\n    this.hp += pts\n}\n\nfunc main {\n    unit Unit = Unit(10)\n    unit.damage(7)\n    unit.heal(4)\n    print("Remaining HP: " + unit.hp)\n}\n```\n\n### Intrinsic Loop Variables\n\n```\nimport basics\n\nfunc main {\n    my_integers <int> List\n    \n    // Add numbers 0..9 inclusive to list\n    repeat 10, my_integers.add(idx)\n    \n    // Square each number in the list\n    each int in my_integers, it = it * it\n    \n    // Print each number\n    each int in my_integers {\n        printf("my_integers[%zu] = %d\\n", idx, it)\n    }\n}\n```\n\n### Classes and Virtual Dispatch\n```\nimport basics\n\nclass Shape () {\n    constructor {}\n    \n    virtual func draw {}\n}\n\nclass Rectangle extends Shape (w, h float) {\n    constructor(w, h float) {\n        this.w = w\n        this.h = h\n    }\n    \n    override func draw {\n        printf("Rectangle %f by %f\\n", this.w, this.h)\n    }\n}\n\nclass Circle extends Shape (radius float) {\n    constructor(radius float) {\n        this.radius = radius\n    }\n    \n    override func draw {\n        printf("Circle with radius %f\\n", this.radius)\n    }\n}\n\nfunc main {\n    shapes <*Shape> List\n    \n    defer {\n        each *Shape in shapes, delete it\n    }\n     \n    shapes.add(new Rectangle(4.0, 5.0) as *Shape)\n    shapes.add(new Circle(9.0) as *Shape)\n\n    each *Shape in shapes {\n        it.draw()\n    }\n}\n```\n\n## Applications in Adept 2.0\n\n- [(2.0) Tic-Tac-Toe](https://github.com/IsaacShelton/AdeptTicTacToe)\n- [(2.0) Neural Network](https://github.com/IsaacShelton/AdeptNeuralNetwork)\n- [(2.0) 2D Platformer](https://github.com/IsaacShelton/Adept2DPlatformer)\n- [(2.1) HexGL](https://github.com/IsaacShelton/HexGL)\n- [(2.1) Minesweeper](https://github.com/IsaacShelton/AdeptMinesweeper)\n- [(2.2) Another 2D Platformer](https://github.com/IsaacShelton/Tangent)\n- [(2.2) A* Path Finding](https://github.com/IsaacShelton/AdeptPathFinding)\n- [(2.3) Creature Gathering Game](https://github.com/IsaacShelton/Tadpole)\n- [(2.4) Card Game](https://github.com/IsaacShelton/GenericCardGame)\n- [(2.5) MiniBox Multiplayer Gamepad](https://github.com/IsaacShelton/MiniBox)\n- [(2.6) Shared Pointer Demo](https://github.com/IsaacShelton/AdeptSharedPtr)\n- [(2.7) RTS Parody Game](https://github.com/IsaacShelton/GalaxyCraft)\n- [(2.8) Windows GUI Examples](https://github.com/IsaacShelton/AdeptWin32Examples)\n\n## Popular Libraries and Ports\n- [(2.5) Box2D](https://github.com/IsaacShelton/Box2D)\n- [(2.6) SharedPtr](https://github.com/IsaacShelton/AdeptSharedPtr)\n\n## Additional Syntax Examples\n[See examples folder](https://github.com/IsaacShelton/Adept/tree/master/tests/e2e/src)\n\n## Thank you for sponsoring Adept ❤️\n- Fernando Dantas\n']
Awesome-Vision-and-RoadMaps,Awesome Vision and RoadMaps for Coder, Programming Language, Software Engineering, Web, Backend, Distributed Infrastructure, DataScience & AI | 技术领域前瞻与程序员的进阶之路,81,https://github.com/wx-chevalier/Awesome-Vision-and-RoadMaps,master,["![](https://i.postimg.cc/8zGQnXwb/image.png)\n\n# Awesome RoadMaps\n\n当我们站在技术之路的原点，未来可能充满了迷茫，也存在着很多不同的可能；我们可能成为 **Web/(大)前端/终端工程师、服务端架构工程师、测试/运维/安全工程师等质量保障、可用性保障相关的工程师、大数据/云计算/虚拟化工程师、算法工程师、产品经理**等等某个或者某几个角色。在这个知识爆炸与终身学习/碎片化学习为主的时代，我们面临的问题之一就是如何进行有效学习，不仅能有效平衡广度与深度，并且能真正的积淀下来，提升自己的研发效能。于笔者而言，常常郁结于胸的就是以下三个问题：\n\n- 应该学习什么？这是怎样的一个技术世界？存在着怎样的高峰与路径？\n- 如何克服遗忘带来的无效学习？\n- 如何不再碎片化地学习？\n\n究其根本，也就是需要拓展自己的**知识广度**，精进自己的**知识深度**，锤炼自己的**编程能力**。所谓知识广度，即是为实际问题选择合适的解决方案的能力，广义来说也是眼界与格局的表现。它并不拘泥于某个技术方向或者行业领域，而需要对传统/流行的各类语言、工具、框架、库、服务等有一定的认识；能够明晰各个方案的优劣，并在较高的层次（High Level）描述相关原理。知识广度的拓展与保持需要建立在庞大的阅读量与知识沉淀能力上。在[能力模型](https://github.com/wx-chevalier/Awesome-RoadMaps/blob/master/%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96/%E8%83%BD%E5%8A%9B%E6%A8%A1%E5%9E%8B.md)一节中，我们从业务、团队、技术这三个维度，对技术人员的五个层次进行了梳理：\n\n![路线图](https://i.postimg.cc/8CRhqMDF/image.png)\n\n[Awesome Lists](https://github.com/wx-chevalier/Awesome-Lists) 就为我们准备了精而全的技术开发学习与实践资料索引，去芜存菁，去重留一；譬如其中的 [Awesome WebSites](https://github.com/wx-chevalier/Awesome-Lists/blob/master/Specials/Awesome-WebSites.md) 一文就为我们推荐了值得阅读的资讯、博客等站点列表。知识广度的拓展也并非一蹴而就之事，需得循序渐进，从初窥门径，到登堂入室，最后融会贯通，当我们感觉乱花渐欲迷人眼，太多的碎片化知识反而使自己迷失方向之际，就可以前往 [Awesome CS Books Warehouse](https://github.com/wx-chevalier/Awesome-CS-Books)，去深入地阅读学习各个领域的精选书籍、课程等系统化的内容。\n\n俗话说，好记性不如烂笔头，当我们阅读的多了，自然也要开始记录；而笔者认为记录的开始就要有自己的知识体系。在自己的知识体系下随看随记、定期整理。唯有建立符合自己认知方式的知识图谱，才能有效地沉淀知识，明晰知识边界并进行不断地探索。上车伊始，笔者即致力于构建自己的 [Awesome MindMaps](https://github.com/wx-chevalier/Awesome-MindMaps)，提供了软件工程通用、前端、后端、DevOps、测试、架构师、人工智能工程师等多领域的知识图谱、学习成长路线与面试必备内容，并在数年来不断维护与刷新。\n\n笔者目前选择的是以 MarkDown 格式记录，并且将所有的笔记存放于 [Github-文档札记](https://github.com/topics/wx-doc)以 Git 方式进行版本管理；编辑器是直接使用的 VSCode，移动端编辑的话也是用的 GitGo/WorkCopy 这样的 Git 应用。这些笔记即是笔者自身技术视野与认知的外化，也类比于外设之于内存，在需要的时候分页加载到脑海中使用，以应对这知识爆炸的时代。其中的典型代表，[Awesome CheatSheets](https://github.com/wx-chevalier/Awesome-CheatSheets)，对于日常开发中用到的相关知识的备忘录/清单进行总结, 适合快速掌握或者回顾某个语言/框架/工具的语法或使用要点。[Tech Road, 我的技术之路](https://github.com/wx-chevalier/Developer-Zero-To-Mastery/blob/master/技术之路)是对于笔者多年学习与认知变迁的总结。\n\n先贤有云，知行合一，知是行之始，行是知之成，Linus Torvalds 也曾提到：'Talk is cheap. Show me the code.'，在阅读与笔记之后，就是要开始实践编码。所谓编程能力，并不仅仅是编写代码(Write Code)的能力，而是包含了阅读、编写、理解、重构、抽象等多个方面，是所谓的代码管理/掌控。其外在表现之一即是能够随时随地用合适的语言无阻塞地实现某些功能需求，对于常见的语法，接口，算法，设计模式等能够做到心随意动，信手拈来。编程能力是提升研发效能的重要保障，于笔者而言也是毕生应该追求的目标与爱好之一。笔者的编程能力较弱，日常开发，特别是在多语言多框架并用的场景下，往往会需要不断地中断，查找以继续工作，也是令我颇为苦恼。[Coding Snippets](https://github.com/topics/wx-snippets) 系列仓库，即是对笔者在编程语言、前后端编码过程中常用的模板、模式等代码片、工具库的汇聚。\n\n前文重在讨论如何拓宽技术视野、追寻技术的广度，但是需要铭记的是，技术深度才是技术广度的基石，正如中国自古以来常用道术之辩，知其然，也要知其所以然；亦如 Richard Feynman 所述：”What I cannot create, I do not understand.”。所谓知识深度，即是能够对某个方面做到深入了解，并且达到融会贯通，洞若观火，可以随心所欲地加以扩展、优化、创新等改造或变换。这方面则更加的见仁见智，不同的领域与方向对于深度的定义与挖掘方向也是千差万别。[Reinvent Wheels](https://github.com/topics/wx-code) 系列仓库即是笔者在前后端到基础架构中重造的轮子的汇总。\n\n我们需要自己去从零开始造些轮子，才能深刻理解使用的框架/库/平台的内部原理，才能在碰到故障时快速地修复；在下文的几乎每个章节中，我们都会提到某些笔者自造的轮子。笔者目前将所有的文档归类到了不同的系列中，每个系列又分为 篇-章-节-小节 这样的层次结构。\n\n# 编程语言与软件工程\n\n编程语言是一切的基础，正如 Steve McConnell 在 [Code Complete](https://github.com/wx-chevalier/Awesome-CS-Books) 一书中提及，我们应该 `Program into a language` 而不是 `Program in a language`，针对不同的需要选择合适的编程语言来实现，而不是受制于自己所会的语言。在[知识图谱](https://github.com/wx-chevalier/Awesome-MindMaps)中也包含了跨编程语言的公共知识杂谈，笔者与编程语言相关的文章存放在 [Programming Language Series | 编程语言语法基础与工程实践](https://github.com/wx-chevalier/ProgrammingLanguage-Series)仓库中，其涵盖了 **C/C++、Go、Java、JavaScript、Python、Rust、Swift** 等常见的语言，以及通用的[编程语言理论](https://github.com/wx-chevalier/ProgrammingLanguage-Series/blob/master/编程语言理论)。\n\n编程能力锻炼的基础，首要的就是关于[数据结构与算法](https://github.com/wx-chevalier/SoftwareEngineering-Series/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95)，以及[面向对象的设计模式](https://github.com/wx-chevalier/SoftwareEngineering-Series/tree/master/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)，其对应的代码分别存放在了 [coding-snippets](https://github.com/wx-chevalier/coding-snippets), [algorithm-snippets](https://github.com/wx-chevalier/algorithm-snippets), [design-pattern-snippets](https://github.com/wx-chevalier/design-pattern-snippets) 中。此外，我们还可以从零编写一些类似于 Guava & Lodash 这样的自己的通用工具库，笔者自身是整合在了 [Guash](https://github.com/wx-chevalier/guash) 中。\n\n在编程语言之上，我们就需要考虑如何去实现真正的软件系统，譬如 [软件工程基础](https://github.com/wx-chevalier/SoftwareEngineering-Series) 系列中的**开发工具/Git 漫谈、软件系统架构、软件质量保障**等内容，我们也可以自己去实现一些自己的工具，譬如笔者的 [Soogle](https://github.com/wx-chevalier/Soogle) 是构建自身搜索、外部服务访问能力的工具集合；而 [xCompass](https://github.com/wx-chevalier/xCompass) 是包含个人主页在内的多端阅读能力的源代码仓库。\n\n# About\n\n## RoadMaps\n\n- [Developer Roadmaps](https://roadmap.sh/): Step by step guides and paths to learn different tools or technologies\n\n- [golang-developer-roadmap](https://github.com/Alikhll/golang-developer-roadmap): Roadmap to becoming a Go developer in 2020\n\n- [data-engineer-roadmap](https://github.com/datastacktv/data-engineer-roadmap): Roadmap to becoming a data engineer in 2021\n\n## Copyright & More | 延伸阅读\n\n![License: CC BY-NC-SA 4.0](https://img.shields.io/badge/License-CC%20BY--NC--SA%204.0-lightgrey.svg)\n\n笔者所有文章遵循[知识共享 署名 - 非商业性使用 - 禁止演绎 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh)，欢迎转载，尊重版权。您还可以前往 [NGTE Books](https://ng-tech.icu/books-gallery/) 主页浏览包含知识体系、编程语言、软件工程、模式与架构、Web 与大前端、服务端开发实践与工程架构、分布式基础架构、人工智能与深度学习、产品运营与创业等多类目的书籍列表：\n\n[![NGTE Books](https://s2.ax1x.com/2020/01/18/19uXtI.png)](https://ng-tech.icu/books-gallery/)\n"]
SQL-Database-Management-System,SQL is a domain-specific language used in programming and designed for managing data held in a relational database management system, or for stream processing in a relational data stream management system.,88,https://github.com/soumyadip007/SQL-Database-Management-System,master,['# SQL-Database-Management-System']
PHP-JS-Basics-Architecture-Form-CURD-Registration-Login,PHP: Hypertext Preprocessor is a general-purpose programming language originally designed for web development. It was originally created by Rasmus Lerdorf in 1994; the PHP reference implementation is now produced by The PHP Group. (Materials for training),69,https://github.com/soumyadip007/PHP-JS-Basics-Architecture-Form-CURD-Registration-Login,master,['# PHP\n# JS\n# MySql DB connection\n# Projects\n']
Awesome-MindMaps,Awesome MindMaps for Coder, Programming Language, Software Engineering, Web, Backend, Distributed Infrastructure, DataScience & AI | 超全的思维脑图集锦,62,https://github.com/wx-chevalier/Awesome-MindMaps,master,['![知识脉络题图](https://pic.imgdb.cn/item/611770e15132923bf8e7315c.jpg)\n\n# Awesome MindMaps for ITCS\n\n[Awesome ITCS MindMaps](https://github.com/wx-chevalier/Awesome-MindMaps) 是笔者所有系列文章、代码、项目中的知识系统的脑图形式的总结：\n\n- 知识脉络\n\n![知识脉络](https://i.postimg.cc/fL2rzBx1/image.png)\n\n- 知识要点\n\n![知识要点](https://i.postimg.cc/FKNBH7GC/image.png)\n\n本仓库所有文件以 MindMap 软件编辑，也基于 [xmind-viewer](https://github.com/xmindltd/xmind-viewer) 提供了 Web 在线预览版本以供查看。\n\n# About\n\n## Acknowledgements\n\n- [https://github.com/panjianlong13/MindMapSummary](https://github.com/panjianlong13/MindMapSummary): 自己学习总结了一些思维导图(持续更新中)，分享给大家。\n\n## Copyright & More | 延伸阅读\n\n[![技术视野](https://s3.ax1x.com/2021/02/21/yTSKdH.png)](https://github.com/wx-chevalier/Awesome-MindMaps)\n\n您还可以前往 [NGTE Books](https://ng-tech.icu/books-gallery/) 主页浏览包含知识体系、编程语言、软件工程、模式与架构、Web 与大前端、服务端开发实践与工程架构、分布式基础架构、人工智能与深度学习、产品运营与创业等多类目的书籍列表：\n\n[![NGTE Books](https://s2.ax1x.com/2020/01/18/19uXtI.png)](https://ng-tech.icu/books-gallery/)\n']
Demos,:fire: the go programming language go Demos， go语言例子 go语言圣经 练习题  go 语言书籍 bootstrap 练习 sql-mysql练习,86,https://github.com/basicExploration/Demos,master,[' \n- [googege\'s blog](https://github.com/googege/blog)\n- [关于go语言的一些解释](https://github.com/googege/Files/tree/master/EXPLAIN.md)\n- [Go语言demos](https://github.com/googege/Files/tree/master/godemo)\n- [Go语言圣经书中代码以及完成的练习题](https://github.com/googege/Files/tree/master/gop_homework)\n- [Go语言圣经以及其它书籍📚](https://github.com/imgoogege)\n- [SQL练习](https://github.com/googege/Files/tree/master/SQLTest)\n- [BootstrapTest 练习](https://github.com/googege/Files/tree/master/BootstrapTest)\n- [计算机里的小技巧](https://github.com/googege/Files/tree/master/computergold.md)\n- [Docker入门](https://github.com/googege/Files/tree/master/docker/README.md)\n- [hello Dart](https://github.com/googege/Files/tree/master/helloDart/README.md)\n- [hello C](https://github.com/googege/Files/tree/master/helloC)\n- [hello Python](https://github.com/googege/Files/tree/master/helloPython)\n- [hello ShellScript](https://github.com/googege/Files/tree/master/helloShellScript)\n- [review JavaScript](https://github.com/googege/Files/tree/master/reviewJavaScript)\n\n---\n### 欢迎加入算法讨论群\n![p](https://raw.githubusercontent.com/googege/AMAC/master/joinUs.png)\n***\n☕️如何真的对你有帮助，你可以请我喝杯咖啡，这样我就可以有精神了，多谢多谢\n\n![p](https://raw.githubusercontent.com/googege/Files/master/donate.png)\n\n[推荐vps](https://app.cloudcone.com/?ref=2525)\n\n[VPS网站使用说明](https://www.bilibili.com/video/av38630366)\n\n*可支持 **支付宝支付**, 个人提子使用版本 2刀/月，`1T`流量 ，最高`1Gb`带宽， 速度测试:基本上在`1M/s` 以上,最高速度能达到`8M/s`(联通4g)*\n---\n<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。\n']
scilab,Read only copy of https://gitlab.com/scilab/scilab,54,https://github.com/ScilabOrg/scilab,master,['scilab/README.md']
TDKDictionaryCrawler, Collect Turkish language word from Turkish Language Institue web site http://www.tdk.gov.tr/ and create turkish word file. It can be useful for cryptanalysis and brute force password attacks and appeare other turkish language features. Türk Dil Kurumu (TDK) web sayfasından Türkçe kelimeleri toplayarak Türkçe kelime dosyası oluşturur. Son çalıştırdığında program toplam 76187 kelime toplamıştır. Toplanan kelimeler Türk diline ait özelliklerinin çıkarılması, şifre saldırıları ve kriptanaliz işlemlerinde kullanılabilir.,92,https://github.com/ncarkaci/TDKDictionaryCrawler,master,['# Türk Dil Kurumu (TDK) Türkçe Sözlük Kelime Toplayıcı / Turkish Language Institue Dictionary Crawler\n\nTürk Dil Kurumu (TDK) web sayfasından [http://www.tdk.gov.tr/](http://www.tdk.gov.tr/) Türkçe kelimeleri toplayarak Türkçe kelime dosyası oluşturur. Son çalıştırdığında program toplam 76187 kelime toplamıştır. Toplanan kelimeler Türk diline ait özelliklerinin çıkarılması, şifre saldırıları ve kriptanaliz işlemlerinde kullanılabilir.\n\nCollect Turkish language word from Turkish Language Institue web site [http://www.tdk.gov.tr/](http://www.tdk.gov.tr/) and create turkish word file. It can be useful for cryptanalysis and brute force password attacks and appeare other turkish language features.\n\n# Türkçe kelime sıralayıcısı\n\nPython dilinde Türkçe karakter içeren kelimeleri sıralamak istediğimizde doğru sıralama sonuçları döndürMemektedir. Her ne kadar locale dosyası Türk diline uygun konfigüre edilerek bu problem çözülmeye çalışılsa da "â", "ı" ve "i" vb. gibi karakterleri içeren kelimeler arasında doğru sıralama yapılamamaktadır. Özellikle "ı" ve "i" harfi içeren kelimeler doğru şekilde sıralanamaktadır. Bu problem için [isithza.com](https://belgeler.yazbel.com/python-istihza/gomulu_fonksiyonlar.html) adresinde çözüm önerilmiştir. Bununla birlikte ".", "/",","â" vb. gibi karakterler için önerilen yöntem çalışmamaktadır. İlgili yöntem tüm karakter kümeleri için düzenlenerek Türkçe kelimeler için sıralama yapacak python fonksiyonu oluşturulmuştur. İlgili fonksiyon TDK ve Zemberek sözlük birleştirilmesiyle elde edilen sözlük sıralanmasında kullanılarak test edilmiştir.\n\n# Sözlük birleştirici\n\nZaman zaman elimizde birden fazla sözlük dosyası yer almakta ve bu dosyaları tek bir dosya altında birleştirmek istemekteyiz. Bu durumda çözülmesi gereken iki problem bizi bekliyor; ilk olarak dosyalar birleştirilince tekrar eden kelimeler olmaması gerekiyor. İkinci durum ise birleştirme sonucu elde edilen dosyanın sıralanmış olması gerekiyor. Sıralama işlemi ingilizce kelimeler için problem olmazken Türkçe kelimeler de problem yaşanabilmektedir. Bu durumda bir önce başlıkta anlatılan Türkçe diline özgü sıralama fonksiyonu ile çözülmüştür. Bu amaçla kütüphane içerisinde yer alan birlestir.py betiği birden fazla sözlük içeren dosyaları tekrar eden kelimeler içermeyecek ve Türk alfabesine uygun olarak sıralanmış şekilde birleştirerek yeni bir dosya olarak kaydeder. Programa birleştirilmek üzere birden fazla dosya verilebilir.\n\n# İstatistik\n\nElimizde bulunan kelimelerin istatiksel değerleri için oluşturulmuş istatistik.py kütüphanesidir. Bu kütüphane elimizde bulunan kelime listesinde kaç adet kelime geçtiği, kelimelerin uzunlukları, hangi uzunlukta ne kadar kelime olduğu, bu uzunluk değerlerine göre kelime sayısı dağılımı, kelime listesine göre harf sayıları, harf sayılarının yüzdelik dağılımı gibi istatistiki bilgileri içerir. Bu bilgilere göre TDK ve Zemberek sözlüğün farklılık içerdiği gözlenmiştir. İlerki zamanlarda bu çalışmanın çıktıları burada yayınlanacaktır. Bu verilere özellikle n-gram değerleri ve bu değerlerin istatistik çıktıları eklenmesi gelecek çalışmalar arasındadır.\n\nTDK\'dan elde edilen kelimeler içinde harflerin kullanım sayısı ve yüzdelik dilimi Tablo\'de gösterilmiştir.\n\n| HARF | Kullanım Sayısı | Kullanım Yüzdesi |\n|------|-----------------|------------------|\n| a    | 83706           | 12.046           |\n| e    | 62987           | 9.065            |\n| l    | 56121           | 8.077            |\n| i    | 51988           | 7.482            |\n| k    | 49880           | 7.178            |\n| m    | 40547           | 5.835            |\n| r    | 38321           | 5.515            |\n| ı    | 34434           | 4.956            |\n| t    | 31581           | 4.545            |\n| n    | 29246           | 4.209            |\n| s    | 24800           | 3.569            |\n| u    | 19142           | 2.755            |\n| b    | 16669           | 2.399            |\n| y    | 15991           | 2.301            |\n| d    | 15758           | 2.268            |\n| ş    | 15349           | 2.209            |\n| o    | 14928           | 2.148            |\n| z    | 13146           | 1.892            |\n| ü    | 13006           | 1.872            |\n| c    | 9106            | 1.310            |\n| ç    | 9025            | 1.299            |\n| p    | 8269            | 1.190            |\n| g    | 8024            | 1.155            |\n| h    | 7479            | 1.076            |\n| v    | 7325            | 1.054            |\n| f    | 5638            | 0.811            |\n| ğ    | 5242            | 0.754            |\n| ö    | 4980            | 0.717            |\n| j    | 915             | 0.132            |\n| â    | 812             | 0.117            |\n| î    | 249             | 0.036            |\n| ̇     | 108             | 0.016            |\n| û    | 53              | 0.008            |\n| -    | 26              | 0.004            |\n| .    | 6               | 0.001            |\n| \'    | 3               | 0.000            |\n| /    | 3               | 0.000            |\n\nBenzer şekilde kelime listesinde bulunan kelimelerin uzunluklarına bakıldı ve bu değerler üzerinden kelime uzunluk dağılım değerleri çıkarıldı. Buna göre dilimizde en fazla 8, 7, 9 harften oluşan kelimeler bulunurken, en az 23 harften oluşan kelime bulunmaktadır. Kelime uzunluğu ve bu uzunluklarda kaç kelime olduğu Tablo 2\'de gösterilmiştir.\n\n| Kelime Uzunluğu | Bu Uzunlukta Kaç Kelime Kullanıldığı  | Bu Uzunlukta Kullanılan Kelime Sayısı Yüzdesi |\n|-----------------|---------------------------------------|-----------------------------------------------|\n| 8               | 9314                                  | 14.368578569                                  |\n| 7               | 8605                                  | 13.2748141063                                 |\n| 9               | 7756                                  | 11.9650735861                                 |\n| 10              | 7391                                  | 11.4019931505                                 |\n| 6               | 7078                                  | 10.9191323933                                 |\n| 5               | 6149                                  | 9.4859769831                                  |\n| 11              | 5503                                  | 8.4894017463                                  |\n| 12              | 3495                                  | 5.3916880072                                  |\n| 4               | 2400                                  | 3.7024467002                                  |\n| 13              | 2302                                  | 3.5512634599                                  |\n| 14              | 1708                                  | 2.6349079016                                  |\n| 15              | 1032                                  | 1.5920520811                                  |\n| 3               | 863                                   | 1.3313381259                                  |\n| 16              | 459                                   | 0.7080929314                                  |\n| 17              | 247                                   | 0.3810434729                                  |\n| 2               | 212                                   | 0.3270494585                                  |\n| 18              | 128                                   | 0.197463824                                   |\n| 19              | 70                                    | 0.1079880288                                  |\n| 1               | 47                                    | 0.0725062479                                  |\n| 20              | 40                                    | 0.061707445                                   |\n| 21              | 17                                    | 0.0262256641                                  |\n| 22              | 3                                     | 0.0046280584                                  |\n| 23              | 3                                     | 0.0046280584                                  |\n\n\nTDK kelime listesine göre en uzun 23 harften oluşan kelime bulunmaktadır. 23 harften oluşan bu en uzun 3 kelime; belirsizleştirilebilmek, demokratikleştirebilmek, belirginleştirilebilmek.\n\n# n-gram kelime listesi oluşturucu\n\nKelimelere ait n-gram değerlerini oluşturup bunları dosyaya yazan betik. Bu betik sonuçları istatistik betiği ile incelenecektir.\n\n# Kelime listesi farkları ve benzerlikleri\n\nTDK üzerinden kelimeler toplandıktan sonra bu kelime listesinin Zemberek ile güçlendirilmesi düşünmüştüm. Bu betik ile TDK sözlük ve zemberek sözlük arasında hangi kelimelerin farklı olduğunu, hangilerinin ortak olduğunu çıkarmaya çalıştım. Ayrıca istatistik kütüphanesi kullanılarak bu farklı kümeler aradasındaki değerler de ilerki zamanlarda araştırılabilir. İLk bakışta TDK\'da bulunan fakat Zemberekte bulunmayan kelimeler olması beni çok şaşırttığını söyleyebilir. TDK\'da olan yaklaşık 25.000 sözcük zemberekte yok. Yaklaşık 40.000 kadar kelimede ortak.\n\n# Rastgele kelime seçme\n\nVerilen kelime listesinden rastgele istenilen sayı kadar kelime getirir. Bu betik yazılmasından Murat Gülsoy\'un Bu Kitabı Çalın isimli kitabındaki bir öyküden esinlenilmiştir. Betik her çalıştırıldığında rastgele kelimeler üretmektedir. Ayrıca sıkıcı zamanlarda arkadaşlarımla oynadığım oyununda temelidir. Oyun şu şekildedir, karşınızdaki size rastgele kelimeler verir ve sizden bu kelimeleri kullanarak bir öykü uydurmanızı ister. Sonra onun verdiği rastgele kelimelerle öyküyü devam ettirmenizi bekler. Bu durum sırayla devam eder. Daha adil olması kelimelerin tamamen rastgele seçilmesi için bu programı kullanabilirsiniz. Bu programı kullanarak oynadığınız oyun sonucunda elde ettiğiniz öyküyü yorum kısmına yazabilirsiniz.\n']
friends-lang,PL for friends in the Japaripark (Logical programming language with Japanese animation-reference joke syntax),66,https://github.com/vain0x/friends-lang,main,['# フレンズ言語 (Friends-lang)\n\n[![Build Status](https://travis-ci.org/vain0x/friends-lang.svg?branch=master)](https://travis-ci.org/vain0x/friends-lang)\n\n**フレンズ言語** は、ジャパリパークのフレンズのためのプログラミング言語。\n\n- [すごーい！ きみはプログラミング言語を実装できるフレンズなんだね - Qiita](http://qiita.com/vain0x/items/6d3b75f667d3ec7f1d2a)\n\n## インストールと使い方\n\n- [最新版のパッケージをダウンロード](https://github.com/vain0x/friends-lang/releases/latest)して展開します。\n    - Windows の場合は `friendsi-win-x64.zip`\n    - macOS の場合は `friendsi-osx-x64.zip`\n    - Linux の場合は `friendsi-linux-x64.zip`\n- `friendsi.exe` (または `friendsi`) を実行します。\n- ようこそジャパリパークへ！\n\n## 文法\n### すごーい！ 文\nすごーい！ 文では、事実を述べることができる。\n\n```\nすごーい！ かばんちゃん は ヒトの フレンズ なんだね！\n```\n\n条件つきのすごーい！文では、仮定が真である場合に、結論も真であることを述べる。以下の例では、命題「あなた が ヒトの フレンズ」が真である場合に、命題「あなた は しっぽのない フレンズ なんだね！」も真であることを述べている。\n\n```\nすごーい！ あなた が ヒトの フレンズ なら\nあなた は しっぽのない フレンズ なんだね！\n```\n\n### なんだっけ？ 文\nなんだっけ？ 文では、事実を確認したり、一定の性質を満たすものを探索したりできる。\n\n```\nすごーい！ かばんちゃん は ヒトの フレンズ なんだね！\nすごーい！ あなた が ヒトの フレンズ なら\nあなた は しっぽのない フレンズ なんだね！\n\nだれ が しっぽのない フレンズ なんだっけ？\n```\n\n出力:\n\n```\n「だれ」は「かばんちゃん」、\nあってる？ (y/n)Y\nやったー！\n```\n\nこの なんだっけ？ 文では「かばんちゃんはヒトのフレンズ」かつ「ヒトのフレンズはしっぽのないフレンズ」だから「かばんちゃんはしっぽのないフレンズ」である、と推論している。\n\n## 推論\nなんだっけ？ 文の実行の手順について解説する。\n\n最初の手順は、与えられた命題の定義を探索することである。例えば、先述の文\n\n```\nだれ が しっぽのない フレンズ なんだっけ？\n```\n\nを実行するには、まず\n\n```\nX が しっぽのない フレンズ なんだね！\n```\n\nで終わる すごーい！ 文を探す。そして次が見つかる。\n\n```\nすごーい！ あなた が ヒトの フレンズ なら\nあなた は しっぽのない フレンズ なんだね！\n```\n\n次に、次の2つの命題を**単一化**する。\n\n- ``だれ が しっぽのない フレンズ``\n- ``あなた が しっぽのない フレンズ``\n\n単一化とは、2つの項や命題が同一になるように、変数の値を埋めていく処理をいう。この例では、変数「だれ」＝変数「あなた」という割り当てにより、2つの命題を同じ「あなた が しっぽのない フレンズ」に単一化できる。\n\n条件つきのすごーい！文は、仮定が真である場合にのみ、結論も真であると主張している。すなわち、この段階では、まだ命題\n\n```\nあなた が しっぽのない フレンズ\n```\n\nが真かどうかは分からない。そのため、仮定\n\n```\nあなた が ヒトの フレンズ\n```\n\nの真偽を判定する必要がある。繰り返しになるが、「X が ヒトの フレンズ」で終わる すごーい！ 文を探索して、\n\n```\nすごーい！ かばんちゃん は ヒトの フレンズ なんだね！\n```\n\nを見つける。「あなた が ヒトの フレンズ」と「かばんちゃん は ヒトの フレンズ」を単一化して、「あなた」＝「かばんちゃん」という割り当てを得る。このすごーい！ 文は無条件に成り立つので、確認すべき仮定はない。\n\n結局、変数「だれ」＝変数「あなた」＝「かばんちゃん」という割り当てにおいて、命題\n\n```\nだれ が しっぽのない フレンズ\n```\n\nすなわち\n\n```\nかばんちゃん が しっぽのない フレンズ\n```\n\nが真であることが分かる。\n\nフレンズ言語の仕組みは、「単一化」と「命題の真偽の判定」だけである。\n\n## 項\nフレンズ言語の **項** について説明する。(他の言語では式と呼ぶことが多いが、ここでは伝統に従って項と呼ぶ。)\n\n### 変数とアトム\n「だれ」「あなた」「きみ」などのいくつかの単語と、アンダーバー _ で始まる単語は、**変数** という。単一化において、変数は任意の項と単一化できる。ただし、既に変数 X が項 t に単一化されている状況では、同じ変数 X は t にのみマッチする。例えば、項「X と X」は「サーバル と サーバル」や「かばんちゃん と かばんちゃん」にマッチするが、「サーバル と かばんちゃん」にはマッチしない。\n\nそれ以外の単語 (先ほどの「かばんちゃん」など) は **アトム** という。単に文字列のことだと思ってかまわない。\n\n### 複合項\n``t の a`` という形の項を **複合項** という。複合項は、同じ形の複合項とマッチする。\n\n### リスト\n先に詳しい人のためにいっておくと、フレンズ言語のリストは cons セルであり、nil は単なるアトムである。\n\n``t_1 と t_2 と … と t_n`` という形の項を **リスト** という。リストは、同じ形のリストとマッチするが、後述の尾部を持つリストともマッチする。\n\n``t_1 と t_2 と … と t_n と ts とか`` という形の項を `ts` を **尾部とするリスト** という。これは平たくいえば、リスト ``t_1 と t_2 と … と t_n`` にリスト `ts` を連結したものだと思ってかまわない。例えば、変数 `_Xs` を尾部とするリスト ``a と b と _Xs とか`` は次のように単一化される。\n\n| 対象 | `_Xs` の値 |\n|:--:|:--:|\n| ``a と b`` | 長さ 0 のリスト |\n| ``a と b と c`` | `c` を含む長さ 1 のリスト |\n| ``a と b と c と d`` | ``c と d`` |\n\n`と` は `の` より優先順位が低い。「リスト の a」という形の複合項を記述する場合は、括弧 「」 を用いて、 ``「x と y」の a`` と書く。\n\n### 自然数\n自然数 (0, 1, 2, ...) は、アトムや複合項の略記である。まず、`0` は単にアトム `0` である。n = m + 1 とするとき、項 n は ``m の 次`` という複合項を表す。要するに、次の表のようになる。\n\n| 自然数 | 項 |\n|:--:|:--:|\n| 0 | `0` |\n| 1 | ``0 の 次`` |\n| 2 | ``0 の 次 の 次`` |\n| 3 | ``0 の 次 の 次 の 次`` |\n\nしたがって、\n\n```\nすごーい！ 3 は three フレンズ なんだね！\nあなた の 次 は three フレンズ なんだっけ？\n```\n\nとすると、変数「あなた」 = ``0 の 次 の 次`` = `2` という割り当てが得られる。\n']
coding-snippets,Code Snippets, DataStructure, Algorithm and DesignPattern Implementations/Solutions for Several Programming Language: Java, JavaScript, Go, Python, Rust, etc.  :dizzy: 多语言版本的数据架构与算法，设计模式，常用代码片等实现。,59,https://github.com/wx-chevalier/coding-snippets,master,['![image](https://user-images.githubusercontent.com/5803001/45917824-f2641680-beaf-11e8-8076-b0f139d88270.png)\n\n# coding-snippets\n\nCode Snippets, DataStructure, Algorithm and DesignPattern Implementations for Several Programming Language: Java, JavaScript, Go, Python, Rust, etc.\n\n[coding-snippets](https://github.com/wxyyxc1992/coding-snippets) 是 [Awesome-Coder](https://github.com/wxyyxc1992/Awesome-Coder) 系列的重要组成，其着眼于提升并保持开发者的实际编程能力；对于前端开发中的组件资源可以参考 [fractal-components, 多框架碎片化界面组件库](https://github.com/wxyyxc1992/fractal-components/)。\n\n为了更好地编排，项目中数据结构与算法相关的内容迁移到了 [algorithm-snippets](https://github.com/wxyyxc1992/algorithm-snippets), 设计模式相关内容迁移到了 [design-pattern-snippets](https://github.com/wxyyxc1992/design-pattern-snippets)\n\n# About\n\n![](https://cdn.dribbble.com/users/1131096/screenshots/3831443/book.png)\n\n## Home & More | 延伸阅读\n\n![](https://i.postimg.cc/59QVkFPq/image.png)\n\n您可以通过以下导航来在 Gitbook 中阅读笔者的系列文章，涵盖了技术资料归纳、编程语言与理论、Web 与大前端、服务端开发与基础架构、云计算与大数据、数据科学与人工智能、产品设计等多个领域：\n\n- 知识体系：《[Awesome Lists](https://ngte-al.gitbook.io/i/)》、《[Awesome CheatSheets](https://ngte-ac.gitbook.io/i/)》、《[Awesome Interviews](https://github.com/wx-chevalier/Awesome-Interviews)》、《[Awesome RoadMaps](https://github.com/wx-chevalier/Awesome-RoadMaps)》、《[Awesome MindMaps](https://github.com/wx-chevalier/Awesome-MindMaps)》、《[Awesome-CS-Books-Warehouse](https://github.com/wx-chevalier/Awesome-CS-Books-Warehouse)》\n\n- 编程语言：《[编程语言理论](https://ngte-pl.gitbook.io/i/)》、《[Java 实战](https://ngte-pl.gitbook.io/i/java/java)》、《[JavaScript 实战](https://ngte-pl.gitbook.io/i/javascript/javascript)》、《[Go 实战](https://ngte-pl.gitbook.io/i/go/go)》、《[Python 实战](https://ngte-pl.gitbook.io/i/python/python)》、《[Rust 实战](https://ngte-pl.gitbook.io/i/rust/rust)》\n\n- 软件工程、模式与架构：《[编程范式与设计模式](https://ngte-se.gitbook.io/i/)》、《[数据结构与算法](https://ngte-se.gitbook.io/i/)》、《[软件架构设计](https://ngte-se.gitbook.io/i/)》、《[整洁与重构](https://ngte-se.gitbook.io/i/)》、《[研发方式与工具](https://ngte-se.gitbook.io/i/)》\n\n* Web 与大前端：《[现代 Web 开发基础与工程实践](https://ngte-web.gitbook.io/i/)》、《[数据可视化](https://ngte-fe.gitbook.io/i/)》、《[iOS](https://ngte-fe.gitbook.io/i/)》、《[Android](https://ngte-fe.gitbook.io/i/)》、《[混合开发与跨端应用](https://ngte-fe.gitbook.io/i/)》\n\n* 服务端开发实践与工程架构：《[服务端基础](https://ngte-be.gitbook.io/i/)》、《[微服务与云原生](https://ngte-be.gitbook.io/i/)》、《[测试与高可用保障](https://ngte-be.gitbook.io/i/)》、《[DevOps](https://ngte-be.gitbook.io/i/)》、《[Node](https://ngte-be.gitbook.io/i/)》、《[Spring](https://ngte-be.gitbook.io/i/)》、《[信息安全与渗透测试](https://ngte-be.gitbook.io/i/)》\n\n* 分布式基础架构：《[分布式系统](https://ngte-infras.gitbook.io/i/)》、《[分布式计算](https://ngte-infras.gitbook.io/i/)》、《[数据库](https://ngte-infras.gitbook.io/i/)》、《[网络](https://ngte-infras.gitbook.io/i/)》、《[虚拟化与编排](https://ngte-infras.gitbook.io/i/)》、《[云计算与大数据](https://ngte-infras.gitbook.io/i/)》、《[Linux 与操作系统](https://ngte-infras.gitbook.io/i/)》\n\n* 数据科学，人工智能与深度学习：《[数理统计](https://ngte-aidl.gitbook.io/i/)》、《[数据分析](https://ngte-aidl.gitbook.io/i/)》、《[机器学习](https://ngte-aidl.gitbook.io/i/)》、《[深度学习](https://ngte-aidl.gitbook.io/i/)》、《[自然语言处理](https://ngte-aidl.gitbook.io/i/)》、《[工具与工程化](https://ngte-aidl.gitbook.io/i/)》、《[行业应用](https://ngte-aidl.gitbook.io/i/)》\n\n* 产品设计与用户体验：《[产品设计](https://ngte-pd.gitbook.io/i/)》、《[交互体验](https://ngte-pd.gitbook.io/i/)》、《[项目管理](https://ngte-pd.gitbook.io/i/)》\n\n* 行业应用：《[行业迷思](https://github.com/wx-chevalier/Business-Series)》、《[功能域](https://github.com/wx-chevalier/Business-Series)》、《[电子商务](https://github.com/wx-chevalier/Business-Series)》、《[智能制造](https://github.com/wx-chevalier/Business-Series)》\n\n此外，前往 [xCompass](https://wx-chevalier.github.io/home/#/search) 交互式地检索、查找需要的文章/链接/书籍/课程；或者在在 [MATRIX 文章与代码索引矩阵](https://github.com/wx-chevalier/Developer-Zero-To-Mastery)中查看文章与项目源代码等更详细的目录导航信息。最后，你也可以关注微信公众号：『**某熊的技术之路**』以获取最新资讯。\n']
