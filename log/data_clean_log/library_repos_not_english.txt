The-Golang-Standard-Library-by-Example,Golang标准库。对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案。以示例驱动的方式讲解Golang的标准库。,9091,https://github.com/polaris1119/The-Golang-Standard-Library-by-Example,master,['# 《Go语言标准库》The Golang Standard Library by Example #\r\n\r\nGolang标准库。对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案。以示例驱动的方式讲解Golang的标准库。\r\n\r\n标准库基于最新版本Go。注：目前 Go 标准库文档并没有标识某个 API 基于哪个版本的 Go，将来会加上这部分 [issue](https://github.com/golang/go/issues/5778)。\r\n\r\n讲解中涉及到特定操作系统时，针对的都是 Linux/amd64。Go 中相关系统调用在 Linux 下，对于同一个系统调用，如果有对应的 `at` 版本，使用的都是 `at` 版本，如 `open` 系统调用使用都是 `openat`。更多信息参考 [Go语言中文网博客中关于系统调用的文章](http://blog.studygolang.com)。\r\n\r\n## 交流 ##\r\n\r\n欢迎大家加入QQ群：192706294 《Go语言实现与标准库》交流群\r\n\r\nGo语言构建的 Go语言中文网：[http://studygolang.com](http://studygolang.com)\r\n\r\n关注作者公众号，加微信好友、进微信交流群。\r\n\r\n![](polarisxu-qrcode-small.jpg)\r\n\r\n## 阅读 ##\r\n\r\n为了更方便阅读，Go语言中文网搭建了阅读平台，可以更友好的在线阅读。\r\n\r\n[Go语言中文网——Go语言标准库](http://books.studygolang.com/The-Golang-Standard-Library-by-Example)\r\n\r\n## 捐赠 ##\r\n\r\n如果您觉得本书对您有帮助，通过微信或支付宝捐赠作者，金额随意！\r\n\r\n**由于无法从支付方获取支付者信息，请在支付的留言备注功能中附上 Go语言中文网账户的昵称等信息，以便我们记录！**\r\n\r\n## 目录 ##\r\n[目录](directory.md)\r\n## 贡献者 ##\r\n\r\n[hikerell](https://github.com/hikerell)\r\n\r\n## 反馈 ##\r\n\r\n由于本人能力有限，书中难免有写的不对之处，且目前所写内容没有经过校正。如果阅读过程中有任何疑问或觉得不对之处，欢迎提出，谢谢！\r\n\r\n## 版权声明 ##\r\n\r\n本书所有内容遵循 [CC-BY-SA 3.0协议（署名-相同方式共享）](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC)\r\n\r\n1. 常见误解\r\n\r\n2. 常用手法\r\n\r\n3. 如何理解，使用\r\n\r\n4. 为什么接口如此组织\r\n\r\n5. 和其它语言对比优缺点\r\n']
vjtools,The vip.com's java coding standard, libraries and tools,7437,https://github.com/vipshop/vjtools,master,['![VJTools](/docs/images/logo.jpg) [![Build Status](https://travis-ci.org/vipshop/vjtools.svg?branch=master)](https://travis-ci.org/vipshop/vjtools) \n\n\n主力于Java的唯品会，关于Java的一些小家底。 \n\n各位看官看着是好的，烦请“Star”。\n\n[1.0.8版](https://github.com/vipshop/vjtools/releases/tag/v.1.0.8) - 2018.9.24\n\n## Java Standard\n\n| Project | Description |\n| -------- | -------- |\n| [standard](https://vipshop.github.io/vjtools/#/standard/) | 唯品会Java开发手册 |\n| [code formatter](/standard/formatter) | IDE格式化模板 |\n| [sonar rule](/standard/sonar-vj) | Sonar规则定制示例 |\n\n\n## Java Core Library\n\n| Project | Description |\n| -------- | -------- |\n| [vjkit](/vjkit) | 关于文本，集合，并发等基础功能的核心类库 |\n| [vjstar](/vjstar) | 关于后端应用的性能、可用性的最佳实践 |\n\n\n## Java Tools\n\n| Project | Description | Manual |\n| -------- | -------- | -------- |\n| [vjtop](/vjtop)  | 观察JVM进程指标及其繁忙线程 | [Chinese](/vjtop/README.md)|\n| [vjmap](/vjmap)  | JMAP的分代打印版 |[Chinese](/vjmap/README.md)|\n| [vjdump](/vjdump)  | 线上紧急收集JVM数据脚本 | [Chinese](/vjdump/README.md), [English](/vjdump/README_EN.md)|\n| [vjmxcli](/vjmxcli)  | JMX 查看工具 | [Chinese](/vjmxcli/README.md)|\n\n视频：[《VJTools如何利用佛性技术玩转JVM》](http://kai.vkaijiang.com/product/course?courseID=120897)\n\n文档：[《入门科普，围绕JVM的各种外挂技术》](https://mp.weixin.qq.com/s/cwU2rLOuwock048rKBz3ew)\n\n其他直接使用的工具，见[常用工具](docs/other/othertools.md)\n\n\n## Contributing\n\nVJTools官方微信讨论群，请搜索微信号viptech128(唯技术)，添加好友后加入。\n\n所有报Bug、建议与咨询，请在[Issues](https://github.com/vipshop/vjtools/issues)发起；所有代码提交，请走[Pull Request](https://github.com/vipshop/vjtools/pulls)流程。\n\n对于优秀的代码提交和建议，唯品会将不吝发挥电商本色，给予[vip.com](https://www.vip.com)购物卡的奖励 ！！！\n\n\n## Developers\n\n唯品会团队: [江南白衣](http://calvin1978.blogcn.com), [郑德惠](https://github.com/zhengdehui), [黄云斌](https://github.com/huangyunbin), [梁耀曾](https://github.com/AJ-Liang), [林铭恺](https://github.com/acxlam), [李炫彬](https://github.com/lixuanbin) , [张晓玲](https://github.com/hjzhangxiaoling)\n\n曾经一起战斗: [杨镌颖@阿里](https://github.com/yangjuanying), 陈维治@阿里\n']
svg.js,The lightweight library for manipulating and animating SVG,10135,https://github.com/svgdotjs/svg.js,master,['# SVG.js\n\n[![Build Status](https://travis-ci.org/svgdotjs/svg.js.svg?branch=master)](https://travis-ci.org/svgdotjs/svg.js)\n[![Coverage Status](https://coveralls.io/repos/github/svgdotjs/svg.js/badge.svg?branch=master)](https://coveralls.io/github/svgdotjs/svg.js?branch=master)\n[![Cdnjs](https://img.shields.io/cdnjs/v/svg.js.svg)](https://cdnjs.com/libraries/svg.js)\n[![jsdelivr](https://badgen.net/jsdelivr/v/npm/@svgdotjs/svg.js)](https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js)\n[![Join the chat at https://gitter.im/svgdotjs/svg.js](https://badges.gitter.im/svgdotjs/svg.js.svg)](https://gitter.im/svgdotjs/svg.js?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Twitter](https://img.shields.io/badge/Twitter-@svg__js-green.svg)](https://twitter.com/svg_js)\n\n\n\n__A lightweight library for manipulating and animating SVG, without any dependencies.__\n\nSVG.js is licensed under the terms of the MIT License.\n\n## Installation\n\n#### Npm:\n\n`npm install @svgdotjs/svg.js`\n\n#### Yarn:\n\n`yarn add @svgdotjs/svg.js`\n\n#### CDNs:\n\n[https://cdnjs.com/libraries/svg.js](https://cdnjs.com/libraries/svg.js)  \n[https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js](https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js)  \n[https://unpkg.com/@svgdotjs/svg.js](https://unpkg.com/@svgdotjs/svg.js)\n\n## Documentation\nCheck [svgjs.dev](https://svgjs.dev/docs/3.0/) to learn more.\n\n[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=ulima.ums%40googlemail.com&lc=US&item_name=SVG.JS&currency_code=EUR&bn=PP-DonationsBF%3Abtn_donate_74x21.png%3ANonHostedGuest) or [![Sponsor](https://img.shields.io/badge/Sponsor-svg.js-green.svg)](https://github.com/sponsors/Fuzzyma)\n']
cellnet,High performance, simple, extensible golang open source network library,3923,https://github.com/davyxu/cellnet,master,['![cellnetlogo](doc/logo.png)\n\n [![Build Status][3]][4]  [![MIT licensed][11]][12] [![GoDoc][1]][2]\n\n[1]: https://godoc.org/github.com/davyxu/cellnet?status.svg\n[2]: https://godoc.org/github.com/davyxu/cellnet\n[3]: https://travis-ci.org/davyxu/cellnet.svg?branch=master\n[4]: https://travis-ci.org/davyxu/cellnet\n[11]: https://img.shields.io/badge/license-MIT-blue.svg\n[12]: LICENSE\n\ncellnet是一个组件化、高扩展性、高性能的开源服务器网络库\n\n# 使用领域\n\ncellnet经过多个版本的迭代，无论是作为初学者学习的范例，还是作为私用、商用项目的基础构建乃至核心技术层已经在业内广受了解及使用。\n\n主要使用领域：\n\n- 游戏服务器\n\n  方便定制私有协议，快速构建逻辑服务器、网关服务器、服务器间互联互通、对接第三方SDK、转换编码协议等\n\n- ARM设备\n\n  设备间网络通讯\n\n- 证券软件\n\n  内部RPC\n\n# 特性 (Features)\n\n## 传输协议支持\n- TCP\n\n    TCP连接器的重连，侦听器的优雅重启。\n\n- UDP\n\n    纯UDP裸包收发\n\n- HTTP(测试中)\n\n    侦听器的优雅重启, 支持json及form的收发及封装。编写游戏服务器时，不再需要使用第三方HTTP服务器对接SDK。\n\n    注: 如需要对接大规模网页, 请使用第三方专业网络库,如(https://github.com/gin-gonic/gin), cellnet的http支持主要目的在用统一的地址及peer管理\n\n- WebSocket\n\n    采用(github.com/gorilla/websocket)实现\n\n## 编码(Codec)\n\n* cellnet内建支持以下数据编码:\n    - Google Protobuf (https://github.com/google/protobuf)\n\n    - json\n        适合与第三方服务器通信\n\n    - 二进制协议(https://github.com/davyxu/goobjfmt)\n\n       内存流直接序列化, 适用于服务器内网传输\n\n    - ProtoPlus(https://github.com/davyxu/protoplus)\n\n       增加并优化过的Protobuf的编码格式\n\n    可以通过codec包自行添加新的编码格式\n\n* 支持混合编码收发\n\n    无需改动代码，只需调整消息注册方式，即可达成运行期同时收发不同编码的封包\n\n    - 与其他语言编写的服务器使用protobuf\n\n    - 与web服务器使用json通信\n    \n    - 与Unity3D(C#)使用ProtoPlus(github.com/davyxu/protoplus)协议通信\n\n    优点：\n\n    - 享受不同通信协议格式的优点，避免缺点。如Protobuf适合服务器间的传输，封包小，适应面广。\n\n    - 私有的二进制协议方便加密和客户端处理，低GC和实现复杂度。\n\n## 队列实现各种单线程/多线程，异步/同步业务处理模型\n\n  使用队列消息处理结构，方便实现以下效果：\n\n* 单线程异步逻辑，适用于MMORPG复杂交互，免加锁处理共享数据。\n\n* 多线程同步逻辑，适用于机器人逻辑，每个机器人使用独立的goroutine收发处理，机器人间互不干扰。\n\n* 多线程并发逻辑，适用于网关，消息转发，HTTP服务器，每条消息处理都会在完全并发下。\n\n## 远程过程调用（RPC）\n\n* 支持同步RPC，适用于后台服务器向其他服务器请求数据后再顺处理事务。\n\n* 支持异步RPC，适用于单线程服务器逻辑。\n\n## 消息日志\n* 可以方便的通过日志查看收发消息的每一个字段消息\n\n![cellnetlogo](doc/chatlogger.png)\n\n# 获取+编译\n\n编译和使用cellnet，请下载Go1.10以上版本\n\n```\n  go get -u -v github.com/davyxu/cellnet\n\n  go get -u -v github.com/davyxu/golog\n\n  go get -u -v github.com/davyxu/goobjfmt\n\n  go get -u -v github.com/davyxu/protoplus\n```\n\n# 第三方库\n\ncellnet 使用Protobuf时，需要使用附带的pb插件生成一个绑定代码，下面的链接可以处理这个问题\n[Google Protobuf 编码安装](https://github.com/davyxu/cellnet/blob/master/doc/pbcodec.md)\n\n[WebSocket实现](https://github.com/gorilla/websocket)\n\n# 架构\n\ncellnet架构层次由如下图所示：\n\n![architecture](doc/architecture.png)\n\ncellnet对Processor和Peer进行高度抽象，用户可以从这两个层面横向扩展以满足不同的网络封装需求\n\n红色框内的部分为cellnet实现部分\n\n# 消息处理流程\n\ncellnet的消息收发处理流程如下图所示：\n\n![procflow](doc/procflow.png)\n\n本图对应的接口为cellnet/processor.go\n\n\n# 样例\n```golang\n\nconst peerAddress = "127.0.0.1:17701"\n\n// 服务器逻辑\nfunc server() {\n\n    // 创建服务器的事件队列，所有的消息，事件都会被投入这个队列处理\n\tqueue := cellnet.NewEventQueue()\n\n    // 创建一个服务器的接受器(Acceptor)，接受客户端的连接\n\tpeerIns := peer.NewGenericPeer("tcp.Acceptor", "server", peerAddress, queue)\n\n    // 将接受器Peer与tcp.ltv的处理器绑定，并设置事件处理回调\n    // tcp.ltv处理器负责处理消息收发，使用私有的封包格式以及日志，RPC等处理\n\tproc.BindProcessorHandler(peerIns, "tcp.ltv", func(ev cellnet.Event) {\n\n        // 处理Peer收到的各种事件\n\t\tswitch msg := ev.Message().(type) {\n\t\tcase *cellnet.SessionAccepted: // 接受一个连接\n\t\t\tfmt.Println("server accepted")\n\t\tcase *TestEchoACK: // 收到连接发送的消息\n\n\t\t\tfmt.Printf("server recv %+v\\n", msg)\n\n            // 发送回应消息\n\t\t\tev.Session().Send(&TestEchoACK{\n\t\t\t\tMsg:   msg.Msg,\n\t\t\t\tValue: msg.Value,\n\t\t\t})\n\n\t\tcase *cellnet.SessionClosed: // 会话连接断开\n\t\t\tfmt.Println("session closed: ", ev.Session().ID())\n\t\t}\n\n\t})\n\n    // 启动Peer，服务器开始侦听\n\tpeerIns.Start()\n\n    // 开启事件队列，开始处理事件，此函数不阻塞\n\tqueue.StartLoop()\n}\n\n// 模拟客户端逻辑\nfunc client() {\n\n    // 例子专用的完成标记\n\tdone := make(chan struct{})\n\n    // 创建客户端的事件处理队列\n\tqueue := cellnet.NewEventQueue()\n\n    // 创建客户端的连接器\n\tpeerIns := peer.NewGenericPeer("tcp.Connector", "client", peerAddress, queue)\n\n    // 将客户端连接器Peer与tcp.ltv处理器绑定，并设置接收事件回调\n\tproc.BindProcessorHandler(peerIns, "tcp.ltv", func(ev cellnet.Event) {\n\n\t\tswitch msg := ev.Message().(type) {\n\t\tcase *cellnet.SessionConnected: // 已经连接上\n\t\t\tfmt.Println("client connected")\n\t\t\tev.Session().Send(&TestEchoACK{\n\t\t\t\tMsg:   "hello",\n\t\t\t\tValue: 1234,\n\t\t\t})\n\t\tcase *TestEchoACK: //收到服务器发送的消息\n\n\t\t\tfmt.Printf("client recv %+v\\n", msg)\n\n\t\t\t// 完成操作\n\t\t\tdone <- struct{}{}\n\n\t\tcase *cellnet.SessionClosed:\n\t\t\tfmt.Println("client closed")\n\t\t}\n\t})\n\n    // 开启客户端Peer\n\tpeerIns.Start()\n\n    // 开启客户端队列处理\n\tqueue.StartLoop()\n\n\t// 等待客户端收到消息\n\t<-done\n}\n\n```\n\n# 目录功能\n\n[目录及功能一览](https://github.com/davyxu/cellnet/blob/master/doc/dirstruct.md)\n\n# 运行聊天例子\n\n## 运行 服务器\n\n```bash\ncd examples/chat/server\n\ngo run main.go\n```\n\n## 运行 客户端\n\n```bash\ncd examples/chat/client\n\ngo run main.go\n```\n\n随后, 在命令行中输入hello后打回车, 就可以看到服务器返回\n\n```\n\nsid1 say: hello\n\n```\n\n# 基本概念及使用说明\n\n理解下面链接中的概念，可以迅速使用cellnet做基本的网络通讯及消息处理\n\n* [队列](https://github.com/davyxu/cellnet/blob/master/doc/queue.md)\n\n* [端(Peer)](https://github.com/davyxu/cellnet/blob/master/doc/peer.md)\n\n* [收发处理消息](https://github.com/davyxu/cellnet/blob/master/doc/procmsg.md)\n\n\n# 扩展及定制\n\n若cellnet内建的Peer, Codec及Processor流程不能满足你的需求，可以阅读下面链接内容，添加并扩展cellnet功能\n\n* [定制封包编码(Codec)](https://github.com/davyxu/cellnet/blob/master/doc/customcodec.md)\n\n    封包编码可以是JSON，Protobuf等\n\n* [定制端(Peer)](https://github.com/davyxu/cellnet/blob/master/doc/custompeer.md)\n\n    新增Redis连接器，与cellnet自带的TCP/UDP的Peer都不同。\n\n* [定制处理器(Processor)](https://github.com/davyxu/cellnet/blob/master/doc/customproc.md)\n\n    需要在收发包时有统一的处理行为\n\n# FAQ\n\n[常见问题及回答](https://github.com/davyxu/cellnet/blob/master/doc/faq.md)\n\n这里应该有你想知道的答案\n\n\n# 贡献者\n\n按贡献时间排序，越靠前表示越新的贡献\n\nsuperikw(https://github.com/superikw), 在v3中测试出一个websocket接口并发发送问题，wss支持，修复会话管理。\n\nbruce.hu(https://github.com/hxdhero), 在v3中测试出一个竞态冲突的bug\n\nM4tou(https://github.com/mutousay), 在v3中协助解决RPC异步超时回调处理\n\nchuan.li(https://github.com/blade-226), 在v3中提供一个没有在io线程编码的bug\n\nChris Lonng(https://github.com/lonnng), 在v3中提供一个最大封包约束造成服务器间连接断开的bug\n\nIronsDu(https://github.com/IronsDu), 在v2中大幅度性能优化\n\nviwii(viwii@sina.cn), 在v2中，提供一个可能造成死锁的bug\n\n# 版本历史\n2018.5  v4版本 [详细请查看](https://github.com/davyxu/cellnet/blob/v4/CHANGES.md)\n\n2017.8  v3版本 [详细请查看](https://github.com/davyxu/cellnet/blob/v3/CHANGES.md)\n\n2017.1  v2版本 [详细请查看](https://github.com/davyxu/cellnet/blob/v2/CHANGES.md)\n\n2015.8\tv1版本\n\n\n# 备注\n\n感觉不错请star, 谢谢!\n\n知乎: http://www.zhihu.com/people/sunicdavy\n\n提交bug及特性: https://github.com/davyxu/cellnet/issues\n']
F2,📱📈An elegant, interactive and flexible charting library for mobile.,7790,https://github.com/antvis/F2,master,['![](https://user-images.githubusercontent.com/6628666/44565744-476f1880-a79c-11e8-802b-2477493162c7.png)\n\n[![](https://img.shields.io/travis/antvis/f2.svg)](https://travis-ci.org/antvis/f2) ![](https://img.shields.io/badge/language-javascript-red.svg) ![](https://img.shields.io/badge/license-MIT-000000.svg) [![npm package](https://img.shields.io/npm/v/@antv/f2.svg)](https://www.npmjs.com/package/@antv/f2) [![NPM downloads](http://img.shields.io/npm/dm/@antv/f2.svg)](https://npmjs.org/package/@antv/f2) [![Percentage of issues still open](http://isitmaintained.com/badge/open/antvis/f2.svg)](http://isitmaintained.com/project/antvis/f2 \'Percentage of issues still open\')\n\nF2，一个专注于移动，开箱即用的可视化解决方案，完美支持 H5 环境同时兼容多种环境（node, 小程序，weex）。完备的图形语法理论，满足你的各种可视化需求。专业的移动设计指引为你带来最佳的移动端图表体验。[英文 README](./README.en-US.md)\n\n<p align="left"><img src="https://user-images.githubusercontent.com/6628666/44565820-c2d0ca00-a79c-11e8-93d8-6608d3e112ef.png" width="600" /></p>\n\n> 在此衷心感谢[《The Grammar of Graphics》](https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html)的作者 [Leland Wilkinson](https://en.wikipedia.org/wiki/Leland_Wilkinson)，为 F2 的图形语法提供了理论基础！\n\n## 安装\n\n```bash\n$ npm install @antv/f2\n```\n\n## 特性\n\n### 专注移动，体验优雅\n\n- **轻量化呈现，自然反馈**：在设计上我们以人为本，追求自然简单易懂，有吸引力的表达效果，让用户在碎片化的时间里更快更高效得获取图表信息。同时在可视化的操作我们追求内容和操作有机融合，符合人的自然行为反应，让交互操作更自然。\n\n  <p align="left"><img src="https://user-images.githubusercontent.com/6628666/44565525-21954400-a79b-11e8-8d69-cd95fa6b9a99.gif" width="600"></p>\n  <p align="left"><img src="https://user-images.githubusercontent.com/6628666/44566001-b436e280-a79d-11e8-869d-cbbffb0a3a30.gif" width="600" ></p>\n\n- **轻巧流畅**：F2 一直致力于追求极致的性能，针对移动设备做了大量的优化，在支持丰富（50+）图表的基础上同时保持代码量的小巧（不带交互版本 gzip 压缩后 44k，带所有交互版本 56k），同时提供模块化的设计以支持动态加载，提供更优的大小。\n\n- **多端异构**：在完美支持 H5 环境的同时，同时兼容 [Node.js](https://f2.antv.vision/zh/docs/tutorial/manual/node-env)，[支付宝小程序](https://github.com/antvis/my-f2)、[微信小程序](https://github.com/antvis/wx-f2)、[React Native](https://github.com/chenshuai2144/f2-demo)以及 [Weex 端](https://github.com/weex-plugins/weex-chart)的渲染，一份代码，多设备多环境渲染。\n  <p align="center"><img src="https://gw.alipayobjects.com/zos/rmsportal/cPUduuYgROeJwRJSRuFK.png"></p>\n\n### 图表丰富，组件完备\n\n与传统的图表库不同，抛弃了特图特做的封装思路，基于强大的图形语法理论，以数据驱动，通过图形语法的组合灵活构建各类图表，目前可绘制 50+ 图表类型（当然，还可以更多），覆盖各类场景在提供基础的图表可视化能力外，我们还提供了丰富图表功能组件，满足各种功能需求。\n\n<p align="center"><img src="https://user-images.githubusercontent.com/6628666/44565498-f4e12c80-a79a-11e8-98fc-73ee58547dc9.png" /></p>\n\n### 扩展灵活，创意无限\n\n我们在提供最佳实践的同时，还为开发者提供了灵活的扩展机制，包括 Shape、动画以及交互的自定义能力，当然还有图表样式的个性化定制，满足各种个性化的图表要求。\n\n<img src="https://user-images.githubusercontent.com/6628666/44565579-6c16c080-a79b-11e8-9494-86f3ad477341.gif" width="200"><img src="https://user-images.githubusercontent.com/6628666/44565581-6c16c080-a79b-11e8-8210-f4e797480e87.gif" width="200"><img src="https://user-images.githubusercontent.com/6628666/44565580-6c16c080-a79b-11e8-956d-4d15455468a3.gif" width="200"><img src="https://user-images.githubusercontent.com/6628666/44565583-6caf5700-a79b-11e8-8e9e-a1fa12ddcbf1.gif" width="200">\n\n## 文档\n\n- [使用教程](https://f2.antv.vision/zh/docs/tutorial/getting-started)\n- [API](https://f2.antv.vision/zh/docs/api)\n- [图表示例](https://f2.antv.vision/zh/examples)\n\n## 快速开始\n\n<img src="https://gw.alipayobjects.com/zos/finxbff/compress-tinypng/54ad3af8-c30d-43ca-b0e8-e21c4ea3d438.png" width="375">\n\n```html\n<canvas id="mountNode"></canvas>\n```\n\n```jsx\n// F2 对数据源格式的要求，仅仅是 JSON 数组，数组的每个元素是一个标准 JSON 对象。\nconst data = [\n  { genre: \'Sports\', sold: 275 },\n  { genre: \'Strategy\', sold: 115 },\n  { genre: \'Action\', sold: 120 },\n  { genre: \'Shooter\', sold: 350 },\n  { genre: \'Other\', sold: 150 },\n];\n\n// 获取 canvas context\nconst context = document.getElementById(\'mountNode\').getContext(\'2d\');\nconst { props } = (\n  <Canvas context={context} pixelRatio={window.devicePixelRatio}>\n    <Chart data={data}>\n      <Axis field="genre" />\n      <Axis field="sold" />\n      <Interval x="genre" y="sold" color="genre" />\n      <Tooltip />\n    </Chart>\n  </Canvas>\n);\n\nconst canvas = new Canvas(props);\ncanvas.render();\n```\n\n更多示例：[demos](https://f2.antv.vision/zh/examples)。\n\n**手机扫码观看 demos**\n\n<img src="https://gw.alipayobjects.com/zos/rmsportal/nzlxIzUBlBRVGMyaZigG.png" style="width:150px;">\n\n## 本地开发\n\n```bash\n$ npm install\n\n# 先初始化 monorepo\n$ npm run bootstrap\n\n# 再跑测试用例\n$ npm run test\n\n# 监听文件变化构建，并打开 demo 页面\n$ npm run dev\n\n# 打开某一个具体的测试用例\n$ npm run test-watch -- \'TestFileName\'\n```\n\n## 如何贡献\n\n如果您在使用的过程中碰到问题，可以先通过 [issues](https://github.com/antvis/f2/issues) 看看有没有类似的 bug 或者建议。\n\n如需提交代码，请遵从我们的[贡献指南](https://github.com/antvis/f2/blob/master/CONTRIBUTING.md)。\n\n## 体验改进计划说明\n\nF2 从 3.1.12（2018-06-20 发布）版本开始添加了`F2.track（true）`方法。 目前我们的体验改进计划已经完成，所以从 3.3.4 版本开始该方法将从 F2 中删除。 如果它给你带来麻烦，我们深表歉意。\n\n## License\n\n[MIT license](./LICENSE).\n']
weui-wxss,A UI library by WeChat official design team, includes the most useful widgets/modules.,14588,https://github.com/Tencent/weui-wxss,master,['WeUI for 小程序 为微信小程序量身设计\n=====\n\n[![npm version](https://img.shields.io/npm/v/weui-wxss.svg)](https://www.npmjs.org/package/weui-wxss)\n[![Gitter](https://badges.gitter.im/weui/weui.svg)](https://gitter.im/weui/weui?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\n## 概述\n\n[WeUI](https://github.com/weui/weui) 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含`button`、`cell`、`dialog`、 `progress`、 `toast`、`article`、`actionsheet`、`icon`等各式元素。\n\n以下内容是纯UI库，如果想使用逻辑封装版本，请看[小程序组件库 - WeUI](https://developers.weixin.qq.com/miniprogram/dev/extended/weui/)\n\n\n## 使用\n\n- 样式文件可直接引用`dist/style/weui.wxss`，或者单独引用`dist/style/widget`下的组件的`wxss`\n- 组件的wxml结构请看`dist/example/`下的组件\n\n### rpx版本\n默认版本使用的是`px`。这里也提供`rpx`版本，文件在[`dist-rpx-mode`](https://github.com/Tencent/weui-wxss/tree/master/dist-rpx-mode)目录下。\n\n\n## WeUI 黑暗模式\n在根结点增加属性 `data-weui-theme="dark"`\n如:\n```html\n<view data-weui-theme="dark">\n    ...\n</view>\n```\n\n## 预览\n用[微信web开发者工具](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html)打开`dist`目录（**请注意，是`dist`目录，不是整个项目**）\n\n<img src=\'https://cloud.githubusercontent.com/assets/2395166/20168869/48a75b02-a75f-11e6-89aa-503d65c8ad8e.png\' width=\'344\' alt=\'preview\' />\n\n![WeUI for 小程序](https://user-images.githubusercontent.com/2395166/29502325-ada080f6-8661-11e7-94c2-23d638210f45.jpg)\n\n\n## 文档\n\nWeUI 视觉标准参考 [weui-design](https://github.com/weui/weui-design)\n\n\n## License\nThe MIT License(http://opensource.org/licenses/MIT)\n\n请自由地享受和参与开源\n\n\n## 贡献\n\n如果你有好的意见或建议，欢迎给我们提issue或pull request。\n']
awesome-ios-animation,A curated list of awesome iOS animation, including Objective-C and Swift libraries,5094,https://github.com/ameizi/awesome-ios-animation,master,['# awesome-ios-animation\n\nA curated list of awesome iOS animation, including Objective-C and Swift libraries\n\n> 收集整理了下iOS平台下比较主流炫酷的几款动画框架。\n\n> 排名先后顺序按个人喜好，不代表大众意愿。望见谅！\n\n> 该列表不定期更新！\n\nhttps://github.com/facebook/pop\n\n![pop](https://github.com/facebook/pop/blob/master/Images/pop.gif?raw=true)\n\nhttps://github.com/schneiderandre/popping\n\n![popping](https://d2ffutrenqvap3.cloudfront.net/items/2l3M18193q311E3o353W/popping.gif)\n\nhttps://github.com/MengTo/Spring\n\n![](http://cl.ly/image/3a1r1d3l3D1j/spring-logo.jpg)\n\n![](http://cl.ly/image/241o0G1G3S36/download/springsetup.jpg)\n\n![](http://cl.ly/image/1n1E2j3W3y24/springscreen.jpg)\n\nhttps://github.com/AladinWay/TransitionButton\n\n![](https://cdn.dribbble.com/users/62319/screenshots/1945593/shot.gif)\n\nhttps://github.com/jwilling/JNWSpringAnimation\n\n![](http://jwilling.com/serve/github/jnwspringanimation/preview.gif)\n\nhttps://github.com/daltoniam/DCAnimationKit\n\n Tada\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/tada.gif)\n\n Bounce\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/bounce.gif)\n\n Pulse\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/pulse.gif)\n\n Shake\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/shake.gif)\n\n Swing\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/swing.gif)\n\n Snap\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/snapin.gif)\n\n Bounce\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/bouncein.gif)\n\n Expand\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/expandin.gif)\n\n Compress\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/compressin.gif)\n\n Hinge\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/hinge.gif)\n\n Drop\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/drop.gif)\n\n Move\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/slide.gif)\n\n Rotation\n![alt tag](https://raw.github.com/daltoniam/DCAnimationKit/master/gifs/rotate.gif)\n\nhttps://github.com/robb/RBBAnimation\n\n![](http://robb.is/img/rbbanimation/rainbow.gif)\n![](http://robb.is/img/rbbanimation/spring.gif)\n![](http://robb.is/img/rbbanimation/ease-in-out-back.gif)\n![](http://robb.is/img/rbbanimation/bounce.gif)\n![](http://robb.is/img/rbbanimation/sine-wave.gif)\n\nhttps://github.com/matthewcheok/POP-MCAnimate\n\nhttps://github.com/jhurray/JHChainableAnimations\n\n![](https://github.com/jhurray/JHChainableAnimations/raw/master/img/logo.png)\n![](https://raw.githubusercontent.com/jhurray/JHChainableAnimations/master/img/JHChainableAnimationsExample1.png)\n![](https://raw.githubusercontent.com/jhurray/JHChainableAnimations/master/Gifs/JHChainableAnimationsExample1.gif)\n![](https://github.com/jhurray/JHChainableAnimations/raw/master/img/JHChainableAnimationsExample2.png)\n![](https://github.com/jhurray/JHChainableAnimations/raw/master/Gifs/JHChainableAnimationsExample2.gif)\n![](https://github.com/jhurray/JHChainableAnimations/raw/master/img/JHChainableAnimationsExample3.png)\n![](https://github.com/jhurray/JHChainableAnimations/raw/master/Gifs/JHChainableAnimationsExample3.gif)\n\nhttps://github.com/poetmountain/PMTween\n\nhttps://github.com/IFTTT/JazzHands\n\n![Jazz Hands](https://raw.github.com/IFTTT/JazzHands/screenshots/screenshots/intro.gif)\n\n https://github.com/shu223/AnimatedTransitionGallery\n\n![](https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/gallery.gif)\n![](https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/coreimage.gif)\n![](https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/motionblur.gif)\n![](https://raw.githubusercontent.com/shu223/AnimatedTransitionGallery/master/gif/boxblur.gif)\n\nhttps://github.com/Raizlabs/RZTransitions\n\n![](https://raw.githubusercontent.com/Raizlabs/RZTransitions/master/Web/RZTransitions.png)\n![](http://raw.github.com/Raizlabs/RZTransitions/master/Web/RZTransitionsDemo.gif)\n\nhttps://github.com/Yalantis/FoldingTabBar.iOS\n\n![Preview](https://d13yacurqjgara.cloudfront.net/users/495792/screenshots/2003376/tab_bar_animation_fin-02.gif)\n\nhttps://github.com/Yalantis/Side-Menu.iOS\n\n![](https://d13yacurqjgara.cloudfront.net/users/125056/screenshots/1689922/events-menu_1-1-6.gif)\n\nhttps://github.com/Yalantis/Context-Menu.iOS\n\n![ContextMenu](https://d13yacurqjgara.cloudfront.net/users/125056/screenshots/1785274/99miles-profile-light_1-1-4.gif)\n\nhttps://github.com/Yalantis/GuillotineMenu\n\n![Preview](https://d13yacurqjgara.cloudfront.net/users/495792/screenshots/2018249/draft_06.gif)\n\nhttps://github.com/Yalantis/Persei\n\n![Preview](https://raw.githubusercontent.com/Yalantis/Persei/master/Assets/animation.gif)\n\nhttps://github.com/Yalantis/Pull-to-Refresh.Rentals-iOS\n\n![](https://d13yacurqjgara.cloudfront.net/users/125056/screenshots/1650317/realestate-pull_1-2-3.gif)\n\nhttps://github.com/Yalantis/PullToMakeSoup\n\n![](https://raw.githubusercontent.com/Yalantis/PullToMakeSoup/master/PullToMakeSoupDemo/Resouces/recipe-finder.gif)\n\nhttps://github.com/Yalantis/PullToMakeFlight\n\n![](https://raw.githubusercontent.com/Yalantis/PullToMakeFlight/master/PullToMakeFlightDemo/Resources/tours-pull-airplane.gif)\n\nhttps://github.com/Yalantis/Koloda\n\n![Preview](https://github.com/Yalantis/Koloda/blob/master/Koloda_v2_example_animation.gif)\n![Preview](https://github.com/Yalantis/Koloda/blob/master/Koloda_v1_example_animation.gif)\n\nhttps://github.com/Yalantis/StarWars.iOS\n\n![](https://yalantis-com.s3.amazonaws.com/uploads/ckeditor/pictures/49/content_star_wars-shot__1_.gif)\n\nhttps://github.com/Yalantis/EatFit\n\n![Preview](https://yalantis.com/media/content/ckeditor/2015/09/30/charts-animation.gif)\n\nhttps://github.com/Yalantis/Preloader.Ophiuchus\n\n![Yalantis](https://raw.githubusercontent.com/Yalantis/Ophiuchus/master/Example/Ophiuchus/Resources/yalantistwodirections.gif)\n![Preview](https://raw.githubusercontent.com/Yalantis/Ophiuchus/master/Example/Ophiuchus/Resources/animation.gif)\n![The Green Horse](https://raw.githubusercontent.com/Yalantis/Ophiuchus/master/Example/Ophiuchus/Resources/thegreenhorse.gif)\n\nhttps://github.com/Ramotion/animated-tab-bar\n\n![](https://raw.githubusercontent.com/Ramotion/animated-tab-bar/master/Screenshots/tab-bar-icons-iphone-ramotion-animation-interface-design.gif)\n\nhttps://github.com/andreamazz/BubbleTransition\n\n![](https://raw.githubusercontent.com/andreamazz/BubbleTransition/master/assets/logo.png)\n![BubbleTransition](https://raw.githubusercontent.com/andreamazz/BubbleTransition/master/assets/screenshot.gif)\n\nhttps://github.com/fitomad/iOS-Bubble-Transition\n\n![Bubble Transition](https://github.com/fitomad/iOS-Bubble-Transition/blob/master/Bubble.gif?raw=true)\n\nhttps://github.com/carsonperrotti/CNPPopupController\n\n![](https://raw.githubusercontent.com/carsonperrotti/CNPPopupController/master/CNPPopupControllerExample/CNPPopupController.gif)\n\nhttps://github.com/MartinRGB/GiftCard-Implementation\n\n![origami](https://github.com/MartinRGB/GiftCard-Implementation/blob/master/Gif/Origami.gif?raw=true)\n![xcode](https://github.com/MartinRGB/GiftCard-Implementation/blob/master/Gif/Xcode.gif?raw=true)\n\nhttps://github.com/Draveness/DKChainableAnimationKit\n\n![](https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/DKChainableAnimationKit.jpg)\n![](https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Code1.png)\n![](https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Demo1.gif)\n![](https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Code2.png)\n![](https://raw.githubusercontent.com/Draveness/DKChainableAnimationKit/master/Gifs/Demo2.gif)\n\nhttps://github.com/cwRichardKim/TinderSimpleSwipeCards\n\n![alt tag](http://imgur.com/4bYw12e.gif)\n![alt tag](http://i.imgur.com/krDNpR0.gif)\n![alt tag](http://i.imgur.com/W4bIRkc.gif)\n![alt tag](http://i.imgur.com/3yk6aiS.gif)\n![alt tag](http://i.imgur.com/IIFVkm4.gif)\n![alt tag](http://i.imgur.com/j1ISIq5.gif)\n![alt tag](http://i.imgur.com/PQYs4sH.gif)\n\nhttps://github.com/jonathantribouharet/JTMaterialTransition\n\n![](https://raw.githubusercontent.com/jonathantribouharet/JTMaterialTransition/master/Screens/example.gif)\n\nhttps://github.com/kongtomorrow/WatchTransition\n\n![Screenshot](https://github.com/kongtomorrow/WatchTransition/raw/master/WatchFaceTransition.gif)\n\nhttps://github.com/KittenYang/KYPushTransition\n\n![](https://raw.githubusercontent.com/KittenYang/KYPushTransition/master/demo.gif)\n\nhttps://github.com/andreamazz/UIView-Shake\n\n![](https://raw.githubusercontent.com/andreamazz/UIView-Shake/master/assets/logo.png)\n![UIView+Shake](https://raw.githubusercontent.com/andreamazz/UIView-Shake/master/assets/screenshot.gif)\n\nhttps://github.com/andreamazz/UITextField-Shake\n\n![](https://raw.githubusercontent.com/andreamazz/UITextField-Shake/master/assets/logo.png)\n![UITextField+Shake](https://raw.githubusercontent.com/andreamazz/UITextField-Shake/master/assets/screenshot.gif)\n\nhttps://github.com/recruit-mp/RMPZoomTransitionAnimator\n\n![Screen shot](https://raw.githubusercontent.com/recruit-mp/RMPZoomTransitionAnimator/master/docs/collectionview.gif)\n![Screen shot](https://raw.githubusercontent.com/recruit-mp/RMPZoomTransitionAnimator/master/docs/tableview.gif)\n\nhttps://github.com/xhzengAIB/PopMenu\n\n![image](https://github.com/xhzengAIB/LearnEnglish/raw/master/Screenshots/XHSinaMenuViewExample.gif)\n\nhttps://github.com/zoonooz/ZFDragableModalTransition\n\n![](https://raw.githubusercontent.com/zoonooz/ZFDragableModalTransition/master/Screenshot/ss.gif)\n\nhttps://github.com/mathcarignani/MCMHeaderAnimated\n\n![](https://raw.githubusercontent.com/mathcarignani/MCMHeaderAnimated/master/demo.gif)\n\nhttps://github.com/Produkt/RubberBandEffect\n\n![rubber-band01](https://raw.githubusercontent.com/Produkt/RubberBandEffect/master/Others/RubberBand_01.gif) \n\n![rubber-band02](https://raw.githubusercontent.com/Produkt/RubberBandEffect/master/Others/RubberBand_02.gif)\n\nhttps://github.com/icanzilb/EasyAnimation\n\n![](https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/EA.png)\n![](https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/moveX.gif)\n![](https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/corners.gif)\n![](https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/spring.gif)\n![](https://raw.githubusercontent.com/icanzilb/EasyAnimation/master/etc/chain.gif)\n\nhttps://github.com/adad184/MMTweenAnimation\n\n![](https://raw.githubusercontent.com/adad184/MMTweenAnimation/master/Images/demo.gif)\n\nhttps://github.com/andreamazz/GearRefreshControl\n\n![](https://raw.githubusercontent.com/andreamazz/GearRefreshControl/master/assets/screenshot.gif)\n\nhttps://github.com/LiorNn/DragDropCollectionView\n\n![](https://raw.githubusercontent.com/LiorNn/DragDropCollectionView/master/demo.gif)\n\nhttps://github.com/rounak/TwitterBirdAnimation\n\n![twitter bird animation](http://media.tumblr.com/10cc0ba92377a2cba9fb35c9943fd2ca/tumblr_inline_n6zpokNxpC1qh9cw7.gif)\n\nhttps://github.com/haaakon/SingleLineShakeAnimation\n\n![](https://raw.githubusercontent.com/haaakon/SingleLineShakeAnimation/master/example.gif)\n\nhttps://github.com/zipme/RQShineLabel\n\n![image](https://raw.githubusercontent.com/zipme/RQShineLabel/master/Screenshots/rqshinelabel.gif)\n\nhttps://github.com/lexrus/LTMorphingLabel\n\n![](https://cloud.githubusercontent.com/assets/219689/3491822/96bf5de6-059d-11e4-9826-a6f82025d1af.gif)\n![](https://cloud.githubusercontent.com/assets/219689/3491838/ffc5aff2-059d-11e4-970c-6e2d7664785a.gif)\n![](https://cloud.githubusercontent.com/assets/219689/3491840/173c2238-059e-11e4-9b33-dcd21edae9e2.gif)\n![](https://cloud.githubusercontent.com/assets/219689/3491845/29bb0f8c-059e-11e4-9ef8-de56bec1baba.gif)\n![](https://cloud.githubusercontent.com/assets/219689/3508789/31e9fafe-0690-11e4-9a76-ba3ef45eb53a.gif)\n![](https://cloud.githubusercontent.com/assets/219689/3582586/4fb8c52e-0bfe-11e4-9b6f-f070f7f3ab55.gif)\n![](https://cloud.githubusercontent.com/assets/219689/3594949/815cd3e8-0caa-11e4-9738-278a9c959478.gif)\n\nhttps://github.com/wongzigii/WZDraggableSwitchHeaderView\n\n![](https://raw.githubusercontent.com/wongzigii/WZDraggableSwitchHeaderView/master/GIF/WZAnimatingTransition.gif)\n\nhttps://github.com/zhxnlai/ZLSwipeableViewSwift\n\n![direction](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/animation.gif)\n\n![direction](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/swipe.gif)\n\n![direction](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/direction.gif)\n\n![direction](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableViewSwift/master/Previews/undo.gif)\n\nhttps://github.com/zhxnlai/ZLSwipeableView/\n\n![swipe](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipe.gif)\n\n![cancel](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipeCancel.gif)\n\n![swipeLeft](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipeLeft.gif)\n\n![swipeLeftRight](https://raw.githubusercontent.com/zhxnlai/ZLSwipeableView/master/Previews/swipeLeftRight.gif)\n\nhttps://github.com/CezaryKopacz/CKWaveCollectionViewTransition\n\n![anim.gif](http://i.giphy.com/3o85xyoYepG177Bhte.gif)\n\nhttps://github.com/yoavlt/LiquidFloatingActionButton\n\n![anim.gif](https://raw.githubusercontent.com/yoavlt/LiquidFloatingActionButton/master/Demo/top.gif)\n![anim.gif](https://raw.githubusercontent.com/yoavlt/LiquidFloatingActionButton/master/Demo/customizable.gif)\n\nhttps://github.com/ninjaprox/NVActivityIndicatorView\n\n![anim.gif](https://raw.githubusercontent.com/ninjaprox/NVActivityIndicatorView/master/Demo.gif)\n\nhttps://github.com/entotsu/TKSubmitTransition\n\n![Demo GIF Animation](https://github.com/entotsu/TKSubmitTransition/blob/master/demo.gif)\n\nhttp://download.jikexueyuan.com/detail/id/1301\n\n![Demo GIF Animation](http://download.jikexueyuan.com/File/image/e224fc4d0c362305fa498b371cfac4c9_318513_189_4c21143928442461801bae5ac596c.gif)\n\nhttps://github.com/KittenYang/Animations\n\n![Demo GIF Animation](https://raw.githubusercontent.com/KittenYang/Animations/master/GooeySlideMenu.gif)\n\nhttps://github.com/likedan/KDIntroView\n\n![Demo GIF Animation](https://raw.githubusercontent.com/likedan/KDIntroView/master/Imgs/showup.gif)\n\nhttps://github.com/IFTTT/RazzleDazzle\n\n![Demo GIF Animation](https://raw.githubusercontent.com/IFTTT/RazzleDazzle/master/Example/Docs/razzledazzle-demo.gif)\n\nhttps://github.com/hyperoslo/Presentation\n\n![Demo GIF Animation](https://raw.githubusercontent.com/hyperoslo/Presentation/master/Example/Parallax/Images/Parallax-v2.gif)\n\nhttps://github.com/nshintio/uicollectionview-reordering\n\n![Demo GIF Animation](https://camo.githubusercontent.com/ee5e5999dea79c81a09416a51b1e6cec5de3a193/687474703a2f2f6e7368696e742e696f2f696d616765732f7569636f6c6c656374696f6e766965772d72656f72646572696e672f342e676966)\n\nhttps://github.com/chinsyo/uber-video-welcome\n\n![Demo GIF Animation](https://raw.githubusercontent.com/chinsyo/uber-video-welcome/master/uber-video-welcome.gif)\n\nhttps://github.com/yoavlt/LiquidLoader\n\nGrowCircle\n\n![GrowCircle](https://github.com/yoavlt/LiquidLoader/blob/master/Demo/grow-circle.gif?raw=true)\n\nGrowLine\n\n![GrowLine](https://github.com/yoavlt/LiquidLoader/blob/master/Demo/grow-line.gif?raw=true)\n\nhttps://github.com/gontovnik/DGElasticPullToRefresh\n\n![](https://raw.githubusercontent.com/gontovnik/DGElasticPullToRefresh/master/DGElasticPullToRefreshPreview1.gif)\n![](https://raw.githubusercontent.com/gontovnik/DGElasticPullToRefresh/master/DGElasticPullToRefreshPreview2.gif)\n\nhttps://github.com/seedante/CardAnimation\n\n![Design from Dribble](https://d13yacurqjgara.cloudfront.net/users/32399/screenshots/1265487/attachments/173545/secret-project-animation_2x.gif)\n\nhttps://github.com/AlexCatch/ACAnimatedTextField\n\n![Preview](https://raw.githubusercontent.com/AlexCatch/ACAnimatedTextField/master/misc/preview.gif)\n\nhttps://github.com/ephread/Instructions\n\n![Instructions Demo](http://i.imgur.com/JUlQH9F.gif)\n\nhttps://github.com/mentionapp/mntpulltoreact\n\n![Preview](https://raw.githubusercontent.com/mentionapp/mntpulltoreact/master/README/mention-example.gif)\n\nhttps://github.com/TBXark/TKRubberIndicator\n\n![Preview](https://raw.githubusercontent.com/TBXark/TKRubberIndicator/master/Example/demo.gif)\n\nhttps://github.com/12207480/TYAlertController\n\n![image](https://raw.githubusercontent.com/12207480/TYAlertController/master/screenshot/TYAlertControllerDemo.gif)\n\nhttps://github.com/yeziahehe/YFStartView\n\n![GIFImage](http://7xkvt5.com1.z0.glb.clouddn.com/github/YFStartViewbuttom.gif)\n![GIFImage](http://7xkvt5.com1.z0.glb.clouddn.com/github/YFStartViewcenter.gif)\n\nhttps://github.com/zekunyan/TTGEmojiRate\n\n![Screenshot](http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_screenshot2.gif)\n![Screenshot](http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_IBExample.png)\n\nhttps://github.com/PhilippeBoisney/AlertOnboarding\n\n![Screenshot](https://github.com/PhilippeBoisney/AlertOnboarding/blob/master/screenshot.png)\n\nhttps://github.com/hanton/HTYTextField\n\n![image](https://github.com/hanton/HTYTextField/blob/master/screenshot/HTYTextField.gif)\n\nhttps://github.com/manuelescrig/MEVHorizontalContacts\n\n![MEVHorizontalContacts](https://cloud.githubusercontent.com/assets/1849990/15137846/645a0d18-168c-11e6-96e2-651d8f8de3b0.gif)\n\nhttps://github.com/Ramotion/preview-transition\n\n![PreviewTransition](https://github.com/Ramotion/preview-transition/blob/master/preview.gif)\n\nhttps://github.com/Ramotion/expanding-collection\n\n![PreviewTransition](https://github.com/Ramotion/expanding-collection/blob/master/preview.gif)\n\nhttps://github.com/Ramotion/folding-cell\n\n![](https://raw.githubusercontent.com/Ramotion/folding-cell/master/Screenshots/folding-cell.gif)\n\nhttps://github.com/daltonclaybrook/tween-controller\n\n![image](https://raw.githubusercontent.com/daltonclaybrook/tween-controller/master/example.gif)\n\nhttps://github.com/manuelescrig/MEVFloatingButton\n\n![MEVFloatingButton](https://cloud.githubusercontent.com/assets/1849990/13462466/db001be6-e087-11e5-92a1-79c8ecefb715.gif)\n\nhttps://github.com/xhamr/fave-button\n\n![FaveButton](https://raw.githubusercontent.com/xhamr/fave-button/master/fave-button1.gif)\n\nhttps://github.com/WelkinXie/WXWaveView\n\n![WXWaveView](http://welkin-xie.oss-cn-shenzhen.aliyuncs.com/github/wave.gif)\n \nhttps://github.com/BohdanOrlov/BouncyPageViewController\n\n![BouncyPageViewController](https://raw.githubusercontent.com/BohdanOrlov/BouncyPageViewController/master/GIFs/dribble.gif)\n\n![BouncyPageViewController](https://raw.githubusercontent.com/BohdanOrlov/BouncyPageViewController/master/GIFs/bouncyDemo.gif)\n\nhttps://github.com/orazz/CreditCardForm-iOS\n\n![CreditCardForm-iOS](https://raw.githubusercontent.com/orazz/CreditCardForm-iOS/master/Example/Screens/CreditCardDemo.gif)\n\nhttps://github.com/Onix-Systems/RainyRefreshControl\n\n![RainyRefreshControl](https://raw.githubusercontent.com/Onix-Systems/RainyRefreshControl/master/gif/umbrella_refresh.gif)\n\nhttps://github.com/younatics/YNDropDownMenu\n\n![](https://raw.githubusercontent.com/younatics/YNDropDownMenu/master/Images/YNDropDownMenu.gif)\n![](https://raw.githubusercontent.com/younatics/YNDropDownMenu/master/Images/YNDropDownMenu2.gif)\n\nhttps://github.com/marcosgriselli/ViewAnimator\n\n![entireView](https://cdn.rawgit.com/marcosgriselli/ViewAnimator/cf065e96/Resources/entireView.svg)\n![horizontal](https://cdn.rawgit.com/marcosgriselli/ViewAnimator/cf065e96/Resources/horizontal.svg)\n![vertical](https://cdn.rawgit.com/marcosgriselli/ViewAnimator/cf065e96/Resources/vertical.svg)\n![collection](https://cdn.rawgit.com/marcosgriselli/ViewAnimator/cf065e96/Resources/collection.svg)\n![collectionX](https://cdn.rawgit.com/marcosgriselli/ViewAnimator/cf065e96/Resources/collectionX.svg)\n![](https://cdn.dribbble.com/users/702789/screenshots/3816087/preview-messaki.gif)\n\nhttps://github.com/sunjinshuai/Keep\n\n![效果图](https://github.com/sunjinshuai/Keep/blob/master/Keep.gif)\n\nhttps://github.com/loopeer/AlertTransition\n\n![效果图](https://raw.githubusercontent.com/loopeer/AlertTransition/master/Media/EasyTransition.gif)\n![效果图](https://raw.githubusercontent.com/loopeer/AlertTransition/master/Media/BackgroundType.gif)\n![效果图](https://raw.githubusercontent.com/loopeer/AlertTransition/master/Media/changeOrientation.gif)\n![效果图](https://raw.githubusercontent.com/loopeer/AlertTransition/master/Media/MenuTransition.gif)\n![效果图](https://raw.githubusercontent.com/loopeer/AlertTransition/master/Media/TrolleyTransition.gif)\n![效果图](https://raw.githubusercontent.com/loopeer/AlertTransition/master/Media/BubbleTransition.gif)\n![效果图](https://raw.githubusercontent.com/loopeer/AlertTransition/master/Media/StarWarsTransition.gif)\n\nhttps://github.com/CosmicMind/Material\n\nhttps://github.com/CosmicMind/Motion\n\nhttps://github.com/hachinobu/SamuraiTransition\n\n![samuraitransitiondemo](https://cloud.githubusercontent.com/assets/1317847/22860410/512cbee0-f140-11e6-9485-97c6907afa05.gif)\n\nhttps://github.com/eggswift/ESTabBarController\n\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomSelectStyleGif.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomSelectAnimateGif.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomBackgroundGif.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomHighlightGif.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomImpliesGif.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomStyle2.png)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomStyle3.png)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/SystemNotificationStyle.png)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomNotificationStyle.png)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomNofticationGif.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomNofticationGif2.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/CustomNofticationGif3.gif)\n![](https://raw.githubusercontent.com/eggswift/ESTabBarController/master/Resources/LottieGif.gif)\n\nhttps://github.com/quickbirdstudios/FlippingNotch\n\n![alt text](https://cdn.dribbble.com/users/793057/screenshots/4089014/iphone-x-pull-to-refresh.gif)\n\nhttps://github.com/Daltron/NotificationBanner\n\n![](https://raw.githubusercontent.com/Daltron/NotificationBanner/master/NotificationBanner/Assets/basic.gif)\n![](https://raw.githubusercontent.com/Daltron/NotificationBanner/master/NotificationBanner/Assets/side_views.gif)\n![](https://raw.githubusercontent.com/Daltron/NotificationBanner/master/NotificationBanner/Assets/status_bar.gif)\n\nhttps://github.com/Ramotion/fluid-slider\n\n![](https://raw.githubusercontent.com/Ramotion/fluid-slider/master/preview.gif)\n\nhttps://github.com/vladaverin24/TimelineCards\n\n![](https://raw.githubusercontent.com/vladaverin24/TimelineCards/master/Screenshots/timeline_feed.gif)\n![](https://raw.githubusercontent.com/vladaverin24/TimelineCards/master/Screenshots/card_randomized.gif)\n![](https://raw.githubusercontent.com/vladaverin24/TimelineCards/master/Screenshots/card_samples.gif)\n\nhttps://github.com/bref-Chan/CCFoldCell\n\n![image](https://github.com/bref-Chan/CCFoldCell/blob/master/image/CCFoldCell.gif)   \n']
AppUpdate,🚀   Android 版本更新 🚀   a  library for android version update  🚀 ,3476,https://github.com/WVector/AppUpdate,master,['\n## Android 版本更新\n\n## 目录\n\n* [功能介绍](#功能介绍)\n* [效果图与示例 apk](#效果图与示例-apk)\n* [Gradle 依赖](#Gradle依赖)\n* [简单使用](#简单使用)\n* [详细说明](#详细说明)\n* [更新日志](#更新日志)\n* [License](#license)\n\n## 功能介绍\n\n- [x] 实现android版本更新\n- [x] 对kotlin适配，调用更简单\n- [x] 自定义接口协议，可以不改变现有项目的协议就能使用\n- [x] 支持get,post请求\n- [x] 支持进度显示，对话框进度条，和通知栏进度条展示\n- [x] 支持后台下载\n- [x] 支持强制更新\n- [x] 支持简单主题色配置(可以自动从顶部图片提取主色)\n- [x] 支持自定义对话框（可以监听下载进度）\n- [x] 支持静默下载（可以设置wifi状态下）\n- [x] 支持android7.0\n\n## 效果图与示例 apk\n\n<img src="https://raw.githubusercontent.com/WVector/AppUpdateDemo/master/image/example_01.png?raw=true" width="1000">\n\n<img src="https://raw.githubusercontent.com/WVector/AppUpdateDemo/master/image/example_02.png?raw=true" width="1000">\n\n<img src="https://raw.githubusercontent.com/WVector/AppUpdateDemo/master/image/example_03.png?raw=true" width="1000">\n\n<img src="https://raw.githubusercontent.com/WVector/AppUpdateDemo/master/image/example_05.png" width="1000">\n\n<img src="https://raw.githubusercontent.com/WVector/AppUpdateDemo/master/image/example_06.png" width="1000">\n\n\t\n[点击下载 Demo.apk](https://raw.githubusercontent.com/WVector/AppUpdateDemo/master/apk/sample-debug.apk) 或扫描下面的二维码安装\n\n![Demo apk文件二维](https://raw.githubusercontent.com/WVector/AppUpdateDemo/master/image/1498810770.png)\n\n\n\n## Gradle 依赖\n\n**java方式引用**\n\n```gradle\ndependencies {\n    compile \'com.qianwen:update-app:3.5.2\'\n}\n```\n\n[![Download](https://api.bintray.com/packages/qianwen/maven/update-app/images/download.svg) ](https://bintray.com/qianwen/maven/update-app/_latestVersion) [![API](https://img.shields.io/badge/API-14%2B-orange.svg?style=flat)](https://android-arsenal.com/api?level=14) [![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0) [![GitHub stars](https://img.shields.io/github/stars/WVector/AppUpdate.svg?style=plastic&label=Star) ](https://github.com/WVector/AppUpdate)\n\n\n**kotlin方式引用**\n\n```gradle\ndependencies {\n    compile \'com.qianwen:update-app-kotlin:1.2.3\'\n}\n```\n\n[![Download](https://api.bintray.com/packages/qianwen/maven/update-app-kotlin/images/download.svg) ](https://bintray.com/qianwen/maven/update-app/_latestVersion) [![API](https://img.shields.io/badge/API-14%2B-orange.svg?style=flat)](https://android-arsenal.com/api?level=14) [![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0) [![GitHub stars](https://img.shields.io/github/stars/WVector/AppUpdate.svg?style=plastic&label=Star) ](https://github.com/WVector/AppUpdate)\n\n\n## 简单使用\n\n\n\n1,java方式\n\n```java\n\tnew UpdateAppManager\n                .Builder()\n                //当前Activity\n                .setActivity(this)\n                //更新地址\n                .setUpdateUrl(mUpdateUrl)\n                //实现httpManager接口的对象\n                .setHttpManager(new UpdateAppHttpUtil())\n                .build()\n                .update();\n```\n2,kotlin方式\n\n```kotlin\n\tupdateApp(mUpdateUrl, UpdateAppHttpUtil()).update()\n```\n\n## 详细说明\n\n- [java方式](java.md)\n- [kotlin方式](kotlin.md)\n\n#### 进度条使用的是代码家的「[NumberProgressBar](https://github.com/daimajia/NumberProgressBar)」\n\n## 更新日志\n\nkotlin版本是依赖java版本的，所以java版本的问题kotlin自然修复\n\n\nv3.5.2\n\n\t1，修复下载过程中，关闭对话框不能自动安装问题。\n\nv3.5.1\n\n\t1，修复bug\n\nv3.5.0\n\n\t1，优化强制更新 \n\nv3.4.8 \n\n\t1,修复bug\n\t\nv3.4.7 \n\n\t1,优化 APP 安装的问题\n\t\nv3.4.6 \n\n\t1,优化 APP 安装的问题\n\nv3.4.5\n\n\t1，增加全局异常捕获方法\n\t\n\t                .handleException(new ExceptionHandler() \t\t\t\t\t\t{\n                    @Override\n                    public void onException(Exception e) {\n\n                    }\n                })\n\nv3.4.4\n\n\t1，修复bug\n[bug](https://github.com/WVector/AppUpdate/pull/68)\n\nv3.4.3\n\n\t1，修复bug\n[bug](https://github.com/WVector/AppUpdate/pull/67)\n   \nv3.4.2\n\n\t1,修复bug\n[bug](https://github.com/WVector/AppUpdate/pull/66)\n\nv3.4.1\n\n\t1,给插件使用者更多的配置和开启一些钩子方便适配不同的业务需求\n\t2,适配android8.0\n\n感谢[Jiiiiiin](https://github.com/Jiiiiiin)对项目的维护\n\nv3.4.0\n\n\t1,修复  \n[issues#59](https://github.com/WVector/AppUpdate/issues/59)\n\n\n\nv3.3.9\n\n\t1,适配android8.0的通知和安装未知来源的app\n\n感谢[typ0520](https://github.com/typ0520)对项目的维护\n\nv3.3.8\n\n\t1,增加存储空间权限申请\n\nV3.3.7\n\t\n\t1,修改默认安装包下载路径为download/packageName\n\n感谢[bean-liu](https://github.com/bean-liu)对项目的维护\n\nV3.3.6\n\t\n\t1,去掉对下载路径前缀的校验。\n[https://github.com/WVector/AppUpdate/issues/26](https://github.com/WVector/AppUpdate/issues/26)\n\nV3.3.5\n\n\t1，修复升级对话框布局中的问题。\n\t2，修复静默下载，关闭更新弹窗 再点击更新 一直显示的问题。\n[https://github.com/WVector/AppUpdate/issues/21](https://github.com/WVector/AppUpdate/issues/21)\n\nV3.3.4\n\n\t1，修复对话框更新内容过多，升级按钮被挤压的问题。\n\t2，去掉自动从图片提取颜色的功能， 通过.setThemeColor()设置按钮和精度条颜色，\n\t3，兼容compileSdkVersion <25\n\nV3.3.3\n\n\t1，修复下载路径是重定向路径不能下载的问题\n\nV3.3.2\n\n\t1，修复正在下载时，返回桌面报错的问题\n[https://github.com/WVector/AppUpdate/issues/14](https://github.com/WVector/AppUpdate/issues/14)\n\nV3.3.1\n\n\t1，修复对话框外可以点击的问题\n\nV3.3.0 \n\n\t1，可以设置不显示通知栏进度条。\n\t2，可以设置忽略版本。 \n\t3，优化下载时页面卡的问题（由于下载进度回调调用频繁，造成ui线程阻塞）。\n\t4，可以静默下载，类似网易云音乐，并且设置wifi状态下。\n\n V3.2.9 \n\n\t1，新增自定义对话框。\n\t2，适配kotlin，写法更简单。 \n\n\n## License\n\n   \tCopyright 2017 千匍\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.']
Medium.js,A tiny JavaScript library for making contenteditable beautiful (Like Medium's editor),4402,https://github.com/jakiestfu/Medium.js,master,['[![Medium.js](http://i.imgur.com/U6t8Eq2.png "Medium.js")](http://jakiestfu.github.io/Medium.js)\n[![Stories in Ready](https://badge.waffle.io/jakiestfu/medium.js.png?label=ready&title=Ready)](https://waffle.io/jakiestfu/medium.js)']
avbook,AV 电影管理系统， avmoo , javbus , javlibrary 爬虫，线上 AV 影片图书馆，AV 磁力链接数据库，Japanese Adult Video Library,Adult Video Magnet Links - Japanese Adult Video Database,8808,https://github.com/guyueyingmu/avbook,master,['<p align="center"><img src="https://github.com/guyueyingmu/avbook/blob/master/public/avbook/logo.png?raw=true"></p>\n\n<p align="center">\n\n<img src="https://travis-ci.org/laravel/framework.svg"> \n<img src="https://img.shields.io/packagist/php-v/symfony/symfony.svg"> \n<img src="https://img.shields.io/badge/mysql-%3E%3D5.7-brightgreen.svg"> \n<img src="https://img.shields.io/apm/l/vim-mode.svg">\n\n</p>\n\n\n[releases](https://github.com/guyueyingmu/avbook/releases/download/v.0.19.7.11/avbook_laragon.0.19.7.11.7z)\n\npassword:gyym.avbook.bt.01\n#### 使用方法:\n\n   >1.解压到 D:\\laragon <br>\n    2.打开 D:\\laragon\\laragon.exe ,点击 `启动所有`<br>\n    3.点击 `网站` 或者访问 <http://avbook.test>  enjoy it\n    \n   >ps:<br>\n     Ⅰ. 如果没有解压到 D:\\laragon 需自行修改Nginx配置，php.ini配置，并在hosts文件新增一行 ：`127.0.0.1      avbook.test` <br>\n     Ⅱ. laragon终端启动爬虫前先 `git pull ` 更新到最新版本。\n\n## License\n\nThe AVBook is open-source software licensed under the [MIT license](https://opensource.org/licenses/MIT).\n\ngyym.avbook.bt.01']
PaddleSeg,Easy-to-use image segmentation library with awesome pre-trained model zoo, supporting wide-range of practical tasks in Semantic Segmentation, Interactive Segmentation, Panoptic Segmentation, Image Matting, 3D Segmentation, etc.,6552,https://github.com/PaddlePaddle/PaddleSeg,release/2.7,['README_EN.md']
chatgpt-on-wechat,使用ChatGPT搭建微信聊天机器人，基于ChatGPT3.5 API和itchat实现。Wechat robot based on ChatGPT,  which using OpenAI api and itchat library.,5382,https://github.com/zhayujie/chatgpt-on-wechat,master,['# 简介\n\n> ChatGPT近期以强大的对话和信息整合能力风靡全网，可以写代码、改论文、讲故事，几乎无所不能，这让人不禁有个大胆的想法，能否用他的对话模型把我们的微信打造成一个智能机器人，可以在与好友对话中给出意想不到的回应，而且再也不用担心女朋友影响我们 ~~打游戏~~ 工作了。\n\n \n基于ChatGPT的微信聊天机器人，通过 [ChatGPT](https://github.com/openai/openai-python) 接口生成对话内容，使用 [itchat](https://github.com/littlecodersh/ItChat) 实现微信消息的接收和自动回复。已实现的特性如下：\n\n- [x] **文本对话：** 接收私聊及群组中的微信消息，使用ChatGPT生成回复内容，完成自动回复\n- [x] **规则定制化：** 支持私聊中按指定规则触发自动回复，支持对群组设置自动回复白名单\n- [x] **多账号：** 支持多微信账号同时运行\n- [x] **图片生成：** 支持根据描述生成图片，并自动发送至个人聊天或群聊\n- [x] **上下文记忆**：支持多轮对话记忆，且为每个好友维护独立的上下会话\n- [x] **语音识别：** 支持接收和处理语音消息，通过文字或语音回复\n\n\n# 更新日志\n\n>**2023.03.09：** 基于 `whisper API` 实现对微信语音消息的解析和回复，添加配置项 `"speech_recognition":true` 即可启用，使用参考 [#415](https://github.com/zhayujie/chatgpt-on-wechat/issues/415)。(contributed by [wanggang1987](https://github.com/wanggang1987) in [#385](https://github.com/zhayujie/chatgpt-on-wechat/pull/385))\n\n>**2023.03.02：** 接入[ChatGPT API](https://platform.openai.com/docs/guides/chat) (gpt-3.5-turbo)，默认使用该模型进行对话，需升级openai依赖 (`pip3 install --upgrade openai`)。网络问题参考 [#351](https://github.com/zhayujie/chatgpt-on-wechat/issues/351)\n\n>**2023.02.20：** 增加 [python-wechaty](https://github.com/wechaty/python-wechaty) 作为可选渠道，使用Pad协议相对稳定，但Token收费 (使用参考[#244](https://github.com/zhayujie/chatgpt-on-wechat/pull/244)，contributed by [ZQ7](https://github.com/ZQ7))\n\n>**2023.02.09：** 扫码登录存在封号风险，请谨慎使用，参考[#58](https://github.com/AutumnWhj/ChatGPT-wechat-bot/issues/158)\n\n>**2023.02.05：** 在openai官方接口方案中 (GPT-3模型) 实现上下文对话\n\n>**2022.12.19：** 引入 [itchat-uos](https://github.com/why2lyj/ItChat-UOS) 替换 itchat，解决由于不能登录网页微信而无法使用的问题，且解决Python3.9的兼容问题\n\n>**2022.12.18：** 支持根据描述生成图片并发送，openai版本需大于0.25.0\n\n>**2022.12.17：** 原来的方案是从 [ChatGPT页面](https://chat.openai.com/chat) 获取session_token，使用 [revChatGPT](https://github.com/acheong08/ChatGPT) 直接访问web接口，但随着ChatGPT接入Cloudflare人机验证，这一方案难以在服务器顺利运行。 所以目前使用的方案是调用 OpenAI 官方提供的 [API](https://beta.openai.com/docs/api-reference/introduction)，回复质量上基本接近于ChatGPT的内容，劣势是暂不支持有上下文记忆的对话，优势是稳定性和响应速度较好。\n\n# 使用效果\n\n### 个人聊天\n\n![single-chat-sample.jpg](docs/images/single-chat-sample.jpg)\n\n### 群组聊天\n\n![group-chat-sample.jpg](docs/images/group-chat-sample.jpg)\n\n### 图片生成\n\n![group-chat-sample.jpg](docs/images/image-create-sample.jpg)\n\n\n# 快速开始\n\n## 准备\n\n### 1. OpenAI账号注册\n\n前往 [OpenAI注册页面](https://beta.openai.com/signup) 创建账号，参考这篇 [教程](https://www.pythonthree.com/register-openai-chatgpt/) 可以通过虚拟手机号来接收验证码。创建完账号则前往 [API管理页面](https://beta.openai.com/account/api-keys) 创建一个 API Key 并保存下来，后面需要在项目中配置这个key。\n\n> 项目中使用的对话模型是 davinci，计费方式是约每 750 字 (包含请求和回复) 消耗 $0.02，图片生成是每张消耗 $0.016，账号创建有免费的 $18 额度，使用完可以更换邮箱重新注册。\n\n\n### 2.运行环境\n\n支持 Linux、MacOS、Windows 系统（可在Linux服务器上长期运行)，同时需安装 `Python`。 \n> 建议Python版本在 3.7.1~3.9.X 之间，3.10及以上版本在 MacOS 可用，其他系统上不确定能否正常运行。\n\n\n1.克隆项目代码：\n\n```bash\ngit clone https://github.com/zhayujie/chatgpt-on-wechat\ncd chatgpt-on-wechat/\n```\n\n2.安装所需核心依赖：\n\n```bash\npip3 install itchat-uos==1.5.0.dev0\npip3 install --upgrade openai\n```\n注：`itchat-uos`使用指定版本1.5.0.dev0，`openai`使用最新版本，需高于0.27.0。\n\n\n## 配置\n\n配置文件的模板在根目录的`config-template.json`中，需复制该模板创建最终生效的 `config.json` 文件：\n\n```bash\ncp config-template.json config.json\n```\n\n然后在`config.json`中填入配置，以下是对默认配置的说明，可根据需要进行自定义修改：\n\n```bash\n# config.json文件内容示例\n{ \n  "open_ai_api_key": "YOUR API KEY",                          # 填入上面创建的 OpenAI API KEY\n  "proxy": "127.0.0.1:7890",                                  # 代理客户端的ip和端口\n  "single_chat_prefix": ["bot", "@bot"],                      # 私聊时文本需要包含该前缀才能触发机器人回复\n  "single_chat_reply_prefix": "[bot] ",                       # 私聊时自动回复的前缀，用于区分真人\n  "group_chat_prefix": ["@bot"],                              # 群聊时包含该前缀则会触发机器人回复\n  "group_name_white_list": ["ChatGPT测试群", "ChatGPT测试群2"], # 开启自动回复的群名称列表\n  "image_create_prefix": ["画", "看", "找"],                   # 开启图片回复的前缀\n  "conversation_max_tokens": 1000,                            # 支持上下文记忆的最多字符数\n  "character_desc": "你是ChatGPT, 一个由OpenAI训练的大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。"  # 人格描述\n}\n```\n**配置说明：**\n\n**1.个人聊天**\n\n+ 个人聊天中，需要以 "bot"或"@bot" 为开头的内容触发机器人，对应配置项 `single_chat_prefix` (如果不需要以前缀触发可以填写  `"single_chat_prefix": [""]`)\n+ 机器人回复的内容会以 "[bot] " 作为前缀， 以区分真人，对应的配置项为 `single_chat_reply_prefix` (如果不需要前缀可以填写 `"single_chat_reply_prefix": ""`)\n\n**2.群组聊天**\n\n+ 群组聊天中，群名称需配置在 `group_name_white_list ` 中才能开启群聊自动回复。如果想对所有群聊生效，可以直接填写 `"group_name_white_list": ["ALL_GROUP"]`\n+ 默认只要被人 @ 就会触发机器人自动回复；另外群聊天中只要检测到以 "@bot" 开头的内容，同样会自动回复（方便自己触发），这对应配置项 `group_chat_prefix`\n+ 可选配置: `group_name_keyword_white_list`配置项支持模糊匹配群名称，`group_chat_keyword`配置项则支持模糊匹配群消息内容，用法与上述两个配置项相同。（Contributed by [evolay](https://github.com/evolay))\n\n**3.语音识别**\n+ 添加 `"speech_recognition": true` 将开启语音识别，默认使用openai的whisper模型识别为文字，同时以文字回复，目前只支持私聊 (注意由于语音消息无法匹配前缀，一旦开启将对所有语音自动回复)；\n+ 添加 `"voice_reply_voice": true` 将开启语音回复语音，但是需要配置对应语音合成平台的key，由于itchat协议的限制，只能发送语音mp3文件，若使用wechaty则回复的是微信语音。\n\n**4.其他配置**\n\n+ `proxy`：由于目前 `openai` 接口国内无法访问，需配置代理客户端的地址，详情参考  [#351](https://github.com/zhayujie/chatgpt-on-wechat/issues/351)\n+ 对于图像生成，在满足个人或群组触发条件外，还需要额外的关键词前缀来触发，对应配置 `image_create_prefix `\n+ 关于OpenAI对话及图片接口的参数配置（内容自由度、回复字数限制、图片大小等），可以参考 [对话接口](https://beta.openai.com/docs/api-reference/completions) 和 [图像接口](https://beta.openai.com/docs/api-reference/completions)  文档直接在 [代码](https://github.com/zhayujie/chatgpt-on-wechat/blob/master/bot/openai/open_ai_bot.py) `bot/openai/open_ai_bot.py` 中进行调整。\n+ `conversation_max_tokens`：表示能够记忆的上下文最大字数（一问一答为一组对话，如果累积的对话字数超出限制，就会优先移除最早的一组对话）\n+ `character_desc` 配置中保存着你对机器人说的一段话，他会记住这段话并作为他的设定，你可以为他定制任何人格      (关于会话上下文的更多内容参考该 [issue](https://github.com/zhayujie/chatgpt-on-wechat/issues/43))\n\n\n## 运行\n\n### 1.本地运行\n\n如果是开发机 **本地运行**，直接在项目根目录下执行：\n\n```bash\npython3 app.py\n```\n终端输出二维码后，使用微信进行扫码，当输出 "Start auto replying" 时表示自动回复程序已经成功运行了（注意：用于登录的微信需要在支付处已完成实名认证）。扫码登录后你的账号就成为机器人了，可以在微信手机端通过配置的关键词触发自动回复 (任意好友发送消息给你，或是自己发消息给好友)，参考[#142](https://github.com/zhayujie/chatgpt-on-wechat/issues/142)。 \n\n\n### 2.服务器部署\n\n使用nohup命令在后台运行程序：\n\n```bash\ntouch nohup.out                                   # 首次运行需要新建日志文件                     \nnohup python3 app.py & tail -f nohup.out          # 在后台运行程序并通过日志输出二维码\n```\n扫码登录后程序即可运行于服务器后台，此时可通过 `ctrl+c` 关闭日志，不会影响后台程序的运行。使用 `ps -ef | grep app.py | grep -v grep` 命令可查看运行于后台的进程，如果想要重新启动程序可以先 `kill` 掉对应的进程。日志关闭后如果想要再次打开只需输入\xa0`tail -f nohup.out`。\nscripts/目录有相应的脚本可以调用\n\n> **注意：** 如果 扫码后手机提示登录验证需要等待5s，而终端的二维码再次刷新并提示 `Log in time out, reloading QR code`，此时需参考此 [issue](https://github.com/zhayujie/chatgpt-on-wechat/issues/8) 修改一行代码即可解决。\n\n> **多账号支持：** 将 项目复制多份，分别启动程序，用不同账号扫码登录即可实现同时运行。\n\n> **特殊指令：** 用户向机器人发送 **#清除记忆** 即可清空该用户的上下文记忆。\n\n\n### 3.Docker部署\n\n参考文档 [Docker部署](https://github.com/limccn/chatgpt-on-wechat/wiki/Docker%E9%83%A8%E7%BD%B2)   (Contributed by [limccn](https://github.com/limccn))。\n\n\n## 常见问题\n\nFAQs： <https://github.com/zhayujie/chatgpt-on-wechat/wiki/FAQs>\n\n\n## 联系\n\n欢迎提交PR、Issues，以及Star支持一下。程序运行遇到问题优先查看 [常见问题列表](https://github.com/zhayujie/chatgpt-on-wechat/wiki/FAQs) ，其次前往 [Issues](https://github.com/zhayujie/chatgpt-on-wechat/issues) 中搜索，若无相似问题可创建Issue，或加微信 eijuyahz 交流。\n\n \n']
interview,📚 C/C++ 技术面试基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。This repository is a summary of the basic knowledge of recruiting job seekers and beginners in the direction of C/C++ technology, including language, program library, data structure, algorithm, system, network, link loading library, interview experience, recruitment, recommendation, etc.,27949,https://github.com/huihut/interview,master,['<div align="center">\n📖 Github\n&emsp;&emsp; | &emsp;&emsp;\n<a href="https://interview.huihut.com">📚 Docsify</a>\n</div> \n<br>\n\n<div align="center">\n简体中文\n&emsp;&emsp; | &emsp;&emsp;\n<a href="https://github.com/huihut/interview/blob/master/README_en.md">English</a>\n</div> \n<br>\n\n<b><details><summary>💡 关于</summary></b>\n\n📚 本仓库是面向 C/C++ 技术方向校招求职者、初学者的基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。\n\n💡 侧边目录支持方式：[📚 Docsify 文档](https://interview.huihut.com)、[Github + TOC 导航](https://github.com/jawil/GayHub)（[TOC预览.png](https://gitee.com/huihut/interview/raw/master/images/TOC预览.png)）\n\n📄 保存为 PDF 方式：使用 Chrome 浏览器打开 <a href="https://interview.huihut.com">📚 Docsify 文档</a> 页面，缩起左侧目录-右键 - 打印 - 选择目标打印机是另存为PDF - 保存（[打印预览.png](https://gitee.com/huihut/interview/raw/master/images/打印预览.png)）\n\n🙏 仓库内容如有错误或改进欢迎 issue 或 pr，建议或讨论可在 [#12](https://github.com/huihut/interview/issues/12) 提出。由于本人水平有限，仓库中的知识点有来自本人原创、读书笔记、书籍、博文等，非原创均已标明出处，如有遗漏，请 issue 提出。本仓库遵循 [CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享）](https://github.com/huihut/interview/blob/master/LICENSE) 协议，转载请注明出处，不得用于商业目的。\n\n</details>\n\n## 📑 目录\n\n* [➕ C/C++](#cc)\n* [⭐️ Effective](#effective)\n* [📦 STL](#stl)\n* [〽️ 数据结构](#data-structure)\n* [⚡️ 算法](#algorithm)\n* [❓ Problems](#problems)\n* [💻 操作系统](#os)\n* [☁️ 计算机网络](#computer-network)\n* [🌩 网络编程](#network-programming)\n* [💾 数据库](#database)\n* [📏 设计模式](#design-pattern)\n* [⚙️ 链接装载库](#link-loading-library)\n* [📚 书籍](#books)\n* [🔱 C/C++ 发展方向](#cc-development-direction)\n* [💯 复习刷题网站](#review-of-brush-questions-website)\n* [📝 面试题目经验](#interview-questions-experience)\n* [📆 招聘时间岗位](#recruitment-time-post)\n* [👍 内推](#recommend)\n* [👬 贡献者](#contributor)\n* [🍭 支持赞助](#support-sponsor)\n* [📜 License](#license)\n\n\n<a id="cc"></a>\n\n## ➕ C/C++\n\n### const\n\n#### 作用\n\n1. 修饰变量，说明该变量不可以被改变；\n2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；\n3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；\n4. 修饰成员函数，说明该成员函数内不能修改成员变量。\n\n#### const 的指针与引用\n\n* 指针\n    * 指向常量的指针（pointer to const）\n    * 自身是常量的指针（常量指针，const pointer）\n* 引用\n    * 指向常量的引用（reference to const）\n    * 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰\n\n> （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 `p2`、`p3`\n\n#### 使用\n\nconst 使用\n\n```cpp\n// 类\nclass A\n{\nprivate:\n    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化\n\npublic:\n    // 构造函数\n    A() : a(0) { };\n    A(int x) : a(x) { };        // 初始化列表\n\n    // const可用于对重载函数的区分\n    int getValue();             // 普通成员函数\n    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值\n};\n\nvoid function()\n{\n    // 对象\n    A b;                        // 普通对象，可以调用全部成员函数\n    const A a;                  // 常对象，只能调用常成员函数\n    const A *p = &a;            // 指针变量，指向常对象\n    const A &q = a;             // 指向常对象的引用\n\n    // 指针\n    char greeting[] = "Hello";\n    char* p1 = greeting;                // 指针变量，指向字符数组变量\n    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）\n    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）\n    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量\n}\n\n// 函数\nvoid function1(const int Var);           // 传递过来的参数在函数内不可变\nvoid function2(const char* Var);         // 参数指针所指内容为常量\nvoid function3(char* const Var);         // 参数指针为常量\nvoid function4(const int& Var);          // 引用参数在函数内为常量\n\n// 函数返回值\nconst int function5();      // 返回一个常数\nconst int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();\nint* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();\n```\n\n#### 宏定义 #define 和 const 常量 \n\n宏定义 #define|const 常量\n---|---\n宏定义，相当于字符替换|常量声明\n预处理器处理|编译器处理\n无类型安全检查|有类型安全检查\n不分配内存|要分配内存\n存储在代码段|存储在数据段\n可通过 `#undef` 取消|不可取消\n\n### static\n\n#### 作用\n\n1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。\n4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。\n\n### this 指针\n\n1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。\n2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。\n3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。\n4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；\n5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。\n6. 在以下场景中，经常需要显式引用 `this` 指针：\n    1. 为实现对象的链式引用；\n    2. 为避免对同一对象进行赋值操作；\n    3. 在实现一些数据结构时，如 `list`。\n\n### inline 内联函数\n\n#### 特征\n\n* 相当于把内联函数里面的内容写在调用内联函数处；\n* 相当于不用执行进入函数的步骤，直接执行函数体；\n* 相当于宏，却比宏多了类型检查，真正具有函数特性；\n* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；\n* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。\n\n#### 使用\n\ninline 使用\n\n```cpp\n// 声明1（加 inline，建议使用）\ninline int functionName(int first, int second,...);\n\n// 声明2（不加 inline）\nint functionName(int first, int second,...);\n\n// 定义\ninline int functionName(int first, int second,...) {/****/};\n\n// 类内定义，隐式内联\nclass A {\n    int doA() { return 0; }         // 隐式内联\n}\n\n// 类外定义，需要显式内联\nclass A {\n    int doA();\n}\ninline int A::doA() { return 0; }   // 需要显式内联\n```\n\n#### 编译器对 inline 函数的处理步骤\n\n1. 将 inline 函数体复制到 inline 函数调用点处； \n2. 为所用 inline 函数中的局部变量分配内存空间； \n3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； \n4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。\n\n#### 优缺点\n\n优点\n\n1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。\n2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 \n3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。\n4. 内联函数在运行时可调试，而宏定义不可以。\n\n缺点\n\n1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。\n2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。\n3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。\n\n#### 虚函数（virtual）可以是内联函数（inline）吗？\n\n> [Are "inline virtual" member functions ever actually "inlined"?](http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html)\n\n* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。\n* 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。\n* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。\n\n虚函数内联使用\n\n```cpp\n#include <iostream>  \nusing namespace std;\nclass Base\n{\npublic:\n\tinline virtual void who()\n\t{\n\t\tcout << "I am Base\\n";\n\t}\n\tvirtual ~Base() {}\n};\nclass Derived : public Base\n{\npublic:\n\tinline void who()  // 不写inline时隐式内联\n\t{\n\t\tcout << "I am Derived\\n";\n\t}\n};\n\nint main()\n{\n\t// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 \n\tBase b;\n\tb.who();\n\n\t// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  \n\tBase *ptr = new Derived();\n\tptr->who();\n\n\t// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。\n\tdelete ptr;\n\tptr = nullptr;\n\n\tsystem("pause");\n\treturn 0;\n} \n```\n\n### volatile\n\n```cpp\nvolatile int i = 10; \n```\n\n* volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。\n* volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）\n* const 可以是 volatile （如只读的状态寄存器）\n* 指针可以是 volatile\n\n### assert()\n\n断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。\n\nassert() 使用\n\n```cpp\n#define NDEBUG          // 加上这行，则 assert 不可用\n#include <assert.h>\n\nassert( p != NULL );    // assert 不可用\n```\n\n### sizeof()\n\n* sizeof 对数组，得到整个数组所占空间大小。\n* sizeof 对指针，得到指针本身所占空间大小。\n\n### #pragma pack(n)\n\n设定结构体、联合以及类成员变量以 n 字节方式对齐\n\n#pragma pack(n) 使用\n\n```cpp\n#pragma pack(push)  // 保存对齐状态\n#pragma pack(4)     // 设定为 4 字节对齐\n\nstruct test\n{\n    char m1;\n    double m4;\n    int m3;\n};\n\n#pragma pack(pop)   // 恢复对齐状态\n```\n\n### 位域\n\n```cpp\nBit mode: 2;    // mode 占 2 位\n```\n\n类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。\n\n* 位域在内存中的布局是与机器有关的\n* 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定\n* 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域\n\n### extern "C"\n\n* 被 extern 限定的函数或变量是 extern 类型的\n* 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的\n\n`extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。\n\nextern "C" 使用\n\n```cpp\n#ifdef __cplusplus\nextern "C" {\n#endif\n\nvoid *memset(void *, int, size_t);\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n### struct 和 typedef struct\n\n#### C 中\n\n```c\n// c\ntypedef struct Student {\n    int age; \n} S;\n```\n\n等价于\n\n```c\n// c\nstruct Student { \n    int age; \n};\n\ntypedef struct Student S;\n```\n\n此时 `S` 等价于 `struct Student`，但两个标识符名称空间不相同。\n\n另外还可以定义与 `struct Student` 不冲突的 `void Student() {}`。\n\n#### C++ 中\n\n由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。\n\n一、如果在类标识符空间定义了 `struct Student {...};`，使用 `Student me;` 时，编译器将搜索全局标识符表，`Student` 未找到，则在类标识符内搜索。\n\n即表现为可以使用 `Student` 也可以使用 `struct Student`，如下：\n\n```cpp\n// cpp\nstruct Student { \n    int age; \n};\n\nvoid f( Student me );       // 正确，"struct" 关键字可省略\n```\n\n二、若定义了与 `Student` 同名函数之后，则 `Student` 只代表函数，不代表结构体，如下：\n\n```cpp\ntypedef struct Student { \n    int age; \n} S;\n\nvoid Student() {}           // 正确，定义后 "Student" 只代表此函数\n\n//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名\n\nint main() {\n    Student(); \n    struct Student me;      // 或者 "S me";\n    return 0;\n}\n```\n\n### C++ 中 struct 和 class\n\n总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。\n\n#### 区别\n\n* 最本质的一个区别就是默认的访问控制\n    1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。  \n    2. struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。\n\n### union 联合\n\n联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：\n\n* 默认访问控制符为 public\n* 可以含有构造函数、析构函数\n* 不能含有引用类型的成员\n* 不能继承自其他类，不能作为基类\n* 不能含有虚函数\n* 匿名 union 在定义所在作用域可直接访问 union 成员\n* 匿名 union 不能包含 protected 成员或 private 成员\n* 全局匿名联合必须是静态（static）的\n\nunion 使用\n\n```cpp\n#include<iostream>\n\nunion UnionTest {\n    UnionTest() : i(10) {};\n    int i;\n    double d;\n};\n\nstatic union {\n    int i;\n    double d;\n};\n\nint main() {\n    UnionTest u;\n\n    union {\n        int i;\n        double d;\n    };\n\n    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10\n\n    ::i = 20;\n    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20\n\n    i = 30;\n    std::cout << i << std::endl;    // 输出局部匿名联合的 30\n\n    return 0;\n}\n```\n\n### C 实现 C++ 类\n\nC 实现 C++ 的面向对象特性（封装、继承、多态）\n\n* 封装：使用函数指针把属性与方法封装到结构体中\n* 继承：结构体嵌套\n* 多态：父类与子类方法的函数指针不同\n\n> [Can you write object-oriented code in C? [closed]](https://stackoverflow.com/a/351745)\n\n### explicit（显式）关键字\n\n* explicit 修饰构造函数时，可以防止隐式转换和复制初始化\n* explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外\n\nexplicit 使用\n\n```cpp\nstruct A\n{\n\tA(int) { }\n\toperator bool() const { return true; }\n};\n\nstruct B\n{\n\texplicit B(int) {}\n\texplicit operator bool() const { return true; }\n};\n\nvoid doA(A a) {}\n\nvoid doB(B b) {}\n\nint main()\n{\n\tA a1(1);\t\t// OK：直接初始化\n\tA a2 = 1;\t\t// OK：复制初始化\n\tA a3{ 1 };\t\t// OK：直接列表初始化\n\tA a4 = { 1 };\t\t// OK：复制列表初始化\n\tA a5 = (A)1;\t\t// OK：允许 static_cast 的显式转换 \n\tdoA(1);\t\t\t// OK：允许从 int 到 A 的隐式转换\n\tif (a1);\t\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换\n\tbool a6(a1);\t\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换\n\tbool a7 = a1;\t\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换\n\tbool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化\n\n\tB b1(1);\t\t// OK：直接初始化\n\tB b2 = 1;\t\t// 错误：被 explicit 修饰构造函数的对象不可以复制初始化\n\tB b3{ 1 };\t\t// OK：直接列表初始化\n\tB b4 = { 1 };\t\t// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化\n\tB b5 = (B)1;\t\t// OK：允许 static_cast 的显式转换\n\tdoB(1);\t\t\t// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换\n\tif (b1);\t\t// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换\n\tbool b6(b1);\t\t// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换\n\tbool b7 = b1;\t\t// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换\n\tbool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化\n\n\treturn 0;\n}\n```\n\n### friend 友元类和友元函数\n\n* 能访问私有成员  \n* 破坏封装性\n* 友元关系不可传递\n* 友元关系的单向性\n* 友元声明的形式及数量不受限制\n\n### using\n\n#### using 声明\n\n一条 `using 声明` 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：\n\n```cpp\nusing namespace_name::name;\n```\n\n#### 构造函数的 using 声明\n\n在 C++11 中，派生类能够重用其直接基类定义的构造函数。\n\n```cpp\nclass Derived : Base {\npublic:\n    using Base::Base;\n    /* ... */\n};\n```\n\n如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：\n\n```cpp\nDerived(parms) : Base(args) { }\n```\n\n#### using 指示\n\n`using 指示` 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：\n\n```cpp\nusing namespace_name name;\n```\n\n#### 尽量少使用 `using 指示` 污染命名空间\n\n> 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它**只导入了指定的名称**。如果该名称与局部名称发生冲突，编译器将**发出指示**。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则**局部名称将覆盖名称空间版本**，而编译器**并不会发出警告**。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。\n\nusing 使用\n\n尽量少使用 `using 指示`\n\n```cpp\nusing namespace std;\n```\n\n应该多使用 `using 声明`\n\n```cpp\nint x;\nstd::cin >> x ;\nstd::cout << x << std::endl;\n```\n\n或者\n\n```cpp\nusing std::cin;\nusing std::cout;\nusing std::endl;\nint x;\ncin >> x;\ncout << x << endl;\n```\n\n### :: 范围解析运算符\n\n#### 分类\n\n1. 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间\n2. 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的\n3. 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的\n\n:: 使用\n\n```cpp\nint count = 11;         // 全局（::）的 count\n\nclass A {\npublic:\n\tstatic int count;   // 类 A 的 count（A::count）\n};\nint A::count = 21;\n\nvoid fun()\n{\n\tint count = 31;     // 初始化局部的 count 为 31\n\tcount = 32;         // 设置局部的 count 的值为 32\n}\n\nint main() {\n\t::count = 12;       // 测试 1：设置全局的 count 的值为 12\n\n\tA::count = 22;      // 测试 2：设置类 A 的 count 为 22\n\n\tfun();\t\t        // 测试 3\n\n\treturn 0;\n}\n```\n\n### enum 枚举类型\n\n#### 限定作用域的枚举类型\n\n```cpp\nenum class open_modes { input, output, append };\n```\n\n#### 不限定作用域的枚举类型\n\n```cpp\nenum color { red, yellow, green };\nenum { floatPrec = 6, doublePrec = 10 };\n```\n\n### decltype\n\ndecltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：\n\n```cpp\ndecltype ( expression )\n```\n\ndecltype 使用\n\n```cpp\n// 尾置返回允许我们在参数列表之后声明返回类型\ntemplate <typename It>\nauto fcn(It beg, It end) -> decltype(*beg)\n{\n    // 处理序列\n    return *beg;    // 返回序列中一个元素的引用\n}\n// 为了使用模板参数成员，必须用 typename\ntemplate <typename It>\nauto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type\n{\n    // 处理序列\n    return *beg;    // 返回序列中一个元素的拷贝\n}\n```\n\n### 引用\n\n#### 左值引用\n\n常规引用，一般表示对象的身份。\n\n#### 右值引用\n\n右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。\n\n右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：\n\n* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。\n* 能够更简洁明确地定义泛型函数。\n\n#### 引用折叠\n\n* `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`\n* `X&& &&` 可折叠成 `X&&`\n\n### 宏\n\n* 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。\n\n### 成员初始化列表\n\n好处\n\n* 更高效：少了一次调用默认构造函数的过程。\n* 有些场合必须要用初始化列表：\n  1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面\n  2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面\n  3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化\n\n### initializer_list 列表初始化\n\n用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 `std::initializer_list` 参数.\n\ninitializer_list 使用\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <initializer_list>\n \ntemplate <class T>\nstruct S {\n    std::vector<T> v;\n    S(std::initializer_list<T> l) : v(l) {\n         std::cout << "constructed with a " << l.size() << "-element list\\n";\n    }\n    void append(std::initializer_list<T> l) {\n        v.insert(v.end(), l.begin(), l.end());\n    }\n    std::pair<const T*, std::size_t> c_arr() const {\n        return {&v[0], v.size()};  // 在 return 语句中复制列表初始化\n                                   // 这不使用 std::initializer_list\n    }\n};\n \ntemplate <typename T>\nvoid templated_fn(T) {}\n \nint main()\n{\n    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化\n    s.append({6, 7, 8});      // 函数调用中的列表初始化\n \n    std::cout << "The vector size is now " << s.c_arr().second << " ints:\\n";\n \n    for (auto n : s.v)\n        std::cout << n << \' \';\n    std::cout << \'\\n\';\n \n    std::cout << "Range-for over brace-init-list: \\n";\n \n    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作\n        std::cout << x << \' \';\n    std::cout << \'\\n\';\n \n    auto al = {10, 11, 12};   // auto 的特殊规则\n \n    std::cout << "The list bound to auto has size() = " << al.size() << \'\\n\';\n \n//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，\n                             // 它无类型，故 T 无法推导\n    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK\n    templated_fn<std::vector<int>>({1, 2, 3});           // 也 OK\n}\n```\n\n### 面向对象\n\n面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。\n\n![面向对象特征](https://gitee.com/huihut/interview/raw/master/images/面向对象基本特征.png)\n\n面向对象三大特征 —— 封装、继承、多态\n\n### 封装\n\n把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。\n\n* `public` 成员：可以被任意实体访问\n* `protected` 成员：只允许被子类及本类的成员函数访问\n* `private` 成员：只允许被本类的成员函数、友元类或友元函数访问\n\n### 继承\n\n* 基类（父类）——&gt; 派生类（子类）\n\n### 多态\n\n* 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。\n* 多态是以封装和继承为基础的。\n* C++ 多态分类及实现：\n    1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载\n    2. 子类型多态（Subtype Polymorphism，运行期）：虚函数\n    3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板\n    4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换\n\n> [The Four Polymorphisms in C++](https://catonmat.net/cpp-polymorphism)\n\n#### 静态多态（编译期/早绑定）\n\n函数重载\n\n```cpp\nclass A\n{\npublic:\n    void do(int a);\n    void do(int a, int b);\n};\n```\n\n#### 动态多态（运行期期/晚绑定）\n* 虚函数：用 virtual 修饰成员函数，使其成为虚函数\n* 动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定\n\n**注意：**\n\n* 可以将派生类的对象赋值给基类的指针或引用，反之不可\n* 普通函数（非类成员函数）不能是虚函数\n* 静态函数（static）不能是虚函数\n* 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）\n* 内联函数不能是表现多态性时的虚函数，解释见：[虚函数（virtual）可以是内联函数（inline）吗？](https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97)\n\n动态多态使用\n\n```cpp\nclass Shape                     // 形状类\n{\npublic:\n    virtual double calcArea()\n    {\n        ...\n    }\n    virtual ~Shape();\n};\nclass Circle : public Shape     // 圆形类\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nclass Rect : public Shape       // 矩形类\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nint main()\n{\n    Shape * shape1 = new Circle(4.0);\n    Shape * shape2 = new Rect(5.0, 6.0);\n    shape1->calcArea();         // 调用圆形类里面的方法\n    shape2->calcArea();         // 调用矩形类里面的方法\n    delete shape1;\n    shape1 = nullptr;\n    delete shape2;\n    shape2 = nullptr;\n    return 0;\n}\n```\n\n### 虚析构函数\n\n虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。\n\n虚析构函数使用\n\n```cpp\nclass Shape\n{\npublic:\n    Shape();                    // 构造函数不能是虚函数\n    virtual double calcArea();\n    virtual ~Shape();           // 虚析构函数\n};\nclass Circle : public Shape     // 圆形类\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nint main()\n{\n    Shape * shape1 = new Circle(4.0);\n    shape1->calcArea();    \n    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。\n    shape1 = NULL;\n    return 0；\n}\n```\n\n### 纯虚函数\n\n纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。\n\n```cpp\nvirtual int A() = 0;\n```\n\n### 虚函数、纯虚函数\n\n* 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 \n* 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。\n* 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 \n* 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。\n* 虚基类是虚继承中的基类，具体见下文虚继承。\n\n> [CSDN . C++ 中的虚函数、纯虚函数区别和联系](https://blog.csdn.net/u012260238/article/details/53610462)\n\n### 虚函数指针、虚函数表\n\n* 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。\n* 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。\n\n> [C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现](https://blog.twofei.com/496/)\n\n### 虚继承\n\n虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。\n\n底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。\n\n实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。\n\n### 虚继承、虚函数\n\n* 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）\n* 不同之处：\n    * 虚继承\n        * 虚基类依旧存在继承类中，只占用存储空间\n        * 虚基类表存储的是虚基类相对直接继承类的偏移\n    * 虚函数\n        * 虚函数不占用存储空间\n        * 虚函数表存储的是虚函数地址\n\n### 模板类、成员模板、虚函数\n\n* 模板类中可以使用虚函数\n* 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数\n\n### 抽象类、接口类、聚合类\n\n* 抽象类：含有纯虚函数的类\n* 接口类：仅含有纯虚函数的抽象类\n* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n    * 所有成员都是 public\n    * 没有定义任何构造函数\n    * 没有类内初始化\n    * 没有基类，也没有 virtual 函数\n\n### 内存分配和管理\n\n#### malloc、calloc、realloc、alloca\n\n1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。\n2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。\n3. realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。\n4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。\n\n#### malloc、free\n\n用于分配、释放内存\n\nmalloc、free 使用\n\n申请内存，确认是否申请成功\n\n```cpp\nchar *str = (char*) malloc(100);\nassert(str != nullptr);\n```\n\n释放内存后指针置空\n\n```cpp\nfree(p); \np = nullptr;\n```\n\n#### new、delete\n\n1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。\n2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。\n3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。\n\nnew、delete 使用\n\n申请内存，确认是否申请成功\n\n```cpp\nint main()\n{\n    T* t = new T();     // 先内存分配 ，再构造函数\n    delete t;           // 先析构函数，再内存释放\n    return 0;\n}\n```\n\n#### 定位 new\n\n定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。\n\n```cpp\nnew (place_address) type\nnew (place_address) type (initializers)\nnew (place_address) type [size]\nnew (place_address) type [size] { braced initializer list }\n```\n\n* `place_address` 是个指针\n* `initializers` 提供一个（可能为空的）以逗号分隔的初始值列表\n\n### delete this 合法吗？\n\n> [Is it legal (and moral) for a member function to say delete this?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)\n\n合法，但：\n\n1. 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的\n2. 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数\n3. 必须保证成员函数的 `delete this ` 后面没有调用 this 了\n4. 必须保证 `delete this` 后没有人使用了\n\n### 如何定义一个只能在堆上（栈上）生成对象的类？\n\n> [如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)\n\n#### 只能在堆上\n\n方法：将析构函数设置为私有\n\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。\n\n#### 只能在栈上\n\n方法：将 new 和 delete 重载为私有\n\n原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。\n\n### 智能指针\n\n#### C++ 标准库（STL）中\n\n头文件：`#include <memory>`\n\n#### C++ 98\n\n```cpp\nstd::auto_ptr<std::string> ps (new std::string(str))；\n```\n\n#### C++ 11\n\n1. shared_ptr\n2. unique_ptr\n3. weak_ptr\n4. auto_ptr（被 C++11 弃用）\n\n* Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。\n* Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。\n\n##### shared_ptr\n\n多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。\n\n* 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁\n\n##### weak_ptr\n\nweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。\n\n* 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题\n\n##### unique_ptr\n\nunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。\n\n* unique_ptr 用于取代 auto_ptr\n\n##### auto_ptr\n\n被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵。\n\n##### auto_ptr 与 unique_ptr 比较\n\n* auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；\n* auto_ptr 对象不能管理数组（析构调用 `delete`），unique_ptr 可以管理数组（析构调用 `delete[]` ）；\n\n### 强制类型转换运算符\n\n> [MSDN . 强制转换运算符](https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx)\n\n#### static_cast\n\n* 用于非多态类型的转换\n* 不执行运行时类型检查（转换安全性不如 dynamic_cast）\n* 通常用于转换数值数据类型（如 float -> int）\n* 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）\n\n> 向上转换是一种隐式转换。\n\n#### dynamic_cast\n\n* 用于多态类型的转换\n* 执行行运行时类型检查\n* 只适用于指针或引用\n* 对不明确的指针的转换将失败（返回 nullptr），但不引发异常\n* 可以在整个类层次结构中移动指针，包括向上转换、向下转换\n\n#### const_cast \n\n* 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）\n\n#### reinterpret_cast\n\n* 用于位的简单重新解释\n* 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。\n* 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）\n* 也允许将任何整数类型转换为任何指针类型以及反向转换。\n* reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 \n* reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。\n\n#### bad_cast\n\n* 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。\n\nbad_cast 使用\n\n```cpp\ntry {  \n    Circle& ref_circle = dynamic_cast<Circle&>(ref_shape);   \n}  \ncatch (bad_cast b) {  \n    cout << "Caught: " << b.what();  \n} \n```\n\n### 运行时类型信息 (RTTI) \n\n#### dynamic_cast\n\n* 用于多态类型的转换\n\n#### typeid\n\n* typeid 运算符允许在运行时确定对象的类型\n* type\\_id 返回一个 type\\_info 对象的引用\n* 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数\n* 只能获取对象的实际类型\n\n#### type_info\n\n* type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。\n* 头文件：`typeinfo`\n\ntypeid、type_info 使用\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Flyable                       // 能飞的\n{\npublic:\n    virtual void takeoff() = 0;     // 起飞\n    virtual void land() = 0;        // 降落\n};\nclass Bird : public Flyable         // 鸟\n{\npublic:\n    void foraging() {...}           // 觅食\n    virtual void takeoff() {...}\n    virtual void land() {...}\n    virtual ~Bird(){}\n};\nclass Plane : public Flyable        // 飞机\n{\npublic:\n    void carry() {...}              // 运输\n    virtual void takeoff() {...}\n    virtual void land() {...}\n};\n\nclass type_info\n{\npublic:\n    const char* name() const;\n    bool operator == (const type_info & rhs) const;\n    bool operator != (const type_info & rhs) const;\n    int before(const type_info & rhs) const;\n    virtual ~type_info();\nprivate:\n    ...\n};\n\nvoid doSomething(Flyable *obj)                 // 做些事情\n{\n    obj->takeoff();\n\n    cout << typeid(*obj).name() << endl;        // 输出传入对象类型（"class Bird" or "class Plane"）\n\n    if(typeid(*obj) == typeid(Bird))            // 判断对象类型\n    {\n        Bird *bird = dynamic_cast<Bird *>(obj); // 对象转化\n        bird->foraging();\n    }\n\n    obj->land();\n}\n\nint main(){\n\tBird *b = new Bird();\n\tdoSomething(b);\n\tdelete b;\n\tb = nullptr;\n\treturn 0;\n}\n```\n\n<a id="effective"></a>\n\n## ⭐️ Effective\n\n### Effective C++\n\n1. 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）\n2. 宁可以编译器替换预处理器（尽量以 `const`、`enum`、`inline` 替换 `#define`）\n3. 尽可能使用 const\n4. 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）\n5. 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）\n6. 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）\n7. 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）\n8. 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）\n9. 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）\n10. 令 `operator=` 返回一个 `reference to *this` （用于连锁赋值）\n11. 在 `operator=` 中处理 “自我赋值”\n12. 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）\n13. 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））\n14. 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））\n15. 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）\n16. 成对使用 new 和 delete 时要采取相同形式（`new` 中使用 `[]` 则 `delete []`，`new` 中不使用 `[]` 则 `delete`）\n17. 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）\n18. 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）\n19. 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。\n20. 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）\n21. 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）\n22. 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）\n23. 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）\n24. 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数\n25. 考虑写一个不抛异常的 swap 函数\n26. 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）\n27. 尽量少做转型动作（旧式：`(T)expression`、`T(expression)`；新式：`const_cast<T>(expression)`、`dynamic_cast<T>(expression)`、`reinterpret_cast<T>(expression)`、`static_cast<T>(expression)`、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）\n28. 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）\n29. 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）\n30. 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）\n31. 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）\n32. 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）\n33. 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）\n34. 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）\n35. 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 `tr1::function` 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）\n36. 绝不重新定义继承而来的 non-virtual 函数\n37. 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）\n38. 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））\n39. 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）\n40. 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）\n41. 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）\n42. 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）\n43. 学习处理模板化基类内的名称（可在 derived class templates 内通过 `this->` 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）\n44. 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）\n45. 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）\n46. 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）\n47. 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if...else 测试）\n48. 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）\n49. 了解 new-handler 的行为（set\\_new\\_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）\n50. 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）\n51. 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）\n52. 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）\n53. 不要轻忽编译器的警告\n54. 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）\n55. 让自己熟悉 Boost（准标准库）\n\n### More Effective c++\n\n1. 仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）\n2. 最好使用 C++ 转型操作符（`static_cast`、`const_cast`、`dynamic_cast`、`reinterpret_cast`）\n3. 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）\n4. 非必要不提供 default constructor（避免对象中的字段被无意义地初始化）\n5. 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）\n6. 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）\n7. 千万不要重载 `&&`，`||` 和 `,` 操作符（`&&` 与 `||` 的重载会用 “函数调用语义” 取代 “骤死式语义”；`,` 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）\n8. 了解各种不同意义的 new 和 delete（`new operator`、`operator new`、`placement new`、`operator new[]`；`delete operator`、`operator delete`、`destructor`、`operator delete[]`）\n9. 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）\n10. 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try...catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）\n11. 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）\n12. 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）\n13. 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）\n14. 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）\n15. 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）\n16. 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）\n17. 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）\n18. 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）\n\n### Google C++ Style Guide\n\n* 英文：[Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)\n* 中文：[C++ 风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)\n\n### 其他\n\n* [Bjarne Stroustrup 的常见问题](http://www.stroustrup.com/bs_faq.html)\n* [Bjarne Stroustrup 的 C++ 风格和技巧常见问题](http://www.stroustrup.com/bs_faq2.html)\n\n<a id="stl"></a>\n\n## 📦 STL\n\n### STL 索引\n\n[STL 方法含义索引](https://github.com/huihut/interview/tree/master/STL)\n\n### STL 容器\n\n容器 | 底层数据结构 | 时间复杂度 | 有无序 | 可不可重复 | 其他\n---|---|---|---|---|---\n[array](https://github.com/huihut/interview/tree/master/STL#array)|数组|随机读改 O(1)|无序|可重复|支持随机访问\n[vector](https://github.com/huihut/interview/tree/master/STL#vector)|数组|随机读改、尾部插入、尾部删除 O(1)<br/>头部插入、头部删除 O(n)|无序|可重复|支持随机访问\n[deque](https://github.com/huihut/interview/tree/master/STL#deque)|双端队列|头尾插入、头尾删除 O(1)|无序|可重复|一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问\n[forward_list](https://github.com/huihut/interview/tree/master/STL#forward_list)|单向链表|插入、删除 O(1)|无序|可重复|不支持随机访问\n[list](https://github.com/huihut/interview/tree/master/STL#list)|双向链表|插入、删除 O(1)|无序|可重复|不支持随机访问\n[stack](https://github.com/huihut/interview/tree/master/STL#stack)|deque / list|顶部插入、顶部删除 O(1)|无序|可重复|deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时\n[queue](https://github.com/huihut/interview/tree/master/STL#queue)|deque / list|尾部插入、头部删除 O(1)|无序|可重复|deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时\n[priority_queue](https://github.com/huihut/interview/tree/master/STL#priority_queue)|vector + max-heap|插入、删除 O(log<sub>2</sub>n)|有序|可重复|vector容器+heap处理规则\n[set](https://github.com/huihut/interview/tree/master/STL#set)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|不可重复|\n[multiset](https://github.com/huihut/interview/tree/master/STL#multiset)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|可重复|\n[map](https://github.com/huihut/interview/tree/master/STL#map)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|不可重复|\n[multimap](https://github.com/huihut/interview/tree/master/STL#multimap)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|可重复|\n[unordered_set](https://github.com/huihut/interview/tree/master/STL#unordered_set)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|不可重复|\n[unordered_multiset](https://github.com/huihut/interview/tree/master/STL#unordered_multiset)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|可重复|\n[unordered_map](https://github.com/huihut/interview/tree/master/STL#unordered_map)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|不可重复|\n[unordered_multimap](https://github.com/huihut/interview/tree/master/STL#unordered_multimap)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|可重复|\n\n### STL 算法\n\n算法 | 底层算法 | 时间复杂度 | 可不可重复\n---|---|---|---\n[find](http://www.cplusplus.com/reference/algorithm/find/)|顺序查找|O(n)|可重复\n[sort](https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808)|[内省排序](https://en.wikipedia.org/wiki/Introsort)|O(n*log<sub>2</sub>n)|可重复\n\n\n<a id="data-structure"></a>\n\n## 〽️ 数据结构\n\n### 顺序结构\n\n#### 顺序栈（Sequence Stack）\n\n[SqStack.cpp](DataStructure/SqStack.cpp)\n\n顺序栈数据结构和图片\n\n```cpp\ntypedef struct {\n\tElemType *elem;\n\tint top;\n\tint size;\n\tint increment;\n} SqStack;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqStack.png)\n\n#### 队列（Sequence Queue）\n\n队列数据结构\n\n```cpp\ntypedef struct {\n\tElemType * elem;\n\tint front;\n\tint rear;\n\tint maxSize;\n}SqQueue;\n```\n\n##### 非循环队列\n\n非循环队列图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqQueue.png)\n\n`SqQueue.rear++`\n\n##### 循环队列\n\n循环队列图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqLoopStack.png)\n\n`SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize`\n\n#### 顺序表（Sequence List）\n\n[SqList.cpp](DataStructure/SqList.cpp)\n\n顺序表数据结构和图片\n\n```cpp\ntypedef struct {\n\tElemType *elem;\n\tint length;\n\tint size;\n\tint increment;\n} SqList;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqList.png)\n\n\n### 链式结构\n\n[LinkList.cpp](DataStructure/LinkList.cpp)\n\n[LinkList_with_head.cpp](DataStructure/LinkList_with_head.cpp)\n\n链式数据结构\n\n```cpp\ntypedef struct LNode {\n    ElemType data;\n    struct LNode *next;\n} LNode, *LinkList; \n```\n\n#### 链队列（Link Queue）\n\n链队列图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/LinkQueue.png)\n\n#### 线性表的链式表示\n\n##### 单链表（Link List）\n\n单链表图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/LinkList.png)\n\n##### 双向链表（Du-Link-List）\n\n双向链表图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/DuLinkList.png)\n\n##### 循环链表（Cir-Link-List）\n\n循环链表图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/CirLinkList.png)\n\n### 哈希表\n\n[HashTable.cpp](DataStructure/HashTable.cpp)\n\n#### 概念\n\n哈希函数：`H(key): K -> D , key ∈ K`\n\n#### 构造方法\n\n* 直接定址法\n* 除留余数法\n* 数字分析法\n* 折叠法\n* 平方取中法\n\n#### 冲突处理方法\n\n* 链地址法：key 相同的用单链表链接\n* 开放定址法\n    * 线性探测法：key 相同 -> 放到 key 的下一个位置，`Hi = (H(key) + i) % m`\n    * 二次探测法：key 相同 -> 放到 `Di = 1^2, -1^2, ..., ±（k)^2,(k<=m/2）`\n    * 随机探测法：`H = (H(key) + 伪随机数) % m`\n\n#### 线性探测的哈希表数据结构\n\n线性探测的哈希表数据结构和图片\n\n```cpp\ntypedef char KeyType;\n\ntypedef struct {\n\tKeyType key;\n}RcdType;\n\ntypedef struct {\n\tRcdType *rcd;\n\tint size;\n\tint count;\n\tbool *tag;\n}HashTable;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/HashTable.png)\n\n### 递归\n\n#### 概念\n\n函数直接或间接地调用自身\n\n#### 递归与分治\n\n* 分治法\n    * 问题的分解\n    * 问题规模的分解\n* 折半查找（递归）\n* 归并排序（递归）\n* 快速排序（递归）\n\n#### 递归与迭代\n\n* 迭代：反复利用变量旧值推出新值\n* 折半查找（迭代）\n* 归并排序（迭代）\n\n#### 广义表\n\n##### 头尾链表存储表示\n\n广义表的头尾链表存储表示和图片\n\n```cpp\n// 广义表的头尾链表存储表示\ntypedef enum {ATOM, LIST} ElemTag;\n// ATOM==0：原子，LIST==1：子表\ntypedef struct GLNode {\n    ElemTag tag;\n    // 公共部分，用于区分原子结点和表结点\n    union {\n        // 原子结点和表结点的联合部分\n        AtomType atom;\n        // atom 是原子结点的值域，AtomType 由用户定义\n        struct {\n            struct GLNode *hp, *tp;\n        } ptr;\n        // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾\n    } a;\n} *GList, GLNode;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/GeneralizedList1.png)\n\n##### 扩展线性链表存储表示\n\n扩展线性链表存储表示和图片\n\n```cpp\n// 广义表的扩展线性链表存储表示\ntypedef enum {ATOM, LIST} ElemTag;\n// ATOM==0：原子，LIST==1：子表\ntypedef struct GLNode1 {\n    ElemTag tag;\n    // 公共部分，用于区分原子结点和表结点\n    union {\n        // 原子结点和表结点的联合部分\n        AtomType atom; // 原子结点的值域\n        struct GLNode1 *hp; // 表结点的表头指针\n    } a;\n    struct GLNode1 *tp;\n    // 相当于线性链表的 next，指向下一个元素结点\n} *GList1, GLNode1;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/GeneralizedList2.png)\n\n### 二叉树\n\n[BinaryTree.cpp](DataStructure/BinaryTree.cpp)\n\n#### 性质\n\n1. 非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i >= 1）\n2. 深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k >= 1）\n3. 度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1\n4. 有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1 \n5. 对于含 n 个结点的完全二叉树中编号为 i （1 <= i <= n） 的结点\n    1. 若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋\n    2. 若 2i > n，则 i 结点没有左孩子，否则孩子编号为 2i\n    3. 若 2i + 1 > n，则 i 结点没有右孩子，否则孩子编号为 2i + 1\n\n#### 存储结构\n\n二叉树数据结构\n\n```cpp\ntypedef struct BiTNode\n{\n    TElemType data;\n    struct BiTNode *lchild, *rchild;\n}BiTNode, *BiTree;\n```\n\n##### 顺序存储\n\n二叉树顺序存储图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqBinaryTree.png)\n\n##### 链式存储\n\n二叉树链式存储图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/LinkBinaryTree.png)\n\n#### 遍历方式\n\n* 先序遍历\n* 中序遍历\n* 后续遍历\n* 层次遍历\n\n#### 分类\n\n* 满二叉树\n* 完全二叉树（堆）\n    * 大顶堆：根 >= 左 && 根 >= 右\n    * 小顶堆：根 <= 左 && 根 <= 右\n* 二叉查找树（二叉排序树）：左 < 根 < 右\n* 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | <= 1\n* 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：\n    * LL型：根的左孩子右旋\n    * RR型：根的右孩子左旋\n    * LR型：根的左孩子左旋，再右旋\n    * RL型：右孩子的左子树，先右旋，再左旋\n\n### 其他树及森林\n\n#### 树的存储结构\n\n* 双亲表示法\n* 双亲孩子表示法\n* 孩子兄弟表示法\n\n#### 并查集\n\n一种不相交的子集所构成的集合 S = {S1, S2, ..., Sn}\n\n#### 平衡二叉树（AVL树）\n\n##### 性质\n\n* | 左子树树高 - 右子树树高 | <= 1\n* 平衡二叉树必定是二叉搜索树，反之则不一定\n* 最小二叉平衡树的节点的公式：`F(n)=F(n-1)+F(n-2)+1` （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）\n\n平衡二叉树图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/Self-balancingBinarySearchTree.png)\n\n##### 最小失衡树\n\n平衡二叉树插入新结点导致失衡的子树\n\n调整：\n\n* LL 型：根的左孩子右旋\n* RR 型：根的右孩子左旋\n* LR 型：根的左孩子左旋，再右旋\n* RL 型：右孩子的左子树，先右旋，再左旋\n\n#### 红黑树\n\n[RedBlackTree.cpp](DataStructure/RedBlackTree.cpp)\n\n##### 红黑树的特征是什么？\n\n1. 节点是红色或黑色。\n2. 根是黑色。\n3. 所有叶子都是黑色（叶子是 NIL 节点）。\n4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）\n5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）\n\n##### 调整\n\n1. 变色\n2. 左旋\n3. 右旋\n\n##### 应用\n\n* 关联数组：如 STL 中的 map、set\n\n##### 红黑树、B 树、B+ 树的区别？\n\n* 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些\n* B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。\n\n#### B 树（B-tree）、B+ 树（B+-tree）\n\nB 树、B+ 树图片\n\n![B 树（B-tree）、B+ 树（B+-tree）](https://i.stack.imgur.com/l6UyF.png)\n\n##### 特点\n\n* 一般化的二叉查找树（binary search tree）\n* “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）\n\n##### 应用\n\n* 大部分文件系统、数据库系统都采用B树、B+树作为索引结构\n\n##### 区别\n\n* B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。\n* B+树中所有叶子节点都是通过指针连接在一起，而B树不会。\n\n##### B树的优点\n\n对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。\n\n##### B+树的优点\n\n* 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。\n* 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。\n\n> B 树、B+ 树区别来自：[differences-between-b-trees-and-b-trees](https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees)、[B树和B+树的区别](https://www.cnblogs.com/ivictor/p/5849061.html)\n\n#### 八叉树\n\n八叉树图片\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png)\n\n八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。\n\n##### 用途\n\n* 三维计算机图形\n* 最邻近搜索\n\n<a id="algorithm"></a>\n\n## ⚡️ 算法\n\n### 排序\n\n排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性\n---|---|---|---|---\n[冒泡排序](Algorithm/BubbleSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定\n[选择排序](Algorithm/SelectionSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|数组不稳定、链表稳定\n[插入排序](Algorithm/InsertSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定\n[快速排序](Algorithm/QuickSort.h) | O(n*log<sub>2</sub>n) |  O(n<sup>2</sup>) | O(log<sub>2</sub>n) | 不稳定\n[堆排序](Algorithm/HeapSort.cpp) | O(n*log<sub>2</sub>n)|O(n*log<sub>2</sub>n)|O(1)|不稳定\n[归并排序](Algorithm/MergeSort.h) | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n)|O(n)|稳定\n[希尔排序](Algorithm/ShellSort.h) | O(n*log<sup>2</sup>n)|O(n<sup>2</sup>)|O(1)|不稳定\n[计数排序](Algorithm/CountSort.cpp) | O(n+m)|O(n+m)|O(n+m)|稳定\n[桶排序](Algorithm/BucketSort.cpp) | O(n)|O(n)|O(m)|稳定\n[基数排序](Algorithm/RadixSort.h) | O(k*n)|O(n<sup>2</sup>)| |稳定\n\n> * 均按从小到大排列\n> * k：代表数值中的 “数位” 个数\n> * n：代表数据规模\n> * m：代表数据的最大值减最小值\n> * 来自：[wikipedia . 排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)\n\n### 查找\n\n查找算法 | 平均时间复杂度 | 空间复杂度 | 查找条件\n---|---|---|---\n[顺序查找](Algorithm/SequentialSearch.h) | O(n) | O(1) | 无序或有序\n[二分查找（折半查找）](Algorithm/BinarySearch.h) | O(log<sub>2</sub>n)| O(1) | 有序\n[插值查找](Algorithm/InsertionSearch.h) | O(log<sub>2</sub>(log<sub>2</sub>n)) | O(1) | 有序\n[斐波那契查找](Algorithm/FibonacciSearch.cpp) | O(log<sub>2</sub>n) | O(1) | 有序\n[哈希查找](DataStructure/HashTable.cpp) | O(1) | O(n) | 无序或有序\n[二叉查找树（二叉搜索树查找）](Algorithm/BSTSearch.h) |O(log<sub>2</sub>n) |   | \n[红黑树](DataStructure/RedBlackTree.cpp) |O(log<sub>2</sub>n) | |\n2-3树 | O(log<sub>2</sub>n - log<sub>3</sub>n) |   | \nB树/B+树 |O(log<sub>2</sub>n) |   | \n\n### 图搜索算法\n\n图搜索算法 |数据结构| 遍历时间复杂度 | 空间复杂度\n---|---|---|---\n[BFS广度优先搜索](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵<br/>邻接链表|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)\n[DFS深度优先搜索](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵<br/>邻接链表|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)\n\n### 其他算法\n\n算法 |思想| 应用\n---|---|---\n[分治法](https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95)|把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并|[循环赛日程安排问题](https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem)、排序算法（快速排序、归并排序）\n[动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)|通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题|[背包问题](https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem)、斐波那契数列\n[贪心法](https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95)|一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法|旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码\n\n<a id="problems"></a>\n\n## ❓ Problems\n\n### Single Problem\n\n* [Chessboard Coverage Problem（棋盘覆盖问题）](Problems/ChessboardCoverageProblem)\n* [Knapsack Problem（背包问题）](Problems/KnapsackProblem)\n* [Neumann Neighbor Problem（冯诺依曼邻居问题）](Problems/NeumannNeighborProblem)\n* [Round Robin Problem（循环赛日程安排问题）](Problems/RoundRobinProblem)\n* [Tubing Problem（输油管道问题）](Problems/TubingProblem)\n\n### Leetcode Problems\n\n* [Github . haoel/leetcode](https://github.com/haoel/leetcode)\n* [Github . pezy/LeetCode](https://github.com/pezy/LeetCode)\n\n### 剑指 Offer\n\n* [Github . zhedahht/CodingInterviewChinese2](https://github.com/zhedahht/CodingInterviewChinese2)\n* [Github . gatieme/CodingInterviews](https://github.com/gatieme/CodingInterviews)\n\n### Cracking the Coding Interview 程序员面试金典\n\n* [Github . careercup/ctci](https://github.com/careercup/ctci)\n* [牛客网 . 程序员面试金典](https://www.nowcoder.com/ta/cracking-the-coding-interview)\n\n### 牛客网\n\n* [牛客网 . 在线编程专题](https://www.nowcoder.com/activity/oj)\n\n<a id="os"></a>\n\n## 💻 操作系统\n\n### 进程与线程\n\n对于有线程系统：\n* 进程是资源分配的独立单位\n* 线程是资源调度的独立单位\n\n对于无线程系统：\n* 进程是资源调度、分配的独立单位\n\n#### 进程之间的通信方式以及优缺点\n\n* 管道（PIPE）\n    * 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信\n        * 优点：可以实现任意关系的进程间的通信\n        * 缺点：\n            1. 长期存于系统中，使用不当容易出错\n            2. 缓冲区有限\n    * 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）\n        * 优点：简单方便\n        * 缺点：\n            1. 局限于单向通信 \n            2. 只能创建在它的进程以及其有亲缘关系的进程之间\n            3. 缓冲区有限\n* 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问\n    * 优点：可以同步进程\n    * 缺点：信号量有限\n* 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生\n* 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识\n    * 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便\n    * 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合\n* 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问\n    * 优点：无须复制，快捷，信息量大\n    * 缺点：\n        1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题\n        2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信\n* 套接字（Socket）：可用于不同计算机间的进程通信\n    * 优点：\n        1. 传输数据为字节级，传输数据可自定义，数据量小效率高\n        2. 传输数据时间短，性能高\n        3. 适合于客户端和服务器端之间信息实时交互\n        4. 可以加密,数据安全性强\n    * 缺点：需对传输的数据进行解析，转化成应用级的数据。\n\n#### 线程之间的通信方式\n\n* 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）\n    * 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。\n    * 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。\n    * 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。\n    * 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n* 信号量机制(Semaphore)\n    * 无名线程信号量\n    * 命名线程信号量\n* 信号机制(Signal)：类似进程间的信号处理\n* 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。\n\n线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  \n\n> 进程之间的通信方式以及优缺点来源于：[进程线程面试题总结](http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977)\n\n#### 进程之间私有和共享的资源\n\n* 私有：地址空间、堆、全局变量、栈、寄存器\n* 共享：代码段，公共数据，进程目录，进程 ID\n\n#### 线程之间私有和共享的资源\n\n* 私有：线程栈，寄存器，程序计数器\n* 共享：堆，地址空间，全局变量，静态变量\n\n#### 多进程与多线程间的对比、优劣与选择\n\n##### 对比\n\n对比维度 | 多进程 | 多线程 | 总结\n---|---|---|---\n数据共享、同步|数据共享复杂，需要用 IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有优势\n内存、CPU|占用内存多，切换复杂，CPU 利用率低|占用内存少，切换简单，CPU 利用率高|线程占优\n创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程占优\n编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程占优\n可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程占优\n分布式|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程占优\n\n##### 优劣\n\n优劣|多进程|多线程\n---|---|---\n优点|编程、调试简单，可靠性较高|创建、销毁、切换速度快，内存、资源占用小\n缺点|创建、销毁、切换速度慢，内存、资源占用大|编程、调试复杂，可靠性较差\n\n##### 选择\n\n* 需要频繁创建销毁的优先用线程\n* 需要进行大量计算的优先使用线程\n* 强相关的处理用线程，弱相关的处理用进程\n* 可能要扩展到多机分布的用进程，多核分布的用线程\n* 都满足需求的情况下，用你最熟悉、最拿手的方式\n\n> 多进程与多线程间的对比、优劣与选择来自：[多线程还是多进程的选择及区别](https://blog.csdn.net/lishenglong666/article/details/8557215)\n\n### Linux 内核的同步方式\n\n#### 原因\n\n在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。\n\n#### 同步方式\n\n* 原子操作\n* 信号量（semaphore）\n* 读写信号量（rw_semaphore）\n* 自旋锁（spinlock）\n* 大内核锁（BKL，Big Kernel Lock）\n* 读写锁（rwlock）\n* 大读者锁（brlock-Big Reader Lock）\n* 读-拷贝修改(RCU，Read-Copy Update)\n* 顺序锁（seqlock）\n\n> 来自：[Linux 内核的同步机制，第 1 部分](https://www.ibm.com/developerworks/cn/linux/l-synch/part1/)、[Linux 内核的同步机制，第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-synch/part2/)\n\n### 死锁\n\n#### 原因\n\n* 系统资源不足\n* 资源分配不当\n* 进程运行推进顺序不合适\n\n#### 产生条件\n\n* 互斥\n* 请求和保持\n* 不剥夺\n* 环路\n\n#### 预防\n\n* 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。\n* 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。\n* 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。\n* 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。\n* 有序资源分配法\n* 银行家算法\n\n### 文件系统\n\n* Windows：FCB 表 + FAT + 位图\n* Unix：inode + 混合索引 + 成组链接\n\n### 主机字节序与网络字节序\n\n#### 主机字节序（CPU 字节序）\n\n##### 概念\n\n主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：\n\n* 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址\n* 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址\n\n##### 存储方式\n\n32 位整数 `0x12345678` 是从起始位置为 `0x00` 的地址开始存放，则：\n\n内存地址 | 0x00 | 0x01 | 0x02 | 0x03\n---|---|---|---|---\n大端|12|34|56|78\n小端|78|56|34|12\n\n大端小端图片\n\n![大端序](https://gitee.com/huihut/interview/raw/master/images/CPU-Big-Endian.svg.png)\n![小端序](https://gitee.com/huihut/interview/raw/master/images/CPU-Little-Endian.svg.png)\n\n##### 判断大端小端\n\n判断大端小端\n\n可以这样判断自己 CPU 字节序是大端还是小端：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint i = 0x12345678;\n\n\tif (*((char*)&i) == 0x12)\n\t\tcout << "大端" << endl;\n\telse\t\n\t\tcout << "小端" << endl;\n\n\treturn 0;\n}\n```\n\n##### 各架构处理器的字节序\n\n* x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；\n* Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；\n* ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。\n\n#### 网络字节序\n\n网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。\n\n网络字节顺序采用：大端（Big Endian）排列方式。\n\n### 页面置换算法\n\n在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。\n\n#### 分类\n\n* 全局置换：在整个内存空间置换\n* 局部置换：在本进程中进行置换\n\n#### 算法\n\n全局：\n* 工作集算法\n* 缺页率置换算法\n\n局部：\n* 最佳置换算法（OPT）\n* 先进先出置换算法（FIFO）\n* 最近最久未使用（LRU）算法\n* 时钟（Clock）置换算法\n\n<a id="computer-network"></a>\n\n## ☁️ 计算机网络\n\n> 本节部分知识点来自《计算机网络（第 7 版）》\n\n计算机网络体系结构：\n\n![计算机网络体系结构](https://gitee.com/huihut/interview/raw/master/images/计算机网络体系结构.png)\n\n### 各层作用及协议\n\n分层 | 作用 | 协议\n---|---|---\n物理层 | 通过媒介传输比特，确定机械及电气规范（比特 Bit） | RJ45、CLOCK、IEEE802.3（中继器，集线器）\n数据链路层|将比特组装成帧和点到点的传递（帧 Frame）| PPP、FR、HDLC、VLAN、MAC（网桥，交换机）\n网络层|负责数据包从源到宿的传递和网际互连（包 Packet）|IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）\n运输层|提供端到端的可靠报文传递和错误恢复（ 段Segment）|TCP、UDP、SPX\n会话层|建立、管理和终止会话（会话协议数据单元 SPDU）|NFS、SQL、NETBIOS、RPC\n表示层|对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）|JPEG、MPEG、ASII\n应用层|允许访问OSI环境的手段（应用协议数据单元 APDU）|FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n\n\n### 物理层\n\n* 传输数据的单位：比特\n* 数据传输系统：源系统（源点、发送器） --> 传输系统 --> 目的系统（接收器、终点）\n\n通道：\n* 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播\n* 双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收\n* 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息\n\n通道复用技术：\n* 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源\n* 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度\n* 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用\n* 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信\n\n### 数据链路层\n\n主要信道：\n* 点对点信道\n* 广播信道\n\n#### 点对点信道\n\n* 数据单元：帧\n\n三个基本问题：\n* 封装成帧：把网络层的 IP 数据报封装成帧，`SOH - 数据部分 - EOT`\n* 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）\n* 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）\n\n点对点协议（Point-to-Point Protocol）：\n* 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议\n\n#### 广播信道\n\n广播通信：\n* 硬件地址（物理地址、MAC 地址）\n* 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同\n* 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧\n* 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧\n\n### 网络层\n\n* IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。\n* ARP（Address Resolution Protocol，地址解析协议）\n* ICMP（Internet Control Message Protocol，网际控制报文协议）\n* IGMP（Internet Group Management Protocol，网际组管理协议）\n\n#### IP 网际协议\n\nIP 地址分类：\n* `IP 地址 ::= {<网络号>,<主机号>}`\n\nIP 地址类别 | 网络号 | 网络范围 | 主机号 | IP 地址范围\n---|---|---|---|---\nA 类 | 8bit，第一位固定为 0 | 0 —— 127 | 24bit | 1.0.0.0 —— 127.255.255.255\nB 类 | 16bit，前两位固定为  10 | 128.0 —— 191.255 | 16bit | 128.0.0.0 —— 191.255.255.255\nC  类 | 24bit，前三位固定为  110 | 192.0.0 —— 223.255.255 | 8bit | 192.0.0.0 —— 223.255.255.255\nD  类 | 前四位固定为 1110，后面为多播地址\nE  类 | 前五位固定为 11110，后面保留为今后所用\n\nIP 数据报格式：\n\n![IP 数据报格式](https://gitee.com/huihut/interview/raw/master/images/IP数据报格式.png)\n\n#### ICMP 网际控制报文协议\n\nICMP 报文格式：\n\n![ICMP 报文格式](https://gitee.com/huihut/interview/raw/master/images/ICMP报文格式.png)\n\n应用：\n* PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性\n* TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量\n\n#### 内部网关协议\n\n* RIP（Routing Information Protocol，路由信息协议）\n* OSPF（Open Sortest Path First，开放最短路径优先）\n\n#### 外部网关协议\n\n* BGP（Border Gateway Protocol，边界网关协议）\n\n#### IP多播\n\n* IGMP（Internet Group Management Protocol，网际组管理协议）\n* 多播路由选择协议\n\n#### VPN 和 NAT\n\n* VPN（Virtual Private Network，虚拟专用网）\n* NAT（Network Address Translation，网络地址转换）\n\n#### 路由表包含什么？\n\n1. 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。\n2. 子网掩码（subnet mask）：用来判断 IP 所属网络\n3. 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: `0.0.0.0`, Netmask: `0.0.0.0`）指向自治系统的出口。\n\n根据应用和执行的不同，路由表可能含有如下附加信息：\n\n1. 花费（Cost）：就是数据发送过程中通过路径所需要的花费。\n2. 路由的服务质量\n3. 路由中需要过滤的出/入连接列表\n\n### 运输层\n\n协议：\n\n* TCP（Transmission Control Protocol，传输控制协议）\n* UDP（User Datagram Protocol，用户数据报协议）\n\n端口：\n\n应用程序 | FTP | TELNET | SMTP | DNS | TFTP | HTTP | HTTPS | SNMP  \n--- | --- | --- |--- |--- |--- |--- |--- |---   \n端口号 | 21 | 23 | 25 | 53 | 69 | 80 | 443 | 161  \n\n#### TCP\n\n* TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。\n\n特征：\n* 面向连接\n* 只能点对点（一对一）通信\n* 可靠交互\n* 全双工通信\n* 面向字节流\n\nTCP 如何保证可靠传输：\n* 确认和超时重传\n* 数据合理分片和排序\n* 流量控制\n* 拥塞控制\n* 数据校验\n\nTCP 报文结构\n\n![TCP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP报文.png)\n\nTCP 首部\n\n![TCP 首部](https://gitee.com/huihut/interview/raw/master/images/TCP首部.png)\n\nTCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：\n* URG：紧急比特（urgent），当 `URG＝1` 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。\n* ACK：确认比特（Acknowledge）。只有当 `ACK＝1` 时确认号字段才有效，代表这个封包为确认封包。当 `ACK＝0` 时，确认号无效。\n* PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。\n* RST：复位比特(Reset)，当 `RST＝1` 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。\n* SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。\n* FIN：终止比特(Final)，用来释放一个连接。当 `FIN＝1` 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。\n\n#### UDP\n\n* UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。\n\n特征：\n* 无连接\n* 尽最大努力交付\n* 面向报文\n* 没有拥塞控制\n* 支持一对一、一对多、多对一、多对多的交互通信\n* 首部开销小\n\nUDP 报文结构\n\n![UDP 报文](https://gitee.com/huihut/interview/raw/master/images/UDP报文.png)\n\nUDP 首部\n\n![UDP 首部](https://gitee.com/huihut/interview/raw/master/images/UDP首部.png)\n\n> TCP/UDP 图片来源于：<https://github.com/JerryC8080/understand-tcp-udp>\n\n#### TCP 与 UDP 的区别\n\n1. TCP 面向连接，UDP 是无连接的；\n2. TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付\n3. TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道\n5. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信\n6. TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）\n7. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）\n8. TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节\n\n#### TCP 黏包问题\n\n##### 原因\n\nTCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。\n\n##### 解决\n\n* 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。\n* 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。\n* 在数据包之间设置边界，如添加特殊符号 `\\r\\n` 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 `\\r\\n`，则会误判为消息的边界。\n* 使用更加复杂的应用层协议。\n\n#### TCP 流量控制\n\n##### 概念\n\n流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。\n\n##### 方法\n\n利用可变窗口进行流量控制\n\n![](https://gitee.com/huihut/interview/raw/master/images/利用可变窗口进行流量控制举例.png)\n\n#### TCP 拥塞控制\n\n##### 概念\n\n拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\n\n##### 方法\n\n* 慢开始( slow-start )\n* 拥塞避免( congestion avoidance )\n* 快重传( fast retransmit )\n* 快恢复( fast recovery )\n\nTCP的拥塞控制图\n\n![](https://gitee.com/huihut/interview/raw/master/images/TCP拥塞窗口cwnd在拥塞控制时的变化情况.png)\n![](https://gitee.com/huihut/interview/raw/master/images/快重传示意图.png)\n![](https://gitee.com/huihut/interview/raw/master/images/TCP的拥塞控制流程图.png)\n\n#### TCP 传输连接管理\n\n> 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png>\n\n##### TCP 三次握手建立连接\n\n![UDP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP三次握手建立连接.png)\n\n【TCP 建立连接全过程解释】\n\n1. 客户端发送 SYN 给服务器，说明客户端请求建立连接；\n2. 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；\n3. 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；\n4. 服务端收到客户端的 ACK，连接已建立，可以数据传输。\n\n##### TCP 为什么要进行三次握手？\n\n【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）\n\n> [Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}](https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ)\n\n【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。\n\n> [知乎 . TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633/answer/115173386)\n\n【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n\n> [《计算机网络（第 7 版）-谢希仁》](https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png)\n\n##### TCP 四次挥手释放连接\n\n![UDP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP四次挥手释放连接.png)\n\n【TCP 释放连接全过程解释】\n\n1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；\n2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；\n3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；\n4. 服务端继续发送之前没发完的数据给客户端；\n5. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；\n6. 客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；\n7. 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。\n\n##### TCP 为什么要进行四次挥手？\n\n【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？\n\n【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。\n\n【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）\n\n【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。\n\n【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？\n\n【答案三】\n\n1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。\n2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。\n\n#### TCP 有限状态机\n\nTCP 有限状态机图片\n\n![TCP 的有限状态机](https://gitee.com/huihut/interview/raw/master/images/TCP的有限状态机.png)\n\n### 应用层\n\n#### DNS\n\n* DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。\n\n域名：\n* `域名 ::= {<三级域名>.<二级域名>.<顶级域名>}`，如：`blog.huihut.com`\n\n#### FTP\n\n* FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。\n* TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定\n\n#### TELNET\n\n* TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。\n\n* HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。\n\n* SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。\n* Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。\n\n#### WWW\n\n* WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问\n\n##### URL\n\n* URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）\n\n标准格式：\n\n* `协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]`\n    \n完整格式：\n\n* `协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]`\n\n> 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项  \n> 如：`https://github.com/huihut/interview#cc`\n\n##### HTTP\n\nHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。\n\n请求方法\n\n方法 | 意义\n--- | ---\nOPTIONS | 请求一些选项信息，允许客户端查看服务器的性能\nGET | 请求指定的页面信息，并返回实体主体\nHEAD | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头\nPOST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改\nPUT | 从客户端向服务器传送的数据取代指定的文档的内容\nDELETE | 请求服务器删除指定的页面\nTRACE | 回显服务器收到的请求，主要用于测试或诊断\n\n状态码（Status-Code）\n\n* 1xx：表示通知信息，如请求收到了或正在进行处理\n    * 100 Continue：继续，客户端应继续其请求\n    * 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议\n* 2xx：表示成功，如接收或知道了\n    * 200 OK: 请求成功\n* 3xx：表示重定向，如要完成请求还必须采取进一步的行动\n    * 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替\n* 4xx：表示客户的差错，如请求中有错误的语法或不能完成\n    * 400 Bad Request: 客户端请求的语法错误，服务器无法理解\n    * 401 Unauthorized: 请求要求用户的身份认证\n    * 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）\n    * 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面\n    * 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时\n* 5xx：表示服务器的差错，如服务器失效无法完成请求\n    * 500 Internal Server Error: 服务器内部错误，无法完成请求\n    * 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中\n    * 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求\n\n> 更多状态码：[菜鸟教程 . HTTP状态码](http://www.runoob.com/http/http-status-codes.html)\n\n##### 其他协议\n\n* SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。\n* DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：\n    * 用于内部网络或网络服务供应商自动分配 IP 地址给用户\n    * 用于内部网络管理员作为对所有电脑作中央管理的手段\n* SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。\n\n<a id="network-programming"></a>\n\n## 🌩 网络编程\n\n### Socket\n\n> [Linux Socket 编程（不限 Linux）](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)\n\n![Socket 客户端服务器通讯](https://gitee.com/huihut/interview/raw/master/images/socket客户端服务器通讯.jpg)\n\n\n#### Socket 中的 read()、write() 函数\n\n```cpp\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n##### read()\n\n* read 函数是负责从 fd 中读取内容。\n* 当读成功时，read 返回实际所读的字节数。\n* 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。\n* 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。\n\n##### write()\n\n* write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。\n* 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。\n* 在网络程序中，当我们向套接字文件描述符写时有俩种可能。\n* （1）write 的返回值大于 0，表示写了部分或者是全部的数据。\n* （2）返回的值小于 0，此时出现了错误。\n* 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。\n\n#### Socket 中 TCP 的三次握手建立连接\n\n我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：\n\n1. 客户端向服务器发送一个 SYN J\n2. 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1\n3. 客户端再想服务器发一个确认 ACK K+1\n\n只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：\n\n![socket 中发送的 TCP 三次握手](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png)\n\n从图中可以看出：\n1. 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  \n2. 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  \n3. 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  \n4. 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。\n\n#### Socket 中 TCP 的四次握手释放连接\n\n上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：\n\n![socket 中发送的 TCP 四次握手](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png)\n\n图示过程如下：\n\n1. 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；\n2. 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；\n3. 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；\n4. 接收到这个 FIN 的源发送端 TCP 对它进行确认。\n\n这样每个方向上都有一个 FIN 和 ACK。\n\n<a id="database"></a>\n\n## 💾 数据库\n\n> 本节部分知识点来自《数据库系统概论（第 5 版）》\n\n### 基本概念\n\n* 数据（data）：描述事物的符号记录称为数据。\n* 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。\n* 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。\n* 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。\n* 实体（entity）：客观存在并可相互区别的事物称为实体。\n* 属性（attribute）：实体所具有的某一特性称为属性。\n* 码（key）：唯一标识实体的属性集称为码。\n* 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。\n* 实体集（entity set）：同一实体型的集合称为实体集。\n* 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。\n* 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n* 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。\n* 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。\n\n### 常用数据模型\n\n* 层次模型（hierarchical model）\n* 网状模型（network model）\n* 关系模型（relational model）\n    * 关系（relation）：一个关系对应通常说的一张表\n    * 元组（tuple）：表中的一行即为一个元组\n    * 属性（attribute）：表中的一列即为一个属性\n    * 码（key）：表中可以唯一确定一个元组的某个属性组\n    * 域（domain）：一组具有相同数据类型的值的集合\n    * 分量：元组中的一个属性值\n    * 关系模式：对关系的描述，一般表示为 `关系名(属性1, 属性2, ..., 属性n)`\n* 面向对象数据模型（object oriented data model）\n* 对象关系数据模型（object relational data model）\n* 半结构化数据模型（semistructure data model）\n\n### 常用 SQL 操作\n\n<table>\n  <tr>\n    <th>对象类型</th>\n    <th>对象</th>\n    <th>操作类型</th>\n  </tr>\n  <tr>\n    <td rowspan="4">数据库模式</td>\n    <td>模式</td>\n    <td><code>CREATE SCHEMA</code></td>\n  </tr>\n  <tr>\n    <td>基本表</td>\n    <td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code></td>\n  </tr>\n    <tr>\n    <td>视图</td>\n    <td><code>CREATE VIEW</code></td>\n  </tr>\n    <tr>\n    <td>索引</td>\n    <td><code>CREATE INDEX</code></td>\n  </tr>\n    <tr>\n    <td rowspan="2">数据</td>\n    <td>基本表和视图</td>\n    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>\n  </tr>\n    <tr>\n    <td>属性列</td>\n    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>\n  </tr>\n</table>\n\n> SQL 语法教程：[runoob . SQL 教程](http://www.runoob.com/sql/sql-tutorial.html)\n\n### 关系型数据库\n\n* 基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改\n* 关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性\n\n#### 索引\n\n* 数据库索引：顺序索引、B+ 树索引、hash 索引\n* [MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)\n\n### 数据库完整性\n\n* 数据库的完整性是指数据的正确性和相容性。\n    * 完整性：为了防止数据库中存在不符合语义（不正确）的数据。\n    * 安全性：为了保护数据库防止恶意破坏和非法存取。\n* 触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。\n\n### 关系数据理论\n\n* 数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。\n* 最重要的数据依赖：函数依赖、多值依赖。\n\n#### 范式\n\n* 第一范式（1NF）：属性（字段）是最小单位不可再分。\n* 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。\n* 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 非主属性对码的传递函数依赖）。\n* 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。\n* 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。\n\n### 数据库恢复\n\n* 事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。\n* 事物的 ACID 特性：原子性、一致性、隔离性、持续性。\n* 恢复的实现技术：建立冗余数据 -> 利用冗余数据实施数据库恢复。\n* 建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。\n\n### 并发控制\n\n* 事务是并发控制的基本单位。\n* 并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。\n* 并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。\n* 基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。\n* 活锁死锁：\n    * 活锁：事务永远处于等待状态，可通过先来先服务的策略避免。\n    * 死锁：事务永远不能结束\n        * 预防：一次封锁法、顺序封锁法；\n        * 诊断：超时法、等待图法；\n        * 解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。\n* 可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。\n\n<a id="design-pattern"></a>\n\n## 📏 设计模式\n\n> 各大设计模式例子参考：[CSDN专栏 . C++ 设计模式](https://blog.csdn.net/liang19890820/article/details/66974516) 系列博文\n\n[设计模式工程目录](DesignPattern)\n\n### 单例模式\n\n[单例模式例子](DesignPattern/SingletonPattern)\n\n### 抽象工厂模式\n\n[抽象工厂模式例子](DesignPattern/AbstractFactoryPattern)\n\n### 适配器模式\n\n[适配器模式例子](DesignPattern/AdapterPattern)\n\n### 桥接模式\n\n[桥接模式例子](DesignPattern/BridgePattern)\n\n### 观察者模式\n\n[观察者模式例子](DesignPattern/ObserverPattern)\n\n### 设计模式的六大原则\n\n* 单一职责原则（SRP，Single Responsibility Principle）\n* 里氏替换原则（LSP，Liskov Substitution Principle）\n* 依赖倒置原则（DIP，Dependence Inversion Principle）\n* 接口隔离原则（ISP，Interface Segregation Principle）\n* 迪米特法则（LoD，Law of Demeter）\n* 开放封闭原则（OCP，Open Close Principle）\n\n<a id="link-loading-library"></a>\n\n## ⚙️ 链接装载库\n\n> 本节部分知识点来自《程序员的自我修养——链接装载库》\n\n### 内存、栈、堆\n\n一般应用程序内存空间有如下区域：\n\n* 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文\n* 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域\n* 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里\n* 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据\n\n#### 栈\n\n栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：\n\n* 函数的返回地址和参数\n* 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量\n* 保存上下文：包括函数调用前后需要保持不变的寄存器\n\n#### 堆\n\n堆分配算法：\n\n* 空闲链表（Free List）\n* 位图（Bitmap）\n* 对象池\n\n#### “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”\n\n典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。\n\n普遍原因：\n\n* 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针\n* 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针\n\n### 编译链接\n\n#### 各平台文件格式\n\n平台 | 可执行文件 | 目标文件 | 动态库/共享对象 | 静态库\n---|---|---|---|---\nWindows|exe|obj|dll|lib\nUnix/Linux|ELF、out|o|so|a\nMac|Mach-O|o|dylib、tbd、framework|a、framework\n\n#### 编译链接过程\n\n1. 预编译（预编译器处理如 `#include`、`#define` 等预编译指令，生成 `.i` 或 `.ii` 文件）\n2. 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 `.s` 文件）\n3. 汇编（汇编器把汇编码翻译成机器码，生成 `.o` 文件）\n4. 链接（连接器进行地址和空间分配、符号决议、重定位，生成 `.out` 文件）\n\n> 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld\n\n> MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin\n\n#### 目标文件\n\n编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。\n\n> 可执行文件（Windows 的 `.exe` 和 Linux 的 `ELF`）、动态链接库（Windows 的 `.dll` 和 Linux 的 `.so`）、静态链接库（Windows 的 `.lib` 和 Linux 的 `.a`）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）\n\n##### 目标文件格式\n\n* Windows 的 PE（Portable Executable），或称为 PE-COFF，`.obj` 格式\n* Linux 的 ELF（Executable Linkable Format），`.o` 格式\n* Intel/Microsoft 的 OMF（Object Module Format）\n* Unix 的 `a.out` 格式\n* MS-DOS 的 `.COM` 格式\n\n> PE 和 ELF 都是 COFF（Common File Format）的变种\n\n##### 目标文件存储结构\n\n段 | 功能\n--- | ---\nFile Header | 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）\n.text section | 代码段，执行语句编译成的机器代码 \n.data section | 数据段，已初始化的全局变量和局部静态变量\n.bss section | BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）\n.rodata section | 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量\n.comment section | 注释信息段，存放编译器版本信息\n.note.GNU-stack section | 堆栈提示段 \n\n> 其他段略\n\n#### 链接的接口————符号\n\n在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。\n\n如下符号表（Symbol Table）：\n\nSymbol（符号名） | Symbol Value （地址）\n--- | ---\nmain| 0x100\nAdd | 0x123\n... | ...\n\n### Linux 的共享库（Shared Library）\n\nLinux 下的共享库就是普通的 ELF 共享对象。\n\n共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容\n\n#### 命名\n\n`libname.so.x.y.z`\n\n* x：主版本号，不同主版本号的库之间不兼容，需要重新编译\n* y：次版本号，高版本号向后兼容低版本号\n* z：发布版本号，不对接口进行更改，完全兼容\n\n#### 路径\n\n大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。\n\n* `/lib`：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等\n* `/usr/lib`：存放非系统运行时所需要的关键性的库，主要是开发库\n* `/usr/local/lib`：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库\n\n> 动态链接器会在 `/lib`、`/usr/lib` 和由 `/etc/ld.so.conf` 配置文件指定的，目录中查找共享库\n\n#### 环境变量\n\n* `LD_LIBRARY_PATH`：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序\n* `LD_PRELOAD`：指定预先装载的一些共享库甚至是目标文件\n* `LD_DEBUG`：打开动态链接器的调试功能\n\n#### so 共享库的编写\n\n使用 CLion 编写共享库\n\n创建一个名为 MySharedLib 的共享库\n\nCMakeLists.txt\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(MySharedLib)\n\nset(CMAKE_CXX_STANDARD 11)\n\nadd_library(MySharedLib SHARED library.cpp library.h)\n```\n\nlibrary.h\n\n```cpp\n#ifndef MYSHAREDLIB_LIBRARY_H\n#define MYSHAREDLIB_LIBRARY_H\n\n// 打印 Hello World!\nvoid hello();\n\n// 使用可变模版参数求和\ntemplate <typename T>\nT sum(T t)\n{\n    return t;\n}\ntemplate <typename T, typename ...Types>\nT sum(T first, Types ... rest)\n{\n    return first + sum<T>(rest...);\n}\n\n#endif\n```\n\nlibrary.cpp\n\n```cpp\n#include <iostream>\n#include "library.h"\n\nvoid hello() {\n    std::cout << "Hello, World!" << std::endl;\n}\n```\n\n#### so 共享库的使用（被可执行项目调用）\n\n使用 CLion 调用共享库\n\n创建一个名为 TestSharedLib 的可执行项目\n\nCMakeLists.txt\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(TestSharedLib)\n\n# C++11 编译\nset(CMAKE_CXX_STANDARD 11)\n\n# 头文件路径\nset(INC_DIR /home/xx/code/clion/MySharedLib)\n# 库文件路径\nset(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)\n\ninclude_directories(${INC_DIR})\nlink_directories(${LIB_DIR})\nlink_libraries(MySharedLib)\n\nadd_executable(TestSharedLib main.cpp)\n\n# 链接 MySharedLib 库\ntarget_link_libraries(TestSharedLib MySharedLib)\n```\n\nmain.cpp\n\n```cpp\n#include <iostream>\n#include "library.h"\nusing std::cout;\nusing std::endl;\n\nint main() {\n\n    hello();\n    cout << "1 + 2 = " << sum(1,2) << endl;\n    cout << "1 + 2 + 3 = " << sum(1,2,3) << endl;\n\n    return 0;\n}\n```\n\n执行结果\n\n```\nHello, World!\n1 + 2 = 3\n1 + 2 + 3 = 6\n```\n\n### Windows 应用程序入口函数\n\n* GUI（Graphical User Interface）应用，链接器选项：`/SUBSYSTEM:WINDOWS`\n* CUI（Console User Interface）应用，链接器选项：`/SUBSYSTEM:CONSOLE`\n\n_tWinMain 与 _tmain 函数声明\n\n```cpp\nInt WINAPI _tWinMain(\n    HINSTANCE hInstanceExe,\n    HINSTANCE,\n    PTSTR pszCmdLine,\n    int nCmdShow);\n\nint _tmain(\n    int argc,\n    TCHAR *argv[],\n    TCHAR *envp[]);\n```\n\n应用程序类型|入口点函数|嵌入可执行文件的启动函数\n---|---|---\n处理ANSI字符（串）的GUI应用程序|_tWinMain(WinMain)|WinMainCRTSartup\n处理Unicode字符（串）的GUI应用程序|_tWinMain(wWinMain)|wWinMainCRTSartup\n处理ANSI字符（串）的CUI应用程序|_tmain(Main)|mainCRTSartup\n处理Unicode字符（串）的CUI应用程序|_tmain(wMain)|wmainCRTSartup\n动态链接库（Dynamic-Link Library）|DllMain|_DllMainCRTStartup \n\n### Windows 的动态链接库（Dynamic-Link Library）\n\n> 部分知识点来自《Windows 核心编程（第五版）》\n\n#### 用处\n\n* 扩展了应用程序的特性\n* 简化了项目管理\n* 有助于节省内存\n* 促进了资源的共享\n* 促进了本地化\n* 有助于解决平台间的差异\n* 可以用于特殊目的\n\n#### 注意\n\n* 创建 DLL，事实上是在创建可供一个可执行模块调用的函数\n* 当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）\n* 在使用 C 和 C++ 混编的时候，要使用 extern "C" 修饰符\n* 一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）\n* DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前\n* 调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI\n\n#### 加载 Windows 程序的搜索顺序\n\n1. 包含可执行文件的目录\n2. Windows 的系统目录，可以通过 GetSystemDirectory 得到\n3. 16 位的系统目录，即 Windows 目录中的 System 子目录\n4. Windows 目录，可以通过 GetWindowsDirectory 得到\n5. 进程的当前目录\n6. PATH 环境变量中所列出的目录\n\n#### DLL 入口函数\n\nDllMain 函数\n\n```cpp\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    switch(fdwReason)\n    {\n    case DLL_PROCESS_ATTACH:\n        // 第一次将一个DLL映射到进程地址空间时调用\n        // The DLL is being mapped into the process\' address space.\n        break;\n    case DLL_THREAD_ATTACH:\n        // 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）\n        // A thread is bing created.\n        break;\n    case DLL_THREAD_DETACH:\n        // 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理\n        // A thread is exiting cleanly.\n        break;\n    case DLL_PROCESS_DETACH:\n        // 将一个DLL从进程的地址空间时调用\n        // The DLL is being unmapped from the process\' address space.\n        break;\n    }\n    return (TRUE); // Used only for DLL_PROCESS_ATTACH\n}\n```\n\n#### 载入卸载库\n\nLoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明\n\n```cpp\n// 载入库\nHMODULE WINAPI LoadLibrary(\n  _In_ LPCTSTR lpFileName\n);\nHMODULE LoadLibraryExA(\n  LPCSTR lpLibFileName,\n  HANDLE hFile,\n  DWORD  dwFlags\n);\n// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx\nHMODULE LoadPackagedLibrary(\n  LPCWSTR lpwLibFileName,\n  DWORD   Reserved\n);\n\n// 卸载库\nBOOL WINAPI FreeLibrary(\n  _In_ HMODULE hModule\n);\n// 卸载库和退出线程\nVOID WINAPI FreeLibraryAndExitThread(\n  _In_ HMODULE hModule,\n  _In_ DWORD   dwExitCode\n);\n```\n\n#### 显示地链接到导出符号\n\nGetProcAddress 函数声明\n\n```cpp\nFARPROC GetProcAddress(\n  HMODULE hInstDll,\n  PCSTR pszSymbolName  // 只能接受 ANSI 字符串，不能是 Unicode\n);\n```\n\n#### DumpBin.exe 查看 DLL 信息\n\n在 `VS 的开发人员命令提示符` 使用 `DumpBin.exe` 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：\n```\nDUMPBIN -exports D:\\mydll.dll\n```\n\n#### LoadLibrary 与 FreeLibrary 流程图\n\nLoadLibrary 与 FreeLibrary 流程图\n\n##### LoadLibrary\n\n![WindowsLoadLibrary](https://gitee.com/huihut/interview/raw/master/images/WindowsLoadLibrary.png)\n\n##### FreeLibrary\n\n![WindowsFreeLibrary](https://gitee.com/huihut/interview/raw/master/images/WindowsFreeLibrary.png)\n\n#### DLL 库的编写（导出一个 DLL 模块）\n\nDLL 库的编写（导出一个 DLL 模块）\nDLL 头文件\n\n```cpp\n// MyLib.h\n\n#ifdef MYLIBAPI\n\n// MYLIBAPI 应该在全部 DLL 源文件的 include "Mylib.h" 之前被定义\n// 全部函数/变量正在被导出\n\n#else\n\n// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入\n#define MYLIBAPI extern "C" __declspec(dllimport)\n\n#endif\n\n// 这里定义任何的数据结构和符号\n\n// 定义导出的变量（避免导出变量）\nMYLIBAPI int g_nResult;\n\n// 定义导出函数原型\nMYLIBAPI int Add(int nLeft, int nRight);\n```\n\nDLL 源文件\n\n```cpp\n// MyLibFile1.cpp\n\n// 包含标准Windows和C运行时头文件\n#include <windows.h>\n\n// DLL源码文件导出的函数和变量\n#define MYLIBAPI extern "C" __declspec(dllexport)\n\n// 包含导出的数据结构、符号、函数、变量\n#include "MyLib.h"\n\n// 将此DLL源代码文件的代码放在此处\nint g_nResult;\n\nint Add(int nLeft, int nRight)\n{\n    g_nResult = nLeft + nRight;\n    return g_nResult;\n}\n```\n\n#### DLL 库的使用（运行时动态链接 DLL）\n\nDLL 库的使用（运行时动态链接 DLL）\n\n```cpp\n// A simple program that uses LoadLibrary and \n// GetProcAddress to access myPuts from Myputs.dll. \n \n#include <windows.h> \n#include <stdio.h> \n \ntypedef int (__cdecl *MYPROC)(LPWSTR); \n \nint main( void ) \n{ \n    HINSTANCE hinstLib; \n    MYPROC ProcAdd; \n    BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; \n \n    // Get a handle to the DLL module.\n \n    hinstLib = LoadLibrary(TEXT("MyPuts.dll")); \n \n    // If the handle is valid, try to get the function address.\n \n    if (hinstLib != NULL) \n    { \n        ProcAdd = (MYPROC) GetProcAddress(hinstLib, "myPuts"); \n \n        // If the function address is valid, call the function.\n \n        if (NULL != ProcAdd) \n        {\n            fRunTimeLinkSuccess = TRUE;\n            (ProcAdd) (L"Message sent to the DLL function\\n"); \n        }\n        // Free the DLL module.\n \n        fFreeResult = FreeLibrary(hinstLib); \n    } \n\n    // If unable to call the DLL function, use an alternative.\n    if (! fRunTimeLinkSuccess) \n        printf("Message printed from executable\\n"); \n\n    return 0;\n}\n```\n\n### 运行库（Runtime Library）\n\n#### 典型程序运行步骤\n\n1. 操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）\n2. 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。\n3. 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。\n4. main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。\n\n> 一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。\n\n#### glibc 入口\n\n`_start -> __libc_start_main -> exit -> _exit`\n\n其中 `main(argc, argv, __environ)` 函数在 `__libc_start_main` 里执行。\n\n#### MSVC CRT 入口\n\n`int mainCRTStartup(void)`\n\n执行如下操作：\n\n1. 初始化和 OS 版本有关的全局变量。\n2. 初始化堆。\n3. 初始化 I/O。\n4. 获取命令行参数和环境变量。\n5. 初始化 C 库的一些数据。\n6. 调用 main 并记录返回值。\n7. 检查错误并将 main 的返回值返回。\n\n#### C 语言运行库（CRT）\n\n大致包含如下功能：\n\n* 启动与退出：包括入口函数及入口函数所依赖的其他函数等。\n* 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。\n* I/O：I/O 功能的封装和实现。\n* 堆：堆的封装和实现。\n* 语言实现：语言中一些特殊功能的实现。\n* 调试：实现调试功能的代码。\n\n#### C语言标准库（ANSI C）\n\n包含：\n\n* 标准输入输出（stdio.h）\n* 文件操作（stdio.h）\n* 字符操作（ctype.h）\n* 字符串操作（string.h）\n* 数学函数（math.h）\n* 资源管理（stdlib.h）\n* 格式转换（stdlib.h）\n* 时间/日期（time.h）\n* 断言（assert.h）\n* 各种类型上的常数（limits.h & float.h）\n* 变长参数（stdarg.h）\n* 非局部跳转（setjmp.h）\n\n<a id="books"></a>\n\n## 📚 书籍\n\n> [huihut/CS-Books](https://github.com/huihut/CS-Books)：📚 Computer Science Books 计算机技术类书籍 PDF\n\n### 语言\n\n* 《C++ Primer》\n* 《Effective C++》\n* 《More Effective C++》\n* 《深度探索 C++ 对象模型》\n* 《深入理解 C++11》\n* 《STL 源码剖析》\n\n### 算法\n\n* 《剑指 Offer》\n* 《编程珠玑》\n* 《程序员面试宝典》\n\n### 系统\n\n* 《深入理解计算机系统》\n* 《Windows 核心编程》\n* 《Unix 环境高级编程》\n\n### 网络\n\n* 《Unix 网络编程》\n* 《TCP/IP 详解》\n\n### 其他\n\n* 《程序员的自我修养》\n\n<a id="cc-development-direction"></a>\n\n## 🔱 C/C++ 发展方向\n\n> C/C++ 发展方向甚广，包括不限于以下方向， 以下列举一些大厂校招岗位要求。\n\n### 后台/服务器\n\n【后台开发】\n\n* 编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构；\n* 熟悉 TCP/UDP 网络协议及相关编程、进程间通讯编程；\n* 了解 Python、Shell、Perl 等脚本语言；\n* 了解 MYSQL 及 SQL 语言、编程，了解 NoSQL, key-value 存储原理；\n* 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识；\n* 了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。\n\n### 桌面客户端\n\n【PC 客户端开发】\n\n* 计算机软件相关专业本科或以上学历，热爱编程，基础扎实，理解算法和数据结构相关知识；  \n* 熟悉 windows 操作系统的内存管理、文件系统、进程线程调度； \n* 熟悉 MFC/windows 界面实现机制，熟练使用 VC，精通 C/C++，熟练使用 STL，以及 Windows 下网络编程经验；\n* 熟练掌握 Windows 客户端开发、调试，有 Windows 应用软件开发经验优先；\n* 对于创新及解决具有挑战性的问题充满激情，具有良好的算法基础及系统分析能力。\n\n### 图形学/游戏/VR/AR\n\n【游戏客户端开发】\n\n* 计算机科学/工程相关专业本科或以上学历，热爱编程，基础扎实，理解算法、数据结构、软件设计相关知识；\n* 至少掌握一种游戏开发常用的编程语言，具 C++/C# 编程经验优先；\n* 具游戏引擎（如 Unity、Unreal）使用经验者优先；\n* 了解某方面的游戏客户端技术（如图形、音频、动画、物理、人工智能、网络同步）者优先考虑；\n* 对于创新及解决具有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识；\n* 具阅读英文技术文档能力；\n* 热爱游戏。\n\n### 测试开发\n\n【测试开发】\n\n* 计算机或相关专业本科及以上学历；\n* 一至两年的 C/C++/Python 或其他计算机语言的编程经验；\n* 具备撰写测试计划、测试用例、以及实现性能和安全等测试的能力；\n* 具备实现自动化系统的能力；\n* 具备定位调查产品缺陷能力、以及代码级别调试缺陷的能力；\n* 工作主动积极，有责任心，具有良好的团队合作精神。\n\n### 网络安全/逆向\n\n【安全技术】\n\n* 热爱互联网，对操作系统和网络安全有狂热的追求，专业不限；\n* 熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法；  \n* 掌握基本开发能力，熟练使用 C/C++ 语言；\n* 对数据库、操作系统、网络原理有较好掌握；  \n* 具有软件逆向，网络安全攻防或安全系统开发经验者优先。\n\n### 嵌入式/物联网\n\n【嵌入式应用开发】\n\n* 有良好的编程基础，熟练掌握 C/C++ 语言；\n* 掌握操作系统、数据结构等软件开发必备知识；\n* 具备较强的沟通理解能力及良好的团队合作意识；\n* 有 Linux/Android 系统平台的开发经验者优先。\n\n### 音视频/流媒体/SDK\n\n【音视频编解码】\n\n1. 硕士及以上学历，计算机、信号处理、数学、信息类及相关专业和方向； \n2. 视频编解码基础扎实，熟常用的 HEVC 或 H264，有较好的数字信号处理基础； \n3. 掌握 C/C++，代码能力强, 熟悉一种汇编语言尤佳； \n4. 较强的英文文献阅读能力； \n5. 学习能力强，具有团队协作精神，有较强的抗压能力。\n\n### 计算机视觉/机器学习\n\n【计算机视觉研究】\n\n* 计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先；\n* 熟练掌握计算机视觉和图像处理相关的基本算法及应用；\n* 较强的算法实现能力，熟练掌握 C/C++ 编程，熟悉 Shell/Python/Matlab 至少一种编程语言；\n* 在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。\n\n<a id="review-of-brush-questions-website"></a>\n\n## 💯 复习刷题网站\n\n* [cplusplus](http://www.cplusplus.com/)\n* [cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)\n* [runoob](http://www.runoob.com/cplusplus/cpp-tutorial.html)\n* [leetcode](https://leetcode.com/) | [leetcode-cn](https://leetcode-cn.com/)\n* [lintcode](https://www.lintcode.com/)\n* [nowcoder](https://www.nowcoder.net/)\n\n<a id="interview-questions-experience"></a>\n\n## 📝 面试题目经验\n\n* [牛客网 . 2020秋招面经大汇总！（岗位划分）](https://www.nowcoder.com/discuss/205497)\n* [牛客网 . 【备战秋招】2020届秋招备战攻略](https://www.nowcoder.com/discuss/197116)\n* [牛客网 . 2019校招面经大汇总！【每日更新中】](https://www.nowcoder.com/discuss/90907)\n* [牛客网 . 2019校招技术类岗位面经汇总【技术类】](https://www.nowcoder.com/discuss/146655)\n* [牛客网 . 2018校招笔试真题汇总](https://www.nowcoder.com/discuss/68802)\n* [牛客网 . 2017秋季校园招聘笔经面经专题汇总](https://www.nowcoder.com/discuss/12805)\n* [牛客网 . 史上最全2017春招面经大合集！！](https://www.nowcoder.com/discuss/25268)\n* [牛客网 . 面试题干货在此](https://www.nowcoder.com/discuss/57978)\n* [知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。](https://www.zhihu.com/question/29693016)\n* [知乎 . 互联网公司最常见的面试算法题有哪些？](https://www.zhihu.com/question/24964987)\n* [CSDN . 全面整理的C++面试题](http://blog.csdn.net/ljzcome/article/details/574158)\n* [CSDN . 百度研发类面试题（C++方向）](http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1)\n* [CSDN . c++常见面试题30道](http://blog.csdn.net/fakine/article/details/51321544)\n* [CSDN . 腾讯2016实习生面试经验（已经拿到offer)](http://blog.csdn.net/onever_say_love/article/details/51223886)\n* [cnblogs . C++面试集锦( 面试被问到的问题 )](https://www.cnblogs.com/Y1Focus/p/6707121.html)\n* [cnblogs . C/C++ 笔试、面试题目大汇总](https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html)\n* [cnblogs . 常见C++面试题及基本知识点总结（一）](https://www.cnblogs.com/LUO77/p/5771237.html)\n* [segmentfault . C++常见面试问题总结](https://segmentfault.com/a/1190000003745529)\n\n<a id="recruitment-time-post"></a>\n\n## 📆 招聘时间岗位\n\n* [牛客网 . 名企校招日程](https://www.nowcoder.com/school/schedule)\n\n<a id="recommend"></a>\n\n## 👍 内推\n\n* [Github . CyC2018/Job-Recommend](https://github.com/CyC2018/Job-Recommend)：🔎 互联网内推信息（社招、校招、实习）\n* [Github . amusi/AI-Job-Recommend](https://github.com/amusi/AI-Job-Recommend)：国内公司人工智能方向（含机器学习、深度学习、计算机视觉和自然语言处理）岗位的招聘信息（含全职、实习和校招）\n\n<a id="contributor"></a>\n\n## 👬 贡献者\n\n<a href="https://github.com/huihut/interview/graphs/contributors"><img src="https://opencollective.com/interview/contributors.svg?button=false" /></a>\n\n<a id="support-sponsor"></a>\n\n## 🍭 支持赞助\n\n**[Avalive](https://store.steampowered.com/app/1137770/Avalive/)**：一个面部捕捉的虚拟形象扮演软件。\n\n<a id="license"></a>\n\n## 📜 License\n\n本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。\n\n[![CC BY-NC-SA 4.0](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)](https://github.com/huihut/interview/blob/master/LICENSE)\n\n']
flink-learning,flink learning blog. http://www.54tianzhisheng.cn/  含 Flink 入门、概念、原理、实战、性能调优、源码解析等内容。涉及 Flink Connector、Metrics、Library、DataStream API、Table API & SQL 等内容的学习案例，还有 Flink 落地应用的大型项目案例（PVUV、日志存储、百亿数据实时去重、监控告警）分享。欢迎大家支持我的专栏《大数据实时计算引擎 Flink 实战与性能优化》,13249,https://github.com/zhisheng17/flink-learning,master,['# Flink 学习\n\n麻烦路过的各位亲给这个项目点个 star，太不易了，写了这么多，算是对我坚持下来的一种鼓励吧！另外特别感谢 [JetBrains](https://jb.gg/OpenSourceSupport) 公司提供的免费全家桶工具，🙏🙏🙏！\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-05-25-124027.jpg)\n\n## Stargazers over time\n\n![Stargazers over time](https://starchart.cc/zhisheng17/flink-learning.svg)\n\n## 本项目结构\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/2020-01-11-064410.png)\n\n\n## How to build\n\nMaybe your Maven conf file `settings.xml` mirrors can add aliyun central mirror :\n\n```xml\n<mirror>\n  <id>alimaven</id>\n  <mirrorOf>central</mirrorOf>\n  <name>aliyun maven</name>\n  <url>https://maven.aliyun.com/repository/central</url>\n</mirror>\n```\n\nthen you can run the following command :\n\n```\nmvn clean package -Dmaven.test.skip=true\n```\n\nyou can see following result if build success.\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-09-27-121923.jpg)\n\n## Flink 系统专栏\n\n基于 Flink 1.9 讲解的专栏，涉及入门、概念、原理、实战、性能调优、系统案例的讲解。扫码下面专栏二维码可以订阅该专栏\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-11-05-044731.jpg)\n\n首发地址：[http://www.54tianzhisheng.cn/2019/11/15/flink-in-action/](http://www.54tianzhisheng.cn/2019/11/15/flink-in-action/)\n\n专栏地址：[https://gitbook.cn/gitchat/column/5dad4a20669f843a1a37cb4f](https://gitbook.cn/gitchat/column/5dad4a20669f843a1a37cb4f)\n\n\n\n## Change\n\n**2022/02/26** 将自己 《Flink 实战与性能优化》专栏放在 GitHub，参见 books 目录\n\n**2021/12/18** 将该项目的 Flink 版本升级至 1.14.2，如果有需要可以去老的分支查看。\n\n**2021/08/15** 将该项目的 Flink 版本升级至 1.13.2，API 发生重大改变，所以代码结构也做了相应的调整（部分代码在 master 分支已经删除，同时将之前的代码切到 [feature/flink-1.10.0](https://github.com/zhisheng17/flink-learning/tree/feature/flink-1.10.0) 上了，如果有需要可以去老的分支查看）。\n\n**2020/02/16** 将该项目的 Flink 版本升级至 1.10，该版本代码都是经过测试成功运行的，尽量以该版本作为参考，如果代码在你们集群测试不成功，麻烦检查 Flink 版本是否一致，或者是否有包冲突问题。 \n\n**2019/09/06** 将该项目的 Flink 版本升级到 1.9.0，有一些变动，Flink 1.8.0 版本的代码经群里讨论保存在分支 [feature/flink-1.8.0](https://github.com/zhisheng17/flink-learning/tree/feature/flink-1.8.0) 以便部分同学需要。\n\n**2019/06/08** 四本 Flink 书籍：\n\n+ [Introduction_to_Apache_Flink_book.pdf]()    这本书比较薄，处于介绍阶段，国内有这本的翻译书籍\n\n+ [Learning Apache Flink.pdf]()    这本书比较基础，初学的话可以多看看\n\n+ [Stream Processing with Apache Flink.pdf]()    这本书是 Flink PMC 写的\n\n+ [Streaming System.pdf]()  这本书评价不是一般的高\n\n**2019/06/09** 新增流处理引擎相关的 Paper，在 paper 目录下：\n\n+ [流处理引擎相关的 Paper](./paper/paper.md)\n\n**【提示】**：关于书籍的下载，因版权问题，不方便提供，所以已经删除，需要的话可以切换到老分支去下载。\n\n## 博客\n\n1、[Flink 从0到1学习 —— Apache Flink 介绍](http://www.54tianzhisheng.cn/2018/10/13/flink-introduction/)\n\n2、[Flink 从0到1学习 —— Mac 上搭建 Flink 1.6.0 环境并构建运行简单程序入门](http://www.54tianzhisheng.cn/2018/09/18/flink-install)\n\n3、[Flink 从0到1学习 —— Flink 配置文件详解](http://www.54tianzhisheng.cn/2018/10/27/flink-config/)\n\n4、[Flink 从0到1学习 —— Data Source 介绍](http://www.54tianzhisheng.cn/2018/10/28/flink-sources/)\n\n5、[Flink 从0到1学习 —— 如何自定义 Data Source ？](http://www.54tianzhisheng.cn/2018/10/30/flink-create-source/)\n\n6、[Flink 从0到1学习 —— Data Sink 介绍](http://www.54tianzhisheng.cn/2018/10/29/flink-sink/)\n\n7、[Flink 从0到1学习 —— 如何自定义 Data Sink ？](http://www.54tianzhisheng.cn/2018/10/31/flink-create-sink/)\n\n8、[Flink 从0到1学习 —— Flink Data transformation(转换)](http://www.54tianzhisheng.cn/2018/11/04/Flink-Data-transformation/)\n\n9、[Flink 从0到1学习 —— 介绍 Flink 中的 Stream Windows](http://www.54tianzhisheng.cn/2018/12/08/Flink-Stream-Windows/)\n\n10、[Flink 从0到1学习 —— Flink 中的几种 Time 详解](http://www.54tianzhisheng.cn/2018/12/11/Flink-time/)\n\n11、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 ElasticSearch](http://www.54tianzhisheng.cn/2018/12/30/Flink-ElasticSearch-Sink/)\n\n12、[Flink 从0到1学习 —— Flink 项目如何运行？](http://www.54tianzhisheng.cn/2019/01/05/Flink-run/)\n\n13、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 Kafka](http://www.54tianzhisheng.cn/2019/01/06/Flink-Kafka-sink/)\n\n14、[Flink 从0到1学习 —— Flink JobManager 高可用性配置](http://www.54tianzhisheng.cn/2019/01/13/Flink-JobManager-High-availability/)\n\n15、[Flink 从0到1学习 —— Flink parallelism 和 Slot 介绍](http://www.54tianzhisheng.cn/2019/01/14/Flink-parallelism-slot/)\n\n16、[Flink 从0到1学习 —— Flink 读取 Kafka 数据批量写入到 MySQL](http://www.54tianzhisheng.cn/2019/01/15/Flink-MySQL-sink/)\n\n17、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 RabbitMQ](https://t.zsxq.com/uVbi2nq)\n\n18、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 HBase](https://t.zsxq.com/zV7MnuJ)\n\n19、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 HDFS](https://t.zsxq.com/zV7MnuJ)\n\n20、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 Redis](https://t.zsxq.com/zV7MnuJ)\n\n21、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 Cassandra](https://t.zsxq.com/uVbi2nq)\n\n22、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 Flume](https://t.zsxq.com/zV7MnuJ)\n\n23、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 InfluxDB](https://t.zsxq.com/zV7MnuJ)\n\n24、[Flink 从0到1学习 —— Flink 读取 Kafka 数据写入到 RocketMQ](https://t.zsxq.com/zV7MnuJ)\n\n25、[Flink 从0到1学习 —— 你上传的 jar 包藏到哪里去了](https://t.zsxq.com/uniY7mm)\n\n26、[Flink 从0到1学习 —— 你的 Flink job 日志跑到哪里去了](https://t.zsxq.com/zV7MnuJ)\n\n\n### Flink 源码项目结构\n\n![](./pics/Flink-code.png)\n\n\n## 学习资料\n\n另外我自己整理了些 Flink 的学习资料，目前已经全部放到微信公众号了。\n你可以加我的微信：**yuanblog_tzs**，然后回复关键字：**Flink** 即可无条件获取到，转载请联系本人获取授权，违者必究。\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-09-17-143454.jpg)\n\n更多私密资料请加入知识星球！\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-23-124320.jpg)\n\n有人要问知识星球里面更新什么内容？值得加入吗？\n\n目前知识星球内已更新的系列文章：\n\n### 大数据重磅炸弹\n\n1、[《大数据重磅炸弹——实时计算引擎 Flink》开篇词](https://t.zsxq.com/fqfuVRR\u200b)\n\n2、[你公司到底需不需要引入实时计算引擎？](https://t.zsxq.com/emMBaQN\u200b)\n\n3、[一文让你彻底了解大数据实时计算框架 Flink](https://t.zsxq.com/eM3ZRf2) \u200b\n\n4、[别再傻傻的分不清大数据框架Flink、Blink、Spark Streaming、Structured Streaming和Storm之间的区别了](https://t.zsxq.com/eAyRz7Y)\u200b\n\n5、[Flink 环境准备看这一篇就够了](https://t.zsxq.com/iaMJAe6\u200b) \u2006\n\n6、[一文讲解从 Flink 环境安装到源码编译运行](https://t.zsxq.com/iaMJAe6\u200b)\n\n7、[通过 WordCount 程序教你快速入门上手 Flink](https://t.zsxq.com/eaIIiAm) \u2006\u200b\n\n8、[Flink 如何处理 Socket 数据及分析实现过程](https://t.zsxq.com/Vnq72jY\u200b) \u2006\n\n9、[Flink job 如何在 Standalone、YARN、Mesos、K8S 上部署运行？](https://t.zsxq.com/BiyvFUZ\u200b)\n\n10、[Flink 数据转换必须熟悉的算子（Operator）](https://t.zsxq.com/fufUBiA)\n\n11、[Flink 中 Processing Time、Event Time、Ingestion Time 对比及其使用场景分析](https://t.zsxq.com/r7aYB2V) \n\n12、[如何使用 Flink Window 及 Window 基本概念与实现原理](https://t.zsxq.com/byZbyrb)\n\n13、[如何使用 DataStream API 来处理数据？](https://t.zsxq.com/VzNBi2r)\n\n14、[Flink WaterMark 详解及结合 WaterMark 处理延迟数据](https://t.zsxq.com/Iub6IQf)\n\n15、[基于 Apache Flink 的监控告警系统](https://t.zsxq.com/MniUnqb)\n\n16、[数据仓库、数据库的对比介绍与实时数仓案例分享](https://t.zsxq.com/v7QzNZ3)\n\n17、[使用 Prometheus Grafana 监控 Flink](https://t.zsxq.com/uRN3VfA)\n\n\n### 源码系列\n\n1、[Flink 源码解析 —— 源码编译运行](https://t.zsxq.com/UZfaYfE)\n\n2、[Flink 源码解析 —— 项目结构一览](https://t.zsxq.com/zZZjaYf)\n\n3、[Flink 源码解析—— local 模式启动流程](https://t.zsxq.com/zV7MnuJ)\n\n4、[Flink 源码解析 —— standalonesession 模式启动流程](https://t.zsxq.com/QZVRZJA)\n\n5、[Flink 源码解析 —— Standalone Session Cluster 启动流程深度分析之 Job Manager 启动](https://t.zsxq.com/u3fayvf)\n\n6、[Flink 源码解析 —— Standalone Session Cluster 启动流程深度分析之 Task Manager 启动](https://t.zsxq.com/MnQRByb)\n\n7、[Flink 源码解析 —— 分析 Batch WordCount 程序的执行过程](https://t.zsxq.com/YJ2Zrfi)\n\n8、[Flink 源码解析 —— 分析 Streaming WordCount 程序的执行过程](https://t.zsxq.com/qnMFEUJ)\n\n9、[Flink 源码解析 —— 如何获取 JobGraph？](https://t.zsxq.com/naaMf6y)\n\n10、[Flink 源码解析 —— 如何获取 StreamGraph？](https://t.zsxq.com/qRFIm6I)\n\n11、[Flink 源码解析 —— Flink JobManager 有什么作用？](https://t.zsxq.com/2VRrbuf)\n\n12、[Flink 源码解析 —— Flink TaskManager 有什么作用？](https://t.zsxq.com/RZbu7yN)\n\n13、[Flink 源码解析 —— JobManager 处理 SubmitJob 的过程](https://t.zsxq.com/zV7MnuJ)\n\n14、[Flink 源码解析 —— TaskManager 处理 SubmitJob 的过程](https://t.zsxq.com/zV7MnuJ)\n\n15、[Flink 源码解析 —— 深度解析 Flink Checkpoint 机制](https://t.zsxq.com/ynQNbeM)\n\n16、[Flink 源码解析 —— 深度解析 Flink 序列化机制](https://t.zsxq.com/JaQfeMf)\n\n17、[Flink 源码解析 —— 深度解析 Flink 是如何管理好内存的？](https://t.zsxq.com/zjQvjeM)\n\n18、[Flink Metrics 源码解析 —— Flink-metrics-core](https://t.zsxq.com/Mnm2nI6)\n\n19、[Flink Metrics 源码解析 —— Flink-metrics-datadog](https://t.zsxq.com/Mnm2nI6)\n\n20、[Flink Metrics 源码解析 —— Flink-metrics-dropwizard](https://t.zsxq.com/Mnm2nI6)\n\n21、[Flink Metrics 源码解析 —— Flink-metrics-graphite](https://t.zsxq.com/Mnm2nI6)\n\n22、[Flink Metrics 源码解析 —— Flink-metrics-influxdb](https://t.zsxq.com/Mnm2nI6)\n\n23、[Flink Metrics 源码解析 —— Flink-metrics-jmx](https://t.zsxq.com/Mnm2nI6)\n\n24、[Flink Metrics 源码解析 —— Flink-metrics-slf4j](https://t.zsxq.com/Mnm2nI6)\n\n25、[Flink Metrics 源码解析 —— Flink-metrics-statsd](https://t.zsxq.com/Mnm2nI6)\n\n26、[Flink Metrics 源码解析 —— Flink-metrics-prometheus](https://t.zsxq.com/Mnm2nI6)\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-26-150037.jpg)\n\n26、[Flink Annotations 源码解析](https://t.zsxq.com/f6eAu3J)\n\n![](http://zhisheng-blog.oss-cn-hangzhou.aliyuncs.com/img/2019-07-26-145923.jpg)\n\n除了《从1到100深入学习Flink》源码学习这个系列文章，《从0到1学习Flink》的案例文章也会优先在知识星球更新，让大家先通过一些 demo 学习 Flink，再去深入源码学习！\n\n如果学习 Flink 的过程中，遇到什么问题，可以在里面提问，我会优先解答，这里做个抱歉，自己平时工作也挺忙，微信的问题不能做全部做一些解答，\n但肯定会优先回复给知识星球的付费用户的，庆幸的是现在星球里的活跃氛围还是可以的，有不少问题通过提问和解答的方式沉淀了下来。\n\n1、[为何我使用 ValueState 保存状态 Job 恢复是状态没恢复？](https://t.zsxq.com/62rZV7q)\n\n2、[flink中watermark究竟是如何生成的，生成的规则是什么，怎么用来处理乱序数据](https://t.zsxq.com/yF2rjmY)\n\n3、[消费kafka数据的时候，如果遇到了脏数据，或者是不符合规则的数据等等怎么处理呢？](https://t.zsxq.com/uzFIeiq)\n\n4、[在Kafka 集群中怎么指定读取/写入数据到指定broker或从指定broker的offset开始消费？](https://t.zsxq.com/Nz7QZBY)\n\n5、[Flink能通过oozie或者azkaban提交吗？](https://t.zsxq.com/7UVBeMj)\n\n6、[jobmanager挂掉后，提交的job怎么不经过手动重新提交执行？](https://t.zsxq.com/mUzRbY7)\n\n7、[使用flink-web-ui提交作业并执行 但是/opt/flink/log目录下没有日志文件 请问关于flink的日志（包括jobmanager、taskmanager、每个job自己的日志默认分别存在哪个目录 ）需要怎么配置？](https://t.zsxq.com/Nju7EuV)\n\n8、[通过flink 仪表盘提交的jar 是存储在哪个目录下？](https://t.zsxq.com/6muRz3j)\n\n9、[从Kafka消费数据进行etl清洗，把结果写入hdfs映射成hive表，压缩格式、hive直接能够读取flink写出的文件、按照文件大小或者时间滚动生成文件](https://t.zsxq.com/uvFQvFu)\n\n10、[flink jar包上传至集群上运行，挂掉后，挂掉期间kafka中未被消费的数据，在重新启动程序后，是自动从checkpoint获取挂掉之前的kafka offset位置，自动消费之前的数据进行处理，还是需要某些手动的操作呢？](https://t.zsxq.com/ubIY33f)\n\n11、[flink 启动时不自动创建 上传jar的路径，能指定一个创建好的目录吗](https://t.zsxq.com/UfA2rBy)\n\n12、[Flink sink to es 集群上报 slot 不够，单机跑是好的，为什么？](https://t.zsxq.com/zBMnIA6)\n\n13、[Fllink to elasticsearch如何创建索引文档期时间戳？](https://t.zsxq.com/qrZBAQJ)\n\n14、[blink有没有api文档或者demo，是否建议blink用于生产环境。](https://t.zsxq.com/J2JiIMv)\n\n15、[flink的Python api怎样？bug多吗？](https://t.zsxq.com/ZVVrjuv)\n\n16、[Flink VS Spark Streaming VS Storm VS Kafka Stream ](https://t.zsxq.com/zbybQNf)\n\n17、[你们做实时大屏的技术架构是什么样子的？flume→kafka→flink→redis，然后后端去redis里面捞数据，酱紫可行吗？](https://t.zsxq.com/Zf6meAm)\n\n18、[做一个统计指标的时候，需要在Flink的计算过程中多次读写redis，感觉好怪，星主有没有好的方案？](https://t.zsxq.com/YniI2JQ)\n\n19、[Flink 使用场景大分析，列举了很多的常用场景，可以好好参考一下](https://t.zsxq.com/fYZZfYf)\n\n20、[将kafka中数据sink到mysql时，metadata的数据为空，导入mysql数据不成功？？？](https://t.zsxq.com/I6eEqR7)\n\n21、[使用了ValueState来保存中间状态，在运行时中间状态保存正常，但是在手动停止后，再重新运行，发现中间状态值没有了，之前出现的键值是从0开始计数的，这是为什么？是需要实现CheckpointedFunction吗？](https://t.zsxq.com/62rZV7q)\n\n22、[flink on yarn jobmanager的HA需要怎么配置。还是说yarn给管理了](https://t.zsxq.com/mQ7YbQJ)\n\n23、[有两个数据流就行connect，其中一个是实时数据流（kafka 读取)，另一个是配置流。由于配置流是从关系型数据库中读取，速度较慢，导致实时数据流流入数据的时候，配置信息还未发送，这样会导致有些实时数据读取不到配置信息。目前采取的措施是在connect方法后的flatmap的实现的在open 方法中，提前加载一次配置信息，感觉这种实现方式不友好，请问还有其他的实现方式吗？](https://t.zsxq.com/q3VvB6U)\n\n24、[Flink能通过oozie或者azkaban提交吗？](https://t.zsxq.com/7UVBeMj)\n\n25、[不采用yarm部署flink，还有其他的方案吗？ 主要想解决服务器重启后，flink服务怎么自动拉起？ jobmanager挂掉后，提交的job怎么不经过手动重新提交执行？](https://t.zsxq.com/mUzRbY7)\n\n26、[在一个 Job 里将同份数据昨晚清洗操作后，sink 到后端多个地方（看业务需求），如何保持一致性？（一个sink出错，另外的也保证不能插入）](https://t.zsxq.com/bYnimQv)\n\n27、[flink sql任务在某个特定阶段会发生tm和jm丢失心跳，是不是由于gc时间过长呢，](https://t.zsxq.com/YvBAyrV)\n\n28、[有这样一个需求，统计用户近两周进入产品详情页的来源（1首页大搜索，2产品频道搜索，3其他），为php后端提供数据支持，该信息在端上报事件中，php直接获取有点困难。 我现在的解决方案 通过flink滚动窗口（半小时），统计用户半小时内3个来源pv，然后按照日期序列化，直接写mysql。php从数据库中解析出来，再去统计近两周占比。 问题1，这个需求适合用flink去做吗？ 问题2，我的方案总感觉怪怪的，有没有好的方案？](https://t.zsxq.com/fayf2Vv)\n\n29、[一个task slot  只能同时运行一个任务还是多个任务呢？如果task  slot运行的任务比较大，会出现OOM的情况吗？](https://t.zsxq.com/ZFiY3VZ)\n\n30、[你们怎么对线上flink做监控的，如果整个程序失败了怎么自动重启等等](https://t.zsxq.com/Yn2JqB6)\n\n31、[flink cep规则动态解析有接触吗？有没有成型的框架？](https://t.zsxq.com/YFMFeaA)\n\n32、[每一个Window都有一个watermark吗？window是怎么根据watermark进行触发或者销毁的？](https://t.zsxq.com/VZvRrjm)\n\n33、[ CheckPoint与SavePoint的区别是什么？](https://t.zsxq.com/R3ZZJUF)\n\n34、[flink可以在算子中共享状态吗？或者大佬你有什么方法可以共享状态的呢？](https://t.zsxq.com/Aa62Bim)\n\n35、[运行几分钟就报了，看taskmager日志，报的是 failed elasticsearch bulk request null，可是我代码里面已经做过空值判断了呀 而且也过滤掉了，flink版本1.7.2 es版本6.3.1](https://t.zsxq.com/ayFmmMF)\n\n36、[这种情况，我们调并行度 还是配置参数好](https://t.zsxq.com/Yzzzb2b)\n\n37、[大家都用jdbc写，各种数据库增删查改拼sql有没有觉得很累，ps.set代码一大堆，还要计算每个参数的位置](https://t.zsxq.com/AqBUR3f)\n\n38、[关于datasource的配置，每个taskmanager对应一个datasource?还是每个slot? 实际运行下来，每个slot中datasorce线程池只要设置1就行了，多了也用不到?](https://t.zsxq.com/AqBUR3f)\n\n39、[kafka现在每天出现数据丢失，现在小批量数据，一天200W左右, kafka版本为 1.0.0，集群总共7个节点，TOPIC有十六个分区，单条报文1.5k左右](https://t.zsxq.com/AqBUR3f)\n\n40、[根据key.hash的绝对值 对并发度求模，进行分组，假设10各并发度，实际只有8个分区有处理数据，有2个始终不处理，还有一个分区处理的数据是其他的三倍，如截图](https://t.zsxq.com/AqBUR3f)\n\n41、[flink每7小时不知道在处理什么， CPU 负载 每7小时，有一次高峰，5分钟内平均负载超过0.8，如截图](https://t.zsxq.com/AqBUR3f)\n\n42、[有没有Flink写的项目推荐？我想看到用Flink写的整体项目是怎么组织的，不单单是一个单例子](https://t.zsxq.com/M3fIMbu)\n\n43、[Flink 源码的结构图](https://t.zsxq.com/yv7EQFA)\n\n44、[我想根据不同业务表（case when）进行不同的redis sink（hash ，set），我要如何操作？](https://t.zsxq.com/vBAYNJq)\n\n45、[这个需要清理什么数据呀，我把hdfs里面的已经清理了 启动还是报这个](https://t.zsxq.com/b2zbUJa)\n\n46、[  在流处理系统，在机器发生故障恢复之后，什么情况消息最多会被处理一次？什么情况消息最少会被处理一次呢？](https://t.zsxq.com/QjQFmQr)\n\n47、[我检查点都调到5分钟了，这是什么问题](https://t.zsxq.com/zbQNfuJ)\n\n48、[reduce方法后 那个交易时间 怎么不是最新的，是第一次进入的那个时间，](https://t.zsxq.com/ZrjEauN)\n\n49、[Flink  on Yarn 模式，用yarn session脚本启动的时候，我在后台没有看到到Jobmanager，TaskManager，ApplicationMaster这几个进程，想请问一下这是什么原因呢？因为之前看官网的时候，说Jobmanager就是一个jvm进程，Taskmanage也是一个JVM进程](https://t.zsxq.com/VJyr3bM)\n\n50、[Flink  on Yarn的时候得指定 多少个TaskManager和每个TaskManager slot去运行任务，这样做感觉不太合理，因为用户也不知道需要多少个TaskManager适合，Flink 有动态启动TaskManager的机制吗。](https://t.zsxq.com/VJyr3bM)\n\n51、[参考这个例子，Flink 零基础实战教程：如何计算实时热门商品 | Jark\'s Blog， 窗口聚合的时候，用keywindow，用的是timeWindowAll，然后在aggregate的时候用aggregate(new CustomAggregateFunction(), new CustomWindowFunction())，打印结果后，发现窗口中一直使用的重复的数据，统计的结果也不变，去掉CustomWindowFunction()就正常了 ？ 非常奇怪](https://t.zsxq.com/UBmUJMv)\n\n52、[用户进入产品预定页面（端埋点上报），并填写了一些信息（端埋点上报），但半小时内并没有产生任何订单，然后给该类用户发送一个push。 1. 这种需求适合用flink去做吗？2. 如果适合，说下大概的思路](https://t.zsxq.com/naQb6aI)\n\n53、[业务场景是实时获取数据存redis，请问我要如何按天、按周、按月分别存入redis里？（比方说过了一天自动换一个位置存redis）](https://t.zsxq.com/AUf2VNz)\n\n54、[有人 AggregatingState 的例子吗, 感觉官方的例子和 官网的不太一样?](https://t.zsxq.com/UJ6Y7m2)\n\n55、[flink-jdbc这个jar有吗？怎么没找到啊？1.8.0的没找到，1.6.2的有](https://t.zsxq.com/r3BaAY3)\n\n56、[现有个关于savepoint的问题，操作流程为，取消任务时设置保存点，更新任务，从保存点启动任务；现在遇到个问题，假设我中间某个算子重写，原先通过state编写，有用定时器，现在更改后，采用窗口，反正就是实现方式完全不一样；从保存点启动就会一直报错，重启，原先的保存点不能还原，此时就会有很多数据重复等各种问题，如何才能保证数据不丢失，不重复等，恢复到停止的时候，现在想到的是记下kafka的偏移量，再做处理，貌似也不是很好弄，有什么解决办法吗](https://t.zsxq.com/jiybIee)\n\n57、[需要在flink计算app页面访问时长，消费Kafka计算后输出到Kafka。第一条log需要等待第二条log的时间戳计算访问时长。我想问的是，flink是分布式的，那么它能否保证执行的顺序性？后来的数据有没有可能先被执行？](https://t.zsxq.com/eMJmiQz)\n\n58、[我公司想做实时大屏，现有技术是将业务所需指标实时用spark拉到redis里存着，然后再用一条spark streaming流计算简单乘除运算，指标包含了各月份的比较。请问我该如何用flink简化上述流程？](https://t.zsxq.com/Y7e6aIu)\n\n59、[flink on yarn 方式，这样理解不知道对不对，yarn-session这个脚本其实就是准备yarn环境的，执行run任务的时候，根据yarn-session初始化的yarnDescription 把 flink 任务的jobGraph提交到yarn上去执行](https://t.zsxq.com/QbIayJ6)\n\n60、[同样的代码逻辑写在单独的main函数中就可以成功的消费kafka ，写在一个spring boot的程序中，接受外部请求，然后执行相同的逻辑就不能消费kafka。你遇到过吗？能给一些查问题的建议，或者在哪里打个断点，能看到为什么消费不到kafka的消息呢？](https://t.zsxq.com/VFMRbYN)\n\n61、[请问下flink可以实现一个流中同时存在订单表和订单商品表的数据 两者是一对多的关系  能实现得到 以订单表为主 一个订单多个商品 这种需求嘛](https://t.zsxq.com/QNvjI6Q)\n\n62、[在用中间状态的时候，如果中间一些信息保存在state中，有没有必要在redis中再保存一份，来做第三方的存储。](https://t.zsxq.com/6ie66EE)\n\n63、[能否出一期flink state的文章。什么场景下用什么样的state？如，最简单的，实时累加update到state。](https://t.zsxq.com/bm6mYjI)\n\n64、[flink的双流join博主有使用的经验吗？会有什么常见的问题吗](https://t.zsxq.com/II6AEe2)\n\n65、[窗口触发的条件问题](https://t.zsxq.com/V7EmUZR)\n\n66、[flink 定时任务怎么做？有相关的demo么？](https://t.zsxq.com/JY3NJam)\n\n67、[流式处理过程中数据的一致性如何保证或者如何检测](https://t.zsxq.com/7YZ3Fuz)\n\n68、[重启flink单机集群，还报job not found 异常。](https://t.zsxq.com/nEEQvzR)\n\n69、[kafka的数据是用 org.apache.kafka.common.serialization.ByteArraySerialize序列化的，flink这边消费的时候怎么通过FlinkKafkaConsumer创建DataStream<String>？](https://t.zsxq.com/qJyvzNj)\n\n70、[现在公司有一个需求，一些用户的支付日志，通过sls收集，要把这些日志处理后，结果写入到MySQL，关键这些日志可能连着来好几条才是一个用户的，因为发起请求，响应等每个环节都有相应的日志，这几条日志综合处理才能得到最终的结果，请问博主有什么好的方法没有？](https://t.zsxq.com/byvnaEi)\n\n71、[flink 支持hadoop 主备么？ hadoop主节点挂了 flink 会切换到hadoop 备用节点？](https://t.zsxq.com/qfie6qR)\n\n72、[请教大家: 实际 flink 开发中用 scala 多还是 java多些？ 刚入手 flink 大数据 scala 需要深入学习么？](https://t.zsxq.com/ZVZzZv7)\n\n73、[我使用的是flink是1.7.2最近用了split的方式分流，但是底层的SplitStream上却标注为Deprecated，请问是官方不推荐使用分流的方式吗？](https://t.zsxq.com/Qzbi6yn)\n\n74、[KeyBy 的正确理解，和数据倾斜问题的解释](https://t.zsxq.com/Auf2NVR)\n\n75、[用flink时，遇到个问题 checkpoint大概有2G左右， 有背压时，flink会重启有遇到过这个问题吗](https://t.zsxq.com/3vnIm62)\n\n76、[flink使用yarn-session方式部署，如何保证yarn-session的稳定性，如果yarn-session挂了，需要重新部署一个yarn-session，如何恢复之前yarn-session上的job呢，之前的checkpoint还能使用吗？](https://t.zsxq.com/URzVBIm)\n\n77、[我想请教一下关于sink的问题。我现在的需求是从Kafka消费Json数据，这个Json数据字段可能会增加，然后将拿到的json数据以parquet的格式存入hdfs。现在我可以拿到json数据的schema，但是在保存parquet文件的时候不知道怎么处理。一是flink没有专门的format parquet，二是对于可变字段的Json怎么处理成parquet比较合适？](https://t.zsxq.com/MjyN7Uf)\n\n78、[flink如何在较大的数据量中做去重计算。](https://t.zsxq.com/6qBqVvZ)\n\n79、[flink能在没有数据的时候也定时执行算子吗？](https://t.zsxq.com/Eqjyju7)\n\n80、[使用rocksdb状态后端，自定义pojo怎么实现序列化和反序列化的，有相关demo么？](https://t.zsxq.com/i2zVfIi)\n\n81、[check point 老是失败，是不是自定义的pojo问题？到本地可以，到hdfs就不行，网上也有很多类似的问题 都没有一个很好的解释和解决方案](https://t.zsxq.com/vRJujAi)\n\n82、[cep规则如图，当start事件进入时，时间00:00:15，而后进入end事件，时间00:00:40。我发现规则无法命中。请问within 是从start事件开始计时？还是跟window一样根据系统时间划分的？如果是后者，请问怎么配置才能从start开始计时？](https://t.zsxq.com/MVFmuB6)\n\n83、[Flink聚合结果直接写Mysql的幂等性设计问题](https://t.zsxq.com/EybM3vR)\n\n84、[Flink job打开了checkpoint，用的rocksdb，通过观察hdfs上checkpoint目录，为啥算副本总量会暴增爆减](https://t.zsxq.com/62VzNRF)\n\n85、[Flink 提交任务的 jar包可以指定路径为 HDFS 上的吗]()\n\n86、[在flink web Ui上提交的任务，设置的并行度为2，flink是stand alone部署的。两个任务都正常的运行了几天了，今天有个地方逻辑需要修改，于是将任务cancel掉(在命令行cancel也试了)，结果taskmanger挂掉了一个节点。后来用其他任务试了，也同样会导致节点挂掉](https://t.zsxq.com/VfimieI)\n\n87、[一个配置动态更新的问题折腾好久（配置用个静态的map变量存着，有个线程定时去数据库捞数据然后存在这个map里面更新一把），本地 idea 调试没问题，集群部署就一直报 空指针异常。下游的算子使用这个静态变量map去get key在集群模式下会出现这个空指针异常，估计就是拿不到 map](https://t.zsxq.com/nee6qRv)\n\n88、[批量写入MySQL，完成HBase批量写入](https://t.zsxq.com/3bEUZfQ)\n\n89、[用flink清洗数据，其中要访问redis，根据redis的结果来决定是否把数据传递到下流，这有可能实现吗？](https://t.zsxq.com/Zb6AM3V)\n\n90、[监控页面流处理的时候这个发送和接收字节为0。](https://t.zsxq.com/RbeYZvb)\n\n91、[sink到MySQL，如果直接用idea的话可以运行，并且成功，大大的代码上面用的FlinkKafkaConsumer010，而我的Flink版本为1.7，kafka版本为2.12，所以当我用FlinkKafkaConsumer010就有问题，于是改为\n    FlinkKafkaConsumer就可以直接在idea完成sink到MySQL，但是为何当我把该程序打成Jar包，去运行的时候，就是报FlinkKafkaConsumer找不到呢](https://t.zsxq.com/MN7iuZf)\n\n92、[SocketTextStreamWordCount中输入中文统计不出来，请问这个怎么解决，我猜测应该是需要修改一下代码，应该是这个例子默认统计英文](https://t.zsxq.com/e2VNN7Y)\n\n93、[ Flink 应用程序本地 ide 里面运行的时候并行度是怎么算的？](https://t.zsxq.com/RVRn6AE)\n\n94、[ 请问下flink中对于窗口的全量聚合有apply和process两种 他们有啥区别呢](https://t.zsxq.com/rzbIQBi)\n\n95、[不知道大大熟悉Hbase不，我想直接在Hbase中查询某一列数据，因为有重复数据，所以想使用distinct统计实际数据量，请问Hbase中有没有类似于sql的distinct关键字。如果没有，想实现这种可以不？](https://t.zsxq.com/UJIubub)\n\n96、[ 来分析一下现在Flink,Kafka方面的就业形势，以及准备就业该如何准备的这方面内容呢？](https://t.zsxq.com/VFaQn2j)\n\n97、[ 大佬知道flink的dataStream可以转换为dataSet吗？因为数据需要11分钟一个批次计算五六个指标，并且涉及好几步reduce，计算的指标之间有联系，用Stream卡住了。](https://t.zsxq.com/Zn2FEQZ)\n\n98、[1.如何在同一窗口内实现多次的聚合，比如像spark中的这样2.多个实时流的jion可以用window来处理一批次的数据吗？](https://t.zsxq.com/aIqjmQN)\n\n99、[写的批处理的功能，现在本机跑是没问题的，就是在linux集群上出现了问题，就是不知道如果通过本地调用远程jar包然后传参数和拿到结果参数返回本机](https://t.zsxq.com/ZNvb2FM)\n\n100、[我用standalone开启一个flink集群，上传flink官方用例Socket Window WordCount做测试，开启两个parallelism能正常运行，但是开启4个parallelism后出现错误](https://t.zsxq.com/femmiqf)\n\n101、[ 有使用AssignerWithPunctuatedWatermarks 的案例Demo吗？网上找了都是AssignerWithPeriodicWatermarks的，不知道具体怎么使用？](https://t.zsxq.com/YZ3vbY3)\n\n102、[ 有一个datastream(从文件读取的)，然后我用flink sql进行计算，这个sql是一个加总的运算，然后通过retractStreamTableSink可以把文件做sql的结果输出到文件吗？这个输出到文件的接口是用什么呢？](https://t.zsxq.com/uzFyVJe)\n\n103、[ 为啥split这个流设置为过期的](https://t.zsxq.com/6QNNrZz)\n\n104、[ 需要使用flink table的水印机制控制时间的乱序问题，这种场景下我就使用水印+窗口了，我现在写的demo遇到了问题，就是在把触发计算的窗口table（WindowedTable）转换成table进行sql操作时发现窗口中的数据还是乱序的，是不是flink table的WindowedTable不支持水印窗口转table-sql的功能](https://t.zsxq.com/Q7YNRBE)\n\n105、[ Flink 对 SQL 的重视性](https://t.zsxq.com/Jmayrbi)\n\n106、[ flink job打开了checkpoint，任务跑了几个小时后就出现下面的错，截图是打出来的日志，有个OOM，又遇到过的没？](https://t.zsxq.com/ZrZfa2Z)\n\n107、[ 本地测试是有数据的，之前该任务放在集群也是有数据的，可能提交过多次，现在读不到数据了 group id 也换过了， 只能重启集群解决么？](https://t.zsxq.com/emaAeyj)\n\n108、[使用flink清洗数据存到es中，直接在flatmap中对处理出来的数据用es自己的ClientInterface类直接将数据存入es当中，不走sink，这样的处理逻辑是不是会有问题。](https://t.zsxq.com/ayBa6am)\n\n108、[ flink从kafka拿数据（即增量数据）与存量数据进行内存聚合的需求，现在有一个方案就是程序启动的时候先用flink table将存量数据加载到内存中创建table中，然后将stream的增量数据与table的数据进行关联聚合后输出结束，不知道这种方案可行么。目前个人认为有两个主要问题：1是增量数据stream转化成append table后不知道能与存量的table关联聚合不，2是聚合后输出的结果数据是否过于频繁造成网络传输压力过大](https://t.zsxq.com/QNvbE62)\n\n109、[ 设置时间时间特性有什么区别呢,  分别在什么场景下使用呢?两种设置时间延迟有什么区别呢 , 分别在什么场景下使用](https://t.zsxq.com/yzjAQ7a)\n\n110、[ flink从rabbitmq中读取数据，设置了rabbitmq的CorrelationDataId和checkpoint为EXACTLY_ONCE；如果flink完成一次checkpoint后，在这次checkpoint之前消费的数据都会从mq中删除。如果某次flink停机更新，那就会出现mq中的一些数据消费但是处于Unacked状态。在flink又重新开启后这批数据又会重新消费。那这样是不是就不能保证EXACTLY_ONCE了](https://t.zsxq.com/qRrJEaa)\n\n111、[1. 在Flink checkpoint 中, 像 operator的状态信息 是在设置了checkpoint 之后自动的进行快照吗 ?2. 上面这个和我们手动存储的 Keyed State 进行快照(这个应该是增量快照)](https://t.zsxq.com/mAqn2RF)\n\n112、[现在有个实时商品数，交易额这种统计需求，打算用 flink从kafka读取binglog日志进行计算，但binglog涉及到insert和update这种操作时 怎么处理才能统计准确，避免那种重复计算的问题？](https://t.zsxq.com/E2BeQ3f)\n\n113、[我这边用flink做实时监控，功能很简单，就是每条消息做keyby然后三分钟窗口，然后做些去重操作，触发阈值则报警，现在问题是同一个时间窗口同一个人的告警会触发两次，集群是三台机器，standalone cluster，初步结果是三个算子里有两个收到了同样的数据](https://t.zsxq.com/vjIeyFI)\n\n114、[在使用WaterMark的时候，默认是每200ms去设置一次watermark，那么每个taskmanager之间，由于得到的数据不同，所以往往产生的最大的watermark不同。 那么这个时候，是各个taskmanager广播这个watermark，得到全局的最大的watermark，还是说各个taskmanager都各自用自己的watermark。主要没看到广播watermark的源码。不知道是自己观察不仔细还是就是没有广播这个变量。](https://t.zsxq.com/unq3FIa)\n\n115、[现在遇到一个需求，需要在job内部定时去读取redis的信息，想请教flink能实现像普通程序那样的定时任务吗？](https://t.zsxq.com/AeUnAyN)\n\n116、[有个触发事件开始聚合，等到数量足够，或者超时则sink推mq 环境 flink 1.6 用了mapState 记录触发事件 1 数据足够这个OK 2 超时state ttl 1.6支持，但是问题来了，如何在超时时候增加自定义处理？](https://t.zsxq.com/z7uZbY3)\n\n117、[请问impala这种mpp架构的sql引擎，为什么稳定性比较差呢？](https://t.zsxq.com/R7UjeUF)\n\n118、[watermark跟并行度相关不是，过于全局了，期望是keyby之后再针对每个keyed stream 打watermark，这个有什么好的实践呢？](https://t.zsxq.com/q7myfAQ)\n\n119、[请问如果把一个文件的内容读取成datastream和dataset，有什么区别吗？？他们都是一条数据一条数据的被读取吗？](https://t.zsxq.com/rB6yfeA)\n\n120、[有没有kylin相关的资料，或者调优的经验？](https://t.zsxq.com/j2j6EyJ)\n\n121、[flink先从jdbc读取配置表到流中，另外从kafka中新增或者修改这个配置，这个场景怎么把两个流一份配置流？我用的connect,接着发不成广播变量，再和实体流合并，但在合并时报Exception in thread "main" java.lang.IllegalArgumentException](https://t.zsxq.com/iMjmQVV)\n\n122、[Flink  exactly-once，kafka版本为0.11.0 ，sink基于FlinkKafkaProducer 每五分钟一次checkpoint，但是checkpoint开始后系统直接卡死，at-lease-once 一分钟能完成的checkpoint， 现在十分钟无法完成没进度还是0， 不知道哪里卡住了](https://t.zsxq.com/RFQNFIa)\n\n123、[flink的状态是默认存在于内存的(也可以设置为rocksdb或hdfs)，而checkpoint里面是定时存放某个时刻的状态信息，可以设置hdfs或rocksdb是这样理解的吗？](https://t.zsxq.com/NJq3rj2)\n\n124、[Flink异步IO中，下图这两种有什么区别？为啥要加 CompletableFuture.supplyAsync，不太明白？](https://t.zsxq.com/NJq3rj2)\n\n125、[flink的状态是默认存在于内存的(也可以设置为rocksdb或hdfs)，而checkpoint里面是定时存放某个时刻的状态信息，可以设置hdfs或rocksdb是这样理解的吗？](https://t.zsxq.com/NJq3rj2)\n\n126、[有个计算场景，从kafka消费两个数据源，两个数据结构都有时间段概念，计算需要做的是匹配两个时间段，匹配到了，就生成一条新的记录。请问使用哪个工具更合适，flink table还是cep？请大神指点一下 我这边之前的做法，将两个数据流转为table.两个table over window后join成新的表。结果job跑一会就oom.](https://t.zsxq.com/rniUrjm)\n\n127、[一个互联网公司，或者一个业务系统，如果想做一个全面的监控要怎么做？有什么成熟的方案可以参考交流吗？有什么有什么度量指标吗？](https://t.zsxq.com/vRZ7qJ2)\n\n128、[怎么深入学习flink,或者其他大数据组件，能为未来秋招找一份大数据相关（计算方向）的工作增加自己的竞争力？](https://t.zsxq.com/3vfyJau)\n\n129、[oppo的实时数仓，其中明细层和汇总层都在kafka中，他们的关系库的实时数据也抽取到kafka的ods，那么在构建数仓的，需要join 三四个大业务表，业务表会变化，那么是大的业务表是从kafka的ods读取吗？实时数仓，多个大表join可以吗](https://t.zsxq.com/VBIunun)\n\n130、[Tuple类型有什么方法转换成json字符串吗？现在的场景是，结果在存储到sink中时希望存的是json字符串，这样应用程序获取数据比较好转换一点。如果Tuple不好转换json字符串，那么应该以什么数据格式存储到sink中](https://t.zsxq.com/vnaURzj)\n\n140、[端到端的数据保证，是否意味着中间处理程序中断，也不会造成该批次处理失败的消息丢失，处理程序重新启动之后，会再次处理上次未处理的消息](https://t.zsxq.com/J6eAmYb)\n\n141、[关于flink datastream window相关的。比如我现在使用滚动窗口，统计一周内去重用户指标，按照正常watermark触发计算，需要等到当前周的window到达window的endtime时，才会触发，这样指标一周后才能产出结果。我能不能实现一小时触发一次计算，每次统计截止到当前时间，window中所有到达元素的去重数量。](https://t.zsxq.com/7qBMrBe)\n\n142、[FLIP-16 Loop Fault Tolerance 是讲现在的checkpoint机制无法在stream loop的时候容错吗？现在这个问题解决了没有呀？](https://t.zsxq.com/uJqzBIe)\n\n143、[现在的需求是，统计各个key的今日累计值，一分钟输出一次。如，各个用户今日累计点击次数。这种需求用datastream还是table API方便点？](https://t.zsxq.com/uZnmQzv)\n\n144、[本地idea可以跑的工程，放在standalone集群上，总报错，报错截图如下，大佬请问这是啥原因](https://t.zsxq.com/BqnYRN7)\n\n145、[比如现在用k8s起了一个flink集群，这时候数据源kafka或者hdfs会在同一个集群上吗，还是会单独再起一个hdfs/kafka集群](https://t.zsxq.com/7MJujMb)\n\n146、[flink kafka sink 的FlinkFixedPartitioner 分配策略，在并行度小于topic的partitions时，一个并行实例固定的写消息到固定的一个partition，那么就有一些partition没数据写进去？](https://t.zsxq.com/6U7QFMj)\n\n147、[基于事件时间，每五分钟一个窗口，五秒钟滑动一次，同时watermark的时间同样是基于事件事件时间的，延迟设为1分钟，假如数据流从12：00开始，如果12：07-12：09期间没有产生任何一条数据，即在12：07-12：09这段间的数据流情况为···· （12：07:00，xxx）,(12:09:00,xxx)······，那么窗口[12:02:05-12:07:05]，[12:02:10-12:07:10]等几个窗口的计算是否意味着只有等到，12：09：00的数据到达之后才会触发](https://t.zsxq.com/fmq3fYF)\n\n148、[使用flink1.7，当消费到某条消息(protobuf格式)，报Caused by: org.apache.kafka.common.KafkaException: Record batch for partition Notify-18 at offset 1803009 is invalid, cause: Record is corrupt 这个异常。 如何设置跳过已损坏的消息继续消费下一条来保证业务不终断？ 我看了官网kafka connectors那里，说在DeserializationSchema.deserialize(...)方法中返回null，flink就会跳过这条消息，然而依旧报这个异常](https://t.zsxq.com/MRvv3ZV)\n\n149、[是否可以抽空总结一篇Flink 的 watermark 的原理案例？一直没搞明白基于事件时间处理时的数据乱序和数据迟到底咋回事](https://t.zsxq.com/MRJeAuj)\n\n150、[flink中rpc通信的原理，与几个类的讲解，有没有系统详细的文章样，如有求分享，谢谢](https://t.zsxq.com/2rJyNrF)\n\n151、[Flink中如何使用基于事件时间处理，但是又不使用Watermarks? 我在会话窗口中使用遇到一些问题，图一是基于处理时间的，测试结果session是基于keyby(用户)的，图二是基于事件时间的，不知道是我用法不对还是怎么的，测试结果发现并不是基于keyby(用户的)，而是全局的session。不知道怎么修改？](https://t.zsxq.com/bM3ZZRf)\n\n152、[flink实时计算平台，yarn模式日志收集怎么做，为什么会checkpoint失败，报警处理，后需要做什么吗？job监控怎么做](https://t.zsxq.com/BMVzzzB)\n\n153、[有flink与jstorm的在不同应用场景下, 性能比较的数据吗? 从网络上能找大部分都是flink与storm的比较. 在jstorm官网上有一份比较的图表, 感觉参考意义不大, 应该是比较早的flink版本.](https://t.zsxq.com/237EAay)\n\n154、[为什么使用SessionWindows.withGap窗口的话，State存不了东西呀，每次加1 ，拿出来都是null, 我换成 TimeWindow就没问题。](https://t.zsxq.com/J6eAmYb)\n\n155、[请问一下，flink datastream流处理怎么统计去重指标？  官方文档中只看到批处理有distinct概念。](https://t.zsxq.com/y3nYZrf)\n\n156、[好全的一篇文章，对比分析 Flink，Spark Streaming，Storm 框架](https://t.zsxq.com/qRjqFY3)\n\n157、[关于 structured_streaming 的 paper](https://t.zsxq.com/Eau7qNB)\n\n158、[zookeeper集群切换领导了，flink集群项目重启了就没有数据的输入和输出了，这个该从哪方面入手解决？](https://t.zsxq.com/rFYbEeq)\n\n159、[我想请教下datastream怎么和静态数据join呢](https://t.zsxq.com/nEAaYNF)\n\n160、[时钟问题导致收到了明天的数据，这时候有什么比较好的处理方法？看到有人设置一个最大的跳跃阈值，如果当前数据时间 - 历史最大时间 超过阈值就不更新。如何合理的设计水印，有没有一些经验呢？](https://t.zsxq.com/IAAeiA6)\n\n161、[大佬们flink怎么定时查询数据库？](https://t.zsxq.com/EuJ2RRf)\n\n162、[现在我们公司有个想法，就是提供一个页面，在页面上选择source sink 填写上sql语句，然后后台生成一个flink的作业，然后提交到集群。功能有点类似于华为的数据中台，就是页面傻瓜式操作。后台能自动根据相应配置得到结果。请问拘你的了解，可以实现吗？如何实现？有什么好的思路。现在我无从下手](https://t.zsxq.com/vzZBmYB)\n\n163、[请教一下 flink on yarn 的 ha机制](https://t.zsxq.com/VRFIMfy)\n\n164、[在一般的流处理以及cep, 都可以对于eventtime设置watermark, 有时可能需要设置相对大一点的值, 这内存压力就比较大, 有没有办法不应用jvm中的内存, 而用堆外内存, 或者其他缓存, 最好有cache机制, 这样可以应对大流量的峰值.](https://t.zsxq.com/FAiiEyr)\n\n165、[请教一个flink sql的问题。我有两个聚合后的流表A和B，A和Bjoin得到C表。在设置state TTL 的时候是直接对C表设置还是，对A表和B表设置比较好？](https://t.zsxq.com/YnI2F66)\n\n166、[spark改写为flink，会不会很复杂，还有这两者在SQL方面的支持差别大吗？](https://t.zsxq.com/unyneEU)\n\n167、[请问flink allowedLateness导致窗口被多次fire，最终数据重复消费，这种问题怎么处理，数据是写到es中](https://t.zsxq.com/RfyZFUR)\n\n168、[设置taskmanager.numberOfTaskSlots: 4的时候没有问题，但是cpu没有压上去，只用了30%左右，于是设置了taskmanager.numberOfTaskSlots: 8，但是就报错误找不到其中一个自定义的类，然后kafka数据就不消费了。为什么？cpu到多少合适？slot是不是和cpu数量一致是最佳配置？kafka分区数多少合适，是不是和slot,parallesim一致最佳？](https://t.zsxq.com/bIAEyFe)\n\n169、[需求是根据每条日志切分出需要9个字段，有五个指标再根据9个字段的不同组合去做计算。  第一个方法是：我目前做法是切分的9个字段开5分钟大小1分钟计算一次的滑动窗口窗口，进行一次reduce去重，然后再map取出需要的字段，然后过滤再开5分钟大小1分钟计算一次的滑动窗口窗口进行计算保存结果，这个思路遇到的问题是上一个滑动窗口会每一分钟会计算5分钟数据，到第二个窗口划定的5分钟范围的数据会有好多重复，这个思路会造成数据重复。 第二个方法是：切分的9个字段开5分钟大小1分钟计算一次的滑动窗口窗口，再pross方法里完成所有的过滤，聚合计算，但是再高峰期每分钟400万条数据，这个思路担心在高峰期flink计算不过来](https://t.zsxq.com/BUNfYnY)\n\n170、[a,b,c三个表，a和c有eventtime，a和c直接join可以，a和b join后再和c join 就会报错，这是怎么回事呢](https://t.zsxq.com/aAqBEY7)\n\n171、[自定义的source是这样的（图一所示） 使用的时候是这样的（图二所示），为什么无论 sum.print().setParallelism(2)（图2所示）的并行度设置成几最后结果都是这样的](https://t.zsxq.com/zZNNRzr)\n\n172、[刚接触flink，如有问的不合适的地方，请见谅。 1、为什么说flink是有状态的计算？ 2、这个状态是什么？3、状态存在哪里](https://t.zsxq.com/i6Mz7Yj)\n\n173、[这边用flink 1.8.1的版本，采用flink on yarn，hadoop版本2.6.0。代码是一个简单的滚动窗口统计函数，但启动的时候报错，如下图片。  （2）然后我把flink版本换成1.7.1，重新提交到2.6.0的yarn平台，就能正常运行了。 （3）我们测试集群hadoop版本是3.0，我用flink 1.8.1版本将这个程序再次打包，提交到3.0版本的yarn平台，也能正常运行。 貌似是flink 1.8.1版本与yarn 2.6.0版本不兼容造成的这个问题](https://t.zsxq.com/vNjAIMN)\n\n174、[StateBackend我使用的是MemoryStateBackend， State是怎么释放内存的，例如我在函数中用ValueState存储了历史状态信息。但是历史状态数据我没有手动释放，那么程序会自动释放么？还是一直驻留在内存中](https://t.zsxq.com/2rVbm6Y)\n\n175、[请问老师是否可以提供一些Apachebeam的学习资料 谢谢](https://t.zsxq.com/3bIEAyv)\n\n176、[flink 的 DataSet或者DataStream支持索引查询以及删除吗，像spark rdd，如果不支持的话，该转换成什么](https://t.zsxq.com/yFEyZVB)\n\n177、[关于flink的状态，能否把它当做数据库使用，类似于内存数据库，在处理过程中存业务数据。如果是数据库可以算是分布式数据库吗?是不是使用rocksdb这种存储方式才算是?支持的单库大小是不是只是跟本地机器的磁盘大小相关?如果使用硬盘存储会不会效率性能有影响](https://t.zsxq.com/VNrn6iI)\n\n178、[我这边做了个http sink，想要批量发送数据，不过现在只能用数量控制发送，但最后的几个记录没法触发发送动作，想问下有没有什么办法](https://t.zsxq.com/yfmiUvf)\n\n179、[请问下如何做定时去重计数，就是根据时间分窗口，窗口内根据id去重计数得出结果，多谢。试了不少办法，没有简单直接办法](https://t.zsxq.com/vNvrfmE)\n\n180、[我有个job使用了elastic search sink. 设置了批量5000一写入，但是看es监控显示每秒只能插入500条。是不是bulkprocessor的currentrequest为0有关](https://t.zsxq.com/rzZbQFA)\n\n181、[有docker部署flink的资料吗](https://t.zsxq.com/aIur7ai)\n\n182、[在说明KeyBy的StreamGraph执行过程时，keyBy的ID为啥是6？  根据前面说，ID是一个静态变量，每取一次就递增1，我觉得应该是3啊，是我理解错了吗](https://t.zsxq.com/VjQjqF6)\n\n183、[有没计划出Execution Graph的远码解析](https://t.zsxq.com/BEmAIQv)\n\n184、[可以分享下物理执行图怎样划分task，以及task如何执行，还有他们之间数据如何传递这块代码嘛？](https://t.zsxq.com/vVjiYJQ)\n\n185、[Flink源码和这个学习项目的结构图](https://t.zsxq.com/FyNJQbQ)\n\n186、[请问flink1.8，如何做到动态加载外部udf-jar包呢？](https://t.zsxq.com/qrjmmaU)\n\n187、[同一个Task Manager中不同的Slot是怎么交互的，比如：source处理完要传递给map的时候，如果在不同的Slot中，他们的内存是相互隔离，是怎么交互的呢？  我猜是通过序列化和反序列化对象，并且通过网络来进行交互的](https://t.zsxq.com/ZFQjQnm)\n\n188、[你们有没有这种业务场景。flink从kafka里面取数据，每一条数据里面有mongdb表A的id,这时我会在map的时候采用flink的异步IO连接A表，然后查询出A表的字段1，再根据该字段1又需要异步IO去B表查询字段2，然后又根据字段2去C表查询字段3.....像这样的业务场景，如果多来几种逻辑，我应该用什么方案最好呢](https://t.zsxq.com/YBQFufi)\n\n189、[今天本地运行flink程序，消费socket中的数据，连续只能消费两条，第三条flink就消费不了了](https://t.zsxq.com/vnufYFY)\n\n190、[源数据经过过滤后分成了两条流，然后再分别提取事件时间和水印，做时间窗口，我测试时一条流没有数据，另一条的数据看日志到了窗口操作那边就没走下去，貌似窗口一直没有等到触发](https://t.zsxq.com/me6EmM3)\n\n191、[有做flink cep的吗，有资料没？](https://t.zsxq.com/fubQrvj)\n\n192、[麻烦问一下 BucketingSink跨集群写，如果任务运行在hadoop A集群，从kafka读取数据处理后写到Hadoo B集群，即使把core-site.xml和hdfs-site.xml拷贝到代码resources下，路径使用hdfs://hadoopB/xxx，会提示ava.lang.RuntimeException: Error while creating FileSystem when initializing the state of the BucketingSink.，跨集群写这个问题  flink不支持吗？](https://t.zsxq.com/fEQVjAe)\n\n193、[想咨询下，如何对flink中的datastream和dataset进行数据采样](https://t.zsxq.com/fIMVJ2J)\n\n194、[一个flink作业经常发生oom，可能是什么原因导致的。  处理流程只有15+字段的解析，redis数据读取等操作，TM配置10g。  业务会在夜间刷数据，qps能打到2500左右~](https://t.zsxq.com/7MVjyzz)\n\n195、[我看到flink 1.8的状态过期仅支持Processing Time，那么如果我使用的是Event time那么状态就不会过期吗](https://t.zsxq.com/jA2NVnU)\n\n196、[请问我想每隔一小时统计一个属性从当天零点到当前时间的平均值，这样的时间窗该如何定义？](https://t.zsxq.com/BQv33Rb)\n\n197、[flink任务里面反序列化一个类，报ClassNotFoundException，可是包里面是有这个类的，有遇到这种情况吗？](https://t.zsxq.com/nEAiIea)\n\n198、[在构造StreamGraph，类似PartitionTransformmation 这种类型的 transform，为什么要添加成一个虚拟节点，而不是一个实际的物理节点呢？](https://t.zsxq.com/RnayrVn)\n\n199、[flink消费kafka的数据写入到hdfs中，我采用了BucketingSink 这个sink将operator出来的数据写入到hdfs文件上，并通过在hive中建外部表来查询这个。但现在有个问题，处于in-progress的文件，hive是无法识别出来该文件中的数据，可我想能在hive中实时查询进来的数据，且不想产生很多的小文件，这个该如何处理呢](https://t.zsxq.com/A2fYNFA)\n\n200、[采用Flink单机集群模式一个jobmanager和两个taskmanager，机器是单机是24核，现在做个简单的功能从kafka的一个topic转满足条件的消息到另一个topic，topic的分区是30，我设置了程序默认并发为30，现在每秒消费2w多数据，不够快，请问可以怎么提高job的性能呢？](https://t.zsxq.com/7AurJU3)\n\n201、[Flink Metric 源码分析](https://t.zsxq.com/Mnm2nI6)\n\n202、[请问怎么理解官网的这段话？按官网的例子，难道只keyby之后才有keyed state，才能托管Flink存储状态么？source和map如果没有自定义operator state的话，状态是不会被保存的？](https://t.zsxq.com/iAi6QRb)\n\n203、[想用Flink做业务监控告警，并要能够支持动态添加CEP规则，问下可以直接使用Flink CEP还是siddhi CEP? 有没有相关的资料学习下？谢谢！](https://t.zsxq.com/3rbeuju)\n\n204、[请问一下，有没有关于水印，触发器的Java方面的demo啊](https://t.zsxq.com/eYJUbm6)\n\n205、[老师，最近我们线上偶尔出现这种情况，就是40个并行度，其他有一个并行度CheckPoint一直失败，其他39个并行度都是毫秒级别就可以CheckPoint成功，这个怎么定位问题呢？还有个问题 CheckPoint的时间分为三部分 Checkpoint Duration (Async）和 Checkpoint Duration (Sync），还有个 end to end 减去同步和异步的时间，这三部分 分别指代哪块？如果发现这三者中的任意一个步骤时间长，该怎么去优化](https://t.zsxq.com/QvbAqVB)\n\n206、[我这边有个场景很依赖消费出来的数据的顺序。在源头侧做了很多处理，将kafka修改成一个分区等等很多尝试，最后消费出来的还是乱序的。能不能在flink消费的时候做处理，来保证处理的数据的顺序。](https://t.zsxq.com/JaUZvbY)\n\n207、[有一个类似于实时计算今天的pv，uv需求，采用source->keyby->window->trigger->process后，在process里采用ValueState计算uv  ,问题是 这个window内一天的所有数据是都会缓存到flink嘛？ 一天的数据量如果大点，这样实现就有问题了，  这个有其他的实现思路嘛？](https://t.zsxq.com/iQfaAeu)\n\n208、[Flink 注解源码解析](https://t.zsxq.com/f6eAu3J)\n\n209、[如何监控 Flink 的 TaskManager 和 JobManager](https://t.zsxq.com/IuRJYne)\n\n210、[问下，在真实流计算过程中，并行度的设置，是与 kafka topic的partition数一样的吗？](https://t.zsxq.com/v7yfEIq)\n\n211、[Flink的日志 如果自己做平台封装在自己的界面中 请问job Manger 和 taskManger 还有用户自己的程序日志 怎么获取呢 有api还是自己需要利用flume 采集到ELK？](https://t.zsxq.com/Zf2F6mM)\n\n212、[我想问下一般用Flink统计pv uv是怎么做的？uv存到redis? 每个uv都存到redis，会不会撑爆？](https://t.zsxq.com/72VzBEy)\n\n213、[Flink的Checkpoint 机制，在有多个source的时候，barrier n 的流将被暂时搁置，从其他流接收的记录将不会被处理，但是会放进一个输入缓存input buffer。如果被缓存的record大小超出了input buffer会怎么样？不可能一直缓存下去吧，如果其中某一条就一直没数据的话，整个过程岂不是卡死了？](https://t.zsxq.com/zBmm2fq)\n\n214、[公司想实时展示订单数据，汇总金额，并需要和前端交互，实时生成数据需要告诉前端，展示成折线图，这种场景的技术选型是如何呢？包括数据的存储，临时汇总数据的存储，何种形式告诉前端](https://t.zsxq.com/ZnIAi2j)\n\n215、[请问下checkpoint中存储了哪些东西？](https://t.zsxq.com/7EIeEyJ)\n\n216、[我这边有个需求是实时计算当前车辆与前车距离，用经纬度求距离。大概6000台车，10秒一条经纬度数据。gps流与自己join的地方在进行checkpoint的时候特别缓，每次要好几分钟。checkpoint 状态后端是rocksDB。有什么比较好的方案吗？自己实现一个类似last_value的函数取车辆最新的经纬再join，或者弄个10秒的滑动窗口输出车辆最新的经纬度再进行join，这样可行吗？](https://t.zsxq.com/euvFaYz)\n\n217、[flink在启动的时候能不能指定一个时间点从kafka里面恢复数据呢](https://t.zsxq.com/YRnEUFe)\n\n218、[我们线上有个问题，很多业务都去读某个hive表，但是当这个hive表正在写数据的时候，偶尔出现过 读到表里数据为空的情况，这个问题怎么解决呢？](https://t.zsxq.com/7QJEEyr)\n\n219、[使用 InfluxDB 和 Grafana 搭建监控 Flink 的平台](https://t.zsxq.com/yVnaYR7)\n\n220、[flink消费kafka两个不同的topic,然后进行join操作，如果使用事件时间，两个topic都要设置watermaker吗，如果只设置了topic  A的watermaker,topic B的不设置会有什么影响吗？](https://t.zsxq.com/uvFU7aY)\n\n221、[请教一个问题，我的Flink程序运行一段时间就会报这个错误，定位好多天都没有定位到。checkpoint 时间是5秒，20秒都不行。Caused by: java.io.IOException: Could not flush and close the file system output stream to hdfs://HDFSaaaa/flink/PointWideTable_OffTest_Test2/1eb66edcfccce6124c3b2d6ae402ec39/chk-355/1005127c-cee3-4099-8b61-aef819d72404 in order to obtain the stream state handle](https://t.zsxq.com/NNFYJMn)\n\n222、[Flink的反压机制相比于Storm的反压机制有什么优势呢？问题2: Flink的某一个节点发生故障，是否会影响其他节点的正常工作？还是会通过Checkpoint容错机制吗把任务转移到其他节点去运行呢？](https://t.zsxq.com/yvRNFEI)\n\n223、[我在验证checkpoint的时候遇到给问题，不管是key state 还是operator state，默认和指定uid是可以的恢复state数据的，当指定uidHash时候无法恢复state数据，麻烦大家给解答一样。我操作state是实现了CheckpointedFunction接口，覆写snapshotState和initializeState，再这两个方法里操作的，然后让程序定时抛出异常，观察发现指定uidHash后snapshotState()方法里context.isRestored()为false，不太明白具体是什么原因](https://t.zsxq.com/ZJmiqZz)\n\n224、[kafka 中的每条数据需要和 es 中的所有数据(动态增加)关联，关联之后会做一些额外的操作，这个有什么比较可行的方案？](https://t.zsxq.com/mYV37qF)\n\n225、[flink消费kafka数据，设置1分钟checkpoint一次，假如第一次checkpoint完成以后，还没等到下一次checkpoint，程序就挂了，kafka offset还是第一次checkpoint记录的offset,那么下次重新启动程序，岂不是多消费数据了？那flink的 exactly one消费语义是怎么样的？](https://t.zsxq.com/buFeyZr)\n\n226、[程序频繁发生Heartbeat of TaskManager with id container_e36_1564049750010_5829_01_000024 timed out. 心跳超时，一天大概10次左右。是内存没给够吗？还是网络波动引起的](https://t.zsxq.com/Znyja62)\n\n227、[有没有性能优化方面的指导文章？](https://t.zsxq.com/AA6ma2Z)\n\n228、[flink消费kafka是如何监控消费是否正常的，有啥好办法？](https://t.zsxq.com/a2N37a6)\n\n229、[我按照官方的wordcount案例写了一个例子，然后在main函数中起了一个线程，原本是准备定时去更新某些配置，准备测试一下是否可行，所以直接在线程函数中打印一条语句测试是否可行。现在测试的结果是不可行，貌似这个线程根本就没有执行，请问这是什么原因呢？   按照理解，JobClient中不是反射类执行main函数吗， 执行main函数的时候为什么没有执行这个线程的打印函数呢？](https://t.zsxq.com/m2FeeMf)\n\n230、[请问我想保留最近多个完成的checkpoint数据，是通过设置 state.checkpoints.num-retained 吗？要怎么使用？](https://t.zsxq.com/EyFUb6m)\n\n231、[有没有etl实时数仓相关案例么？比如二十张事实表流join](https://t.zsxq.com/rFeIAeA)\n\n232、[为什么我扔到flink 的stream job，立刻就finished](https://t.zsxq.com/n2RFmyN)\n\n233、[有没有在flink上机器学习算法的一些例子啊，除了官网提供的flink exampke里的和flink ml里已有的](https://t.zsxq.com/iqJiyvN)\n\n234、[如果我想扩展sql的关键词，比如添加一些数据支持，有什么思路，现在想的感觉都要改calcite（刚碰flink感觉难度太大了）](https://t.zsxq.com/uB6aUzZ)\n\n235、[我想实现统计每5秒中每个类型的次数，这个现在不输出，问题出在哪儿啊](https://t.zsxq.com/2BEeu3Z)\n\n236、[我用flink往hbase里写数据，有那种直接批量写hfile的方式的demo没](https://t.zsxq.com/VBA6IUR)\n\n237、[请问怎么监控Kafka消费是否延迟，是否出现消息积压？你有demo吗？这种是用Springboot自己写一个监控，还是咋整啊？](https://t.zsxq.com/IieMFMB)\n\n238、[请问有计算pv uv的例子吗](https://t.zsxq.com/j2fM3BM)\n\n239、[通过控制流动态修改window算子窗口类型和长度要怎么写](https://t.zsxq.com/Rb2Z7uB)\n\n240、[flink的远程调试能出一版么？网上资料坑的多](https://t.zsxq.com/UVbaQfM)\n\n241、[企业里，Flink开发，java用得多，还是scala用得多？](https://t.zsxq.com/AYVjAuB)\n\n242、[flink的任务运行在yarn的环境上，在yarn的resourcemanager在进行主备切换时，所有的flink任务都失败了，而MR的任务可以正常运行。报错信息如下：AM is not registered for known application attempt: appattempt_1565306391442_89321_000001 or RM had restarted after AM registered . AM should re-register\n     请问这是什么原因，该如何处理呢？](https://t.zsxq.com/j6QfMzf)\n     \n243、[请教一个分布式问题，比如在Flink的多个TaskManager上统计指标count，TM1有两条数据，TM2有一条数据，程序是怎么计算出来是3呢？原理是怎么样的](https://t.zsxq.com/IUVZjUv)\n\n244、[现在公司部分sql查询oracle数据特别的慢，因为查询条件很多想问一下有什么方法，例如基于大数据组件可以加快查询速度的吗？](https://t.zsxq.com/7MFEQR3)\n\n245、[想咨询下有没有做过flink同步配置做自定义计算的系统？或者有没有什么好的建议？业务诉求是希望业务用户可以自助配置计算规则做流式计算](https://t.zsxq.com/Mfa6aQB)\n\n246、[我这边有个实时同步数据的任务，白天运行的时候一直是正常的，一到凌晨2点多之后就没有数据sink进mysql。晚上会有一些离线任务和一些dataX任务同步数据到mysql。但是任务一切都是正常的，ck也很快20ms，数据也是正常消费。看了yarn上的日志，没有任何error。自定义的sink里面也设置了日志打印，但是log里没有。这种如何快速定位问题。](https://t.zsxq.com/z3bunyN)\n\n247、[有没有flink处理异常数据的案例资料](https://t.zsxq.com/Y3fe6Mn)\n\n248、[flink中如何传递一个全局变量](https://t.zsxq.com/I2Z7Ybm)\n\n249、[台4核16G的Flink taskmanager配一个单独的Yarn需要一台啥样的服务器？其他功能都不需要就一个调度的东西？](https://t.zsxq.com/iIUZrju)\n\n250、[side-output 的分享](https://t.zsxq.com/m6I2BEE)\n\n251、[使用 InfluxDB + Grafana 监控flink能否配置告警。是不是prometheus更强大点？](https://t.zsxq.com/amURFme)\n\n252、[我们线上遇到一个问题，带状态的算子没有指定 uid，现在代码必须改，那个带状态的算子 不能正常恢复了，有解吗？通过某种方式能获取到系统之前自动生成的uid吗？](https://t.zsxq.com/rZfyZvn)\n\n253、[tableEnv.registerDataStream("Orders", ds, "user, product, amount, proctime.proctime, rowtime.rowtime");请问像这样把流注册成表的时候，这两个rowtime分别是什么意思](https://t.zsxq.com/uZz3Z7Q)\n\n254、[我想问一下 flink on yarn session 模式下提交任务官网给的例子是 flink run -c xxx.MainClass job.jar 这里是怎么知道 yarn 上的哪个是 flink 的 appid 呢？](https://t.zsxq.com/yBiEyf2)\n\n255、[Flink Netty Connector 这个有详细的使用例子？ 通过Netty建立的source能直接回复消息吗？还是只能被动接受消息？](https://t.zsxq.com/yBeyfqv)\n\n256、[请问flink sqlclient 提交的作业可以用于生产环境吗？](https://t.zsxq.com/FIEia6M)\n\n257、[flink批处理写回mysql是否没法用tableEnv.sqlUpdate("insert into t2 select * from t1")？作为sink表的t2要如何注册？查跟jdbc相关的就两个TableSink，JDBCAppendTableSink用于BatchTableSink，JDBCUpertTablSink用于StreamTableSink。前者只接受insert into  values语法。所以我是先通过select from查询获取到DataSet再JDBCAppendTableSink.emitDataSet(ds)实现的，但这样达不到sql rule any目标](https://t.zsxq.com/ZBIaUvF)\n\n258、[请问在stream模式下，flink的计算结果在不落库的情况下，可以通过什么restful api获取计算结果吗](https://t.zsxq.com/aq3BIU7)\n\n259、[现在我有场景，需要把一定的消息发送给kafka topic指定的partition，该怎么搞？](https://t.zsxq.com/NbYnAYF)\n\n260、[请问我的job作业在idea上运行正常 提交到生产集群里提示Caused by: java.lang.NoSuchMethodError: org.apache.flink.api.java.ClosureCleaner.clean(Ljava/lang/Object;Z)V请问如何解决](https://t.zsxq.com/YfmAMfm)\n\n261、[遇到一个很奇怪的问题，在使用streamingSQL时，发现timestamp在datastream的时候还是正常的，在注册成表print出来的时候就少了八小时，大佬知道是什么原因么？](https://t.zsxq.com/72n6MVb)\n\n262、[请问将flink的产生的一些记录日志异步到kafka中，需要如何配置，配置后必须要重启集群才会生效吗](https://t.zsxq.com/RjQFmIQ)\n\n263、[星主你好，问下flink1.9对维表join的支持怎么样了？有文档吗](https://t.zsxq.com/Q7u3vzR)\n\n264、[请问下 flink slq： SELECT city_name as city_name, count(1) as total, max(create_time) as create_time FROM * 。代码里面设置窗口为： retractStream.timeWindowAll(Time.minutes(5))一个global窗口，数据写入hdfs   结果数据重复 ，存在两条完全重复的数据如下 常州、2283、 1566230703）：请问这是为什么](https://t.zsxq.com/aEEA66M)\n\n265、[我用rocksdb存储checkpoint，线上运行一段时间发展checkpoint占用空间越来越大，我是直接存本地磁盘上的，怎么样能让它自动清理呢？](https://t.zsxq.com/YNrfyrj)\n\n266、[flink应该在哪个用户下启动呢，是root的还是在其他的用户呢](https://t.zsxq.com/aAaqFYn)\n\n267、[link可以读取lzo的文件吗](https://t.zsxq.com/2nUBIAI)\n\n268、[怎么快速从es里面便利数据？我们公司现在所有的数据都存在Es里面的;我发现每次从里面scan数据的时候特别慢;你那有没有什么好的办法？](https://t.zsxq.com/beIY7mY)\n\n269、[如果想让数据按照其中一个假如f0进行分区，然后每一个分区做处理的时候并行度都是1怎么设置呢](https://t.zsxq.com/fYnYrR7)\n\n270、[近在写算子的过程中,使用scala语言写flink比较快,而且在process算子中实现ontime方式时,可以使用scala中的listbuff来输出一个top3的记录;那么到了java中,只能用ArrayList将flink中的ListState使用get()方法取出之后放在ArrayList吗?](https://t.zsxq.com/nQFYrBm)\n\n271、[请问老师能否出一些1.9版本维表join的例子 包括async和维表缓存？](https://t.zsxq.com/eyRRv7q)\n\n272、[flink kaka source设置为从组内消费，有个问题是第一次启动任务，我发现kafka中的历史数据不会被消费，而是从当前的数据开始消费，而第二次启动的时候才会从组的offset开始消费，有什么办法可以让第一次启动任务的时候可以消费kafka中的历史数据吗](https://t.zsxq.com/aMRzjMb)\n\n273、[1.使用flink定时处理离线数据，有时间戳字段，如何求出每分钟的最大值，类似于流处理窗口那样，2如果想自己实现批流统一，有什么好的合并方向吗？比如想让流处理使用批处理的一个算子。](https://t.zsxq.com/3ZjiEMv)\n\n274、[flink怎么实现流式数据批量对待？流的数据是自定义的source，读取的redis多个Hash表，需要控制批次的概念](https://t.zsxq.com/AIYnEQN)\n\n275、[有人说不推荐在一个task中开多个线程，这个你怎么看？](https://t.zsxq.com/yJuFEYb)\n\n276、[想做一个运行在hbase+es架构上的sql查询方案，flink sql能做吗，或者有没有其他的解决方案或者思路？](https://t.zsxq.com/3f6YBmu)\n\n277、[正在紧急做第一个用到Flink的项目，咨询一下，Flink 1.8.1写入ES7就是用自带的Sink吗？有没有例子分享一下，我搜到的都是写ES6的。这种要求我知道不适合提，主要是急，自己试几下没成功。T T](https://t.zsxq.com/jIAqVnm)\n\n278、[手动停止任务后，已经保存了最近一次保存点，任务重新启动后，如何使用上一次检查点？](https://t.zsxq.com/2fAiuzf)\n\n279、[批处理使用流环境（为了使用窗口），那如何确定批处理结束，就是我的任务可以知道批文件读取完事，并且处理完数据后关闭任务，如果不能，那批处理如何实现窗口功能](https://t.zsxq.com/BIiImQN)\n\n280、[如果限制只能在window 内进行去重，数据量还比较大，有什么好的方法吗？](https://t.zsxq.com/Mjyzj66)\n\n281、[端到端exactly once有没有出文章](https://t.zsxq.com/yv7Ujme)\n\n282、[流怎么动态加？，流怎么动态删除？，参数怎么动态修改 （广播](https://t.zsxq.com/IqNZFey)\n\n283、[自定义的source数据源实现了有批次的概念，然后Flink将这个一个批次流注册为多个表join操作，有办法知道这个sql什么时候计算完成了？](https://t.zsxq.com/r7AqvBq)\n\n284、[编译 Flink 报错，群主遇到过没，什么原因](https://t.zsxq.com/rvJiyf6)\n\n285、[我现在是flink on yarn用zookeeper做HA现在在zk里查看检查点信息，为什么里面的文件是ip，而不是路径呢？我该如何拿到那个路径。\n     - 排除rest api 方式获取，因为任务关了restapi就没了\n     -排除history server，有点不好用](https://t.zsxq.com/nufIaey)\n     \n286、[在使用streamfilesink消费kafka之后进行hdfs写入的时候，当直接关闭flink程序的时候，下次再启动程序消费写入hdfs的时候，文件又是从part-0-0开始，这样就跟原来写入的冲突了，该文件就一直处于ingress状态。](https://t.zsxq.com/Fy3RfE6)\n\n287、[现在有一个实时数据分析的需求，数据量不大，但要求sink到mysql，因为是实时更新的，我现在能想到的处理方法就是每次插入一条数据的时候，先从mysql读数据，如果有这条，就执行update，没有的话就insert，但是这样的话每写一条数据就有两次交互了。想问一下老师有没有更好的办法，或者flink有没有内置的api可以执行这种不确定是更新还是插入的操作](https://t.zsxq.com/myNF2zj)\n\n288、[Flink设置了checkpoint，job manage会定期删除check point数据，但是task manage不删除，这个是什么原因](https://t.zsxq.com/ZFiMzrF)\n\n289、[请教一下使用rocksdb作为statebackend ，在哪里可以监控rocksdb io 内存指标呢](https://t.zsxq.com/z3RzJUV)\n\n290、[状态的使用场景，以及用法能出个文章不，这块不太了解](https://t.zsxq.com/AUjE2ZR)\n\n291、[请问一下  Flink 1.9  SQL API中distinct count 是如何实现高效的流式去重的？](https://t.zsxq.com/aaynii6)\n\n292、[在算子内如何获取当前算子并行度以及当前是第几个task](https://t.zsxq.com/mmEyVJA)\n\n293、[有没有flink1.9结合hive的demo。kafka到hive](https://t.zsxq.com/fIqNF6y)\n\n294、[能给讲讲apache calcite吗](https://t.zsxq.com/ne6UZrB)\n\n295、[请问一下像这种窗口操作，怎么保证程序异常重启后保持数据的状态呢？](https://t.zsxq.com/VbUVFMr)\n\n296、[请问一下，我在使用kafkasource的时候，把接过来的Jsonstr转化成自定义的一个类型，用的是gson. fromJson（jsonstr,classOf[Entity]）报图片上的错误了，不知道怎么解决，在不转直接打印的情况下是没问题的](https://t.zsxq.com/EMZFyZz)\n\n297、[DataStream读数据库的表，做多表join，能设置时间窗口么，一天去刷一次。流程序会一直拉数据，数据库扛不住了](https://t.zsxq.com/IEieI6a)\n\n298、[请问一下flink支持多路径通配读取吗？例如路径：s3n://pekdc2-deeplink-01/Kinesis/firehose/2019/07/03/*/*  ，通配读取找不到路径。是否需要特殊设置](https://t.zsxq.com/IemmiY7)\n\n299、[flink yarn环境部署 但是把容器的url地址删除。就会跳转到的hadoop的首页。怎么屏蔽hadoop的yarn首页地址呢？要不暴露这个地址用户能看到所有任务很危险](https://t.zsxq.com/QvZFUNN)\n\n300、[flink sql怎么写一个流，每秒输出当前时间呢](https://t.zsxq.com/2JiubeM)\n\n301、[因为想通过sql弄一个数据流。哈哈 另外想问一个问题，我把全局设置为根据处理时间的时间窗口，那么我在processAllWindowFunction里面要怎么知道进来的每个元素的处理时间是多少呢？这个元素进入这个时间窗口的依据是什么](https://t.zsxq.com/bQ33BmM)\n\n302、[如何实现一个设备上报的数据存储到同一个hdfs文件中？](https://t.zsxq.com/rB6ybYF)\n\n303、[我自己写的kafka生产者测试，数据格式十分简单（key,i）key是一个固定的不变的字符串，i是自增的，flink consumer这边我开了checkpoint. 并且是exactly once，然后程序很简单，就是flink读取kafka的数据然后直接打印出来，我发现比如我看到打印到key，10的时候我直接关掉程序，然后重新启动程序，按理来说应当是从上次的offset继续消费，也就是key,11，但实际上我看到的可能是从key，9开始，然后依次递增，这是是不是说明是重复消费了，那exactly one需要怎么样去保障？](https://t.zsxq.com/MVfeeiu)\n\n304、[假设有一个数据源在源源不断的产生数据，到Flink的反压来到source端的时候，由于Flink处理数据的速度跟不上数据源产生数据的速度，\n     问题1: 这个时候在Flink的source端会怎么处理呢？是将处理不完的数据丢弃还是进行缓存呢？\n     问题2: 如果是缓存，怎么进行缓存呢？](https://t.zsxq.com/meqzJme)\n     \n305、[一个stream 在sink多个时，这多个sink是串行 还是并行的。](https://t.zsxq.com/2fEeMny)\n\n306、[我想在流上做一个窗口，触发窗口的条件是固定的时间间隔或者数据量达到预切值，两个条件只要有一个满足就触发，除了重写trigger在，还有什么别的方法吗？](https://t.zsxq.com/NJY76uf)\n\n307、[使用rocksdb作为状态后端，对于使用sql方式对时间字段进行group by，以达到去窗口化，但是这样没办法对之前的数据清理，导致磁盘空间很大，对于这种非编码方式，有什么办法设置ttl，清理以前的数据吗](https://t.zsxq.com/A6UN7eE)\n\n308、[请问什么时间窗为什么会有TimeWindow{start=362160000, end=362220000}\n     和 TimeWindow{start=1568025300000, end=1568025360000}这两种形式，我都用的是一分钟的TumblingEventTimeWindows，为什么会出现不同的情况？](https://t.zsxq.com/a2fUnEM)\n     \n309、[比如我统计一天的订单量。但是某个数据延迟一天才到达。比如2019.08.01这一天订单量应该是1000，但是有个100的单据迟到了，在2019.08.02才到达，那么导致2019.08.01这一天统计的是900.后面怎么纠正这个错误的结果呢](https://t.zsxq.com/Y3jqjuj)\n\n310、[flink streaming 模式下只使用堆内内存么](https://t.zsxq.com/zJaMNne)\n\n311、[如果考虑到集群的迁移，状态能迁移吗](https://t.zsxq.com/EmMrvVb)\n\n312、[我们现在有一个业务场景，数据上报的值是这样的格式（时间，累加值），我们需要这样的格式数据（时间，当前值）。当前值=累加值-前一个数据的累加值。flink如何做到呢，有考虑过state机制，但是服务宕机后，state就被清空了](https://t.zsxq.com/6EUFeqr)\n\n313、[Flink  On  k8s 与 Flink on  Yarn相比的优缺点是什么？那个更适合在生产环境中使用呢](https://t.zsxq.com/y7U7Mzf)\n\n314、[有没有datahub链接flink的 连接器呀](https://t.zsxq.com/zVNbaYn)\n\n315、[单点resourcemanager 挂了，对任务会产生什么影响呢](https://t.zsxq.com/FQRNJ2j)\n\n316、[flink监控binlog,跟另一张维表做join后，sink到MySQL的最终表。对于最终表的增删改操作，需要定义不同的sink么？](https://t.zsxq.com/rnemUN3)\n\n317、[请问窗口是在什么时候合并的呢？例如：数据进入windowoperator的processElement，如果不是sessionwindow，是否会进行窗口合并呢？](https://t.zsxq.com/JaaQFqB)\n\n318、[Flink中一条流能参与多路计算，并多处输出吗？他们之前会不会相互影响？](https://t.zsxq.com/AqNFM33)\n\n319、[keyBy算子定义是将一个流拆分成不相交的分区，每个分区包含具有相同的key的元素。我不明白的地方是: keyBy怎么设置分区数，是给这个算子设置并行度吗？ 分区数和slot数量是什么关系？](https://t.zsxq.com/nUzbiYj)\n\n320、[动态cep-pattern，能否详细说下？滴滴方案未公布，您贴出来的几张图片是基于1.7的。或者有什么想法也可以讲解下，谢谢了](https://t.zsxq.com/66URfQb)\n\n321、[问题1：使用常驻型session ./bin/yarn-session.sh -n 10 -s 3 -d启动，这个时候分配的资源是yarn 队列里面的, flink提交任务 flink run xx.jar,  其余机器是怎样获取到flink需要运行时的环境的，因为我只在集群的一台机器上有flink 安装包。](https://t.zsxq.com/maEQ3NR)\n\n322、[flink task manager中slot间的内存隔离，cpu隔离是怎么实现的？flink 设计slot的概念有什么意义，为什么不像spark executor那样，内部没有做隔离？](https://t.zsxq.com/YjEYjQz)\n\n323、[spark和kafka集成，direct模式，spark的一个分区对应kafka的一个主题的一个分区。那flink和kafka集成的时候，怎么消费kafka的数据，假设kafka某个主题5个partition](https://t.zsxq.com/nuzvVzZ)\n\n324、[./bin/flink run -m yarn-cluster 执行的flink job ，作业自己打印的日志通过yarn application的log查看不了，只有集群自身的日志，程序中logger.info打印日志存放在哪，还是我打包的方式问题，打日志用的是slf4j。](https://t.zsxq.com/27u3ZZf)\n\n325、[在物联网平台中，需要对每个key下的数据做越限判断，由于每个key的越限值是不同的，越限值配置在实时数据库中。\n     若将越限值加载到state中，由于key的量很大（大概3亿左右），会导致state太大，可能造成内存溢出。若在处理数据时从实时数据库中读取越限值，由于网络IO开销，可能造成实时性下降。请问该如何处理？谢谢](https://t.zsxq.com/miuzFY3)\n     \n326、[如果我一个flink程序有多个window操作，时间戳和watermark是不是每个window都需要分配，还有就是事件时间是不是一定要在数据源中就存在某个字段](https://t.zsxq.com/amURvZR)\n\n327、[有没有flink1.9刚支持的用ddl链接kafka并写入hbase的资料，我们公司想把离线的数仓逐渐转成实时的，写sql对于我们来说上手更快一些，就想找一些这方面的资料学习一下。](https://t.zsxq.com/eqFuBYz)\n\n328、[flink1.9 进行了数据类型的转化时发生了不匹配的问题，  目前使用的Type被弃用，推荐使用是datatypes 类型，但是之前使用的Type类型的方法 对应的schema typeinformation 目前跟datatypes的返回值不对应，请问下  该怎么去调整适配？](https://t.zsxq.com/yVvR3V3)\n\n329、[link中处理数据其中一条出了异常都会导致整个job挂掉?有没有方法(除了异常捕获)让这条数据记录错误日志就行 下面的数据接着处理呢? 粗略看过一些容错处理，是关于程度挂了重启后从检查点拉取数据，但是如果这条数据本身就问提(特别生产上，这样就导致job直接挂了，影响有点大)，那应该怎么过滤掉这条问题数据呢(异常捕获是最后的方法](https://t.zsxq.com/6AIQnEi)\n\n330、[我在一个做日报的统计中使用rabbitmq做数据源，为什么rabbitmq中的数据一直处于unacked状态，每分钟触发一次窗口计算，并驱逐计算过的元素，我在测试环境数据都能ack,但是一到生产环境就不行了，也没有报错，有可能是哪里出了问题啊](https://t.zsxq.com/RBmi2vB)\n\n331、[我们目前数据流向是这样的，kafka source ，etl，redis sink 。这样chk 是否可以保证端到端语义呢？](https://t.zsxq.com/fuNfuBi)\n\n332、[1.在通过 yarn-session 提交 flink job 的时候。flink-core, flink-clients, flink-scala, flink-streaming-scala, scala-library, flink-connector-kafka-0.10 那些应该写 provided scope，那些应该写 compile scope，才是正确、避免依赖冲突的姿势？\n    2.flink-dist_2.11-1.8.0.jar 究竟包含了哪些依赖？（这个文件打包方式不同于 springboot，无法清楚看到有哪些 jar 依赖）](https://t.zsxq.com/mIeMzvf)\n    \n333、[Flink 中使用 count window 会有这样的问题就是，最后有部分数据一直没有达到 count 的值，然后窗口就一直不触发，这里看到个思路，可以将 time window + count window 组合起来](https://t.zsxq.com/AQzj6Qv)\n\n334、[flink流处理时，注册一个流数据为Table后，该流的历史数据也会一直在Table里面么？为什么每次来新数据，历史处理过得数据会重新被执行？](https://t.zsxq.com/VvR3Bai)\n\n335、[available是变化数据，除了最新的数据被插入数据库，之前处理过数据又重新执行了几次](https://t.zsxq.com/jMfyNZv)\n\n336、[这里两天在研究flink的广播变量，发现一个问题，DataSet数据集中获取广播变量，获取的内存地址是一样的（一台机器维护一个广播数据集）。在DataStream中获取广播变量就成了一个task维护一个数据集。（可能是我使用方式有问题）  所以想请教下星主，DataStream中获取一个画面变量可以如DataSet中一台机器维护一个数据吗？](https://t.zsxq.com/m6Yrv7Q)\n\n337、[Flink程序开启checkpoint 机制后，用yarn命令多次killed以后，ckeckpoint目录下有多个job id，再次开辟资源重新启动程序，程序如何找到上一次jobid目录下，而不是找到其他的jobid目录下？默认是最后一个还是需要制定特定的jobid？](https://t.zsxq.com/nqzZrbq)\n\n338、[发展昨天的数据重复插入问题，是把kafka里进来的数据流registerDataStream注册为Table做join时，打印表的长度发现，数据会一直往表里追加，怎样才能来一条处理一条，不往上追加呀](https://t.zsxq.com/RNzfQ7e)\n\n339、[flink1.9 sql 有没有类似分区表那样的处理方式呢？我们现在有一个业务是1个source，但是要分别计算5分钟，10分钟，15分钟的数据。](https://t.zsxq.com/AqRvNNj)\n\n340、[我刚弄了个服务器，在启动基础的命令时候发现task没有启动起来，导致web页是三个0，我看了log也没有报错信息，请问您知道可能是什么问题吗？](https://t.zsxq.com/q3feIuv)\n\n241、[我自定义了个 Sink extends RichSinkFunction，有了 field： private transient Object lock;\n     这个 lock 我直接初始化  private transient Object lock = new Object(); 就不行，在 invoke 里 使用lock时空指针，如果lock在 自定义 Sink 的 构造器初始化也不行。但是在 open 方法里初始化就可以，为什么？能解释一下 执行原理吗？如果一个slot 运行着5个 sink实例，那么 这个sink对象会new 5个还是1个？](https://t.zsxq.com/EIiyjeU)\n     \n342、[请问Kafka的broker 个数怎么估算？](https://t.zsxq.com/aMNnIy3)\n\n343、[flink on yarn如何远程调试](https://t.zsxq.com/BU7iqbi)\n\n344、[目前有个需求：就是源数据是dataA、dataB、DataC通过kafka三个topic获取，然后进行合并。\n     但是有有几个问题，目前不知道怎么解决：\n     dataA="id:10001,info:***,date:2019-08-01 12:23:33,entry1:1,entryInfo1:***"\n     dataB="id:10001,org:***,entry:1"  dataC="id:10001,location:***"  \n     (1) 如何将三个流合并？ (1) 数据中dataA是有时间的，但是dataB和dataC中都没有时间戳，那么如何解决eventTime及迟到乱序的问题？帮忙看下，谢谢](https://t.zsxq.com/F6U7YbY)\n     \n345、[我flink从kafka读json数据，在反序列化后中文部分变成了一串问号，请问如何做才能使中文正常](https://t.zsxq.com/JmIqfaE)\n\n346、[我有好几个Flink程序（独立jar），在线业务数据分析时都会用到同样的一批MySQL中的配置数据(5千多条)，现在的实现方法是每一个程序都是独立把这些配置数据装到内存中，便于快速使用，但现在感觉有些浪费资源和结构不够美观，请问这类情况有什么其他的解决方案吗？谢谢](https://t.zsxq.com/3BMZfAM)\n\n347、[Flink  checkpoint  选 RocksDBStateBackend 还是 FsStatebackEnd ，我们目前是任务执行一段时间之后 任务就会被卡死。](https://t.zsxq.com/RFMjYZn)\n\n348、[flink on k8s的高可用、扩缩容这块目前还有哪些问题？](https://t.zsxq.com/uVv7uJU)\n\n349、[有个问题问一下，是这样的现在Kafka4个分区每秒钟生产4000多到5000条日志数据，但是在消费者FLINK这边接收我只开了4个solt接收，这边只是接收后做切分存储，现在出现了延迟现象，我不清楚是我这边处切分慢了还是Flink接收kafka的数据慢了？Flink UI界面显示这两个背压高](https://t.zsxq.com/zFq3fqb)\n\n350、[想请问一下，在flink集群模式下，能不能指定某个节点来执行一个task?](https://t.zsxq.com/NbaMjem)\n\n+ [请问一下aggrefunction 的merge方法什么时候会用到呢，google上有答案说合并相同的key， 但相同的key应该是被hash相同的task上了?这块不是很理解](https://t.zsxq.com/VnEim6m)\n\n+ [请问flink遇到这种问题怎么解决？1. eventA发起事件，eventB响应事件，每分钟统计事件的响应的成功率。说明，eventA和eventB有相同的commitId关联，eventA到flink的时间早于eventB的时间，但eventB到达的时间也有可能早于eventA。要求是：eventA有A,B,C,D,E五条数据，如果eventB有A\',B\',C\',X\',Y\'五条数据，成功率是3/5.2. 每分钟统计一次eventC成功率(状态0、1)。但该事件日志会重复报，只统计eventTime最早的一条。上一分钟统计到过的，下一分钟不再统计](https://t.zsxq.com/eMnMrRJ)\n\n+ [Flink当前版本中Yarn,k8s,standalone的HA设计方案与源码解析请问可以系统性讲讲么](https://t.zsxq.com/EamqrFQ)\n\n+ [怎么用javaAPI提交job以yarn-cluster模式运行](https://t.zsxq.com/vR76amq)\n\n+ [有人遇到过流损坏的问题么？不知道怎么着手解决？](https://t.zsxq.com/6iMvjmq)\n\n+ [从这个日志能看出什么异常的原因吗？我查看了kafka，yarn，zookeeper。这三个组件都没有任何异常](https://t.zsxq.com/uByFUrb)\n\n+ [为啥flink内部维护两套通信框架，client与jobmanager和jobmanager与taskmanager是akka通信，然而takmanager之间是netty通信？](https://t.zsxq.com/yvBiImq)\n\n+ [问各位球友一个小问题，flink 的 wordcount ，输出在控制台的时候，前面有个数字  > 是什么意思](https://t.zsxq.com/yzzBMji)\n\n+ [从kafka的topicA读数据，转换后写入topicB，开启了checkpoint，任务启动后正常运行，新的topic也有数据写入，但是想监控一下消费topicA有没有延迟，使用kafka客户端提供的脚本查看groupid相关信息，提示没有该groupid](https://t.zsxq.com/MNFUVnE)\n\n+ [将flink分流之后，再进行窗口计算，如何将多个窗口计算的结果汇总起来 作为一个sink，定时输出?\n   我想将多个流计算的不同实时统计指标，比如每1min对多个指标进行统计（多个指标分布在不同的流里面），然后将多个指标作为一条元组存入mysql中?](https://t.zsxq.com/mUfm2zF)\n\n+ [Flink最终如何输出到数据大屏上去。](https://t.zsxq.com/nimeA66)\n\n+ [为什么我keyby 之后，不同key的数据会进入同一个AggregateFunction中吗？ 还是说不同key用的AggregateFunction实列是同一个呢？我在AggregateFunction中给一个对象赋值之后，发现其他key的数据会把之前的数据覆盖，这是怎么回事啊？](https://t.zsxq.com/IMzBUFA)\n\n+ [flink窗口计算的结果怎么和之前的结果聚合在一起](https://t.zsxq.com/yFI2FYv)\n\n+ [flink on yarn 的任务该如何监控呢，之前自带 influxdb metrics 好像无法采集到flink on yarn 的指标](https://t.zsxq.com/ZZ3FmqF)\n\n+ [link1.9.0消费kafka0.10.1.1数据时，通过ui监控查看发现部分分区的current offset和commit offset一直显示为负数，随着程序运行也始终不变，麻烦问下这是怎么回事？](https://t.zsxq.com/QvRNjiU)\n\n+ [flink 1.9 使用rank的时候报，org.apache.flink.table.api.TableException: RANK() on streaming table is not supported currently](https://t.zsxq.com/Y7MBaQb)\n\n+ [Flink任务能不能动态的变更source源kafka的topic，但是又不用重启任务](https://t.zsxq.com/rzVjMjM)\n\n+ [1、keyed state 和opeater state 区分点是啥（是否进行了shuffle流程？）\n   2、CheckpointedFunction 这个接口的作用是啥？\n   3、何时调用这个snapshotState这个方法？](https://t.zsxq.com/ZVnEyne)\n\n+ [请教一下各位大佬，日志一般都怎么收集？task manager貌似把不同job的日志都打印在一起，有木有分开打印的办法？](https://t.zsxq.com/AayjeiM)\n\n+ [最近接到一个需求，统计今天累计在线人数并且要去重，每5秒显示一次结果，请问如何做这个需求？](https://t.zsxq.com/IuJ2FYR)\n\n+ [目前是flink消费kafka的一个问题。kafka使用的是阿里云的kafka，可以申请consumer。目前在同一个A-test的topic下，使用A1的consumer组进行消费，但是在两个程序里，source端得到的数据量差别很大，图一是目前消费kafka写入到另一个kafka的topic中，目前已知只有100条；图二是消费kafka，写入到hdfs中。两次消费起始偏移量一致（消费后，恢复偏移量到最初再消费）按照时间以及设置从头开始消费的策略也都还是只有100条；后面我把kafka的offset提交到checkpoint选项关掉了，也还是只有100条。很奇怪，所以想问一下，目前这个问题是要从state来出发解决](https://t.zsxq.com/eqBUZFm)\n\n+ [问一下 grafana的dashboard 有没有推荐的，我们现在用是prometheus pushgateway reporter来收集metric。但是目前来说，到底哪些指标是要重点关注的还是不太清楚](https://t.zsxq.com/EYz7iMV)\n\n+ [on yarn   1. session 模式提交是不是意味着 多个flink任务会由同一个 jobManager 管理 2. per-job 模式 会启动各自多个jobManager](https://t.zsxq.com/u3vVV3b)\n\n+ [您在flink里面使用过lettuce连接redis cluster吗，我这里使用时报错，Cannot retrieve initial cluster partitions from initial URIs](https://t.zsxq.com/VNnEQJ6)\n\n+ [zhisheng你好，我在使用flink滑动窗口时，每10分钟会向redis写入大量的内容，影响了线上性能，这个有什么办法可以控制写redis的速度吗？](https://t.zsxq.com/62ZZJmi)\n\n+ [flink standalone模式，启动服务的命令为：flink run -c 类名 jar包  。对应的Slots怎么能均匀分布呢？目前遇到问题，一直使用一个机器的Slots，任务多了后直接会把taskjob挂掉。报错信息如二图](https://t.zsxq.com/2zjqVnE)\n\n+ [zhisheng你好，像standalone与yarn集群，其master与workers相互通信都依赖于ssh协议，请问有哪种不依赖于ssh协议的搭建方式吗？](https://t.zsxq.com/qzrvbaQ)\n\n+ [官网中，这两种周期性watermaker的产生分别适用什么场景呢？](https://t.zsxq.com/2fUjAQz)\n\n+ [周期性的watermarke 设置定时产生， ExecutionConfig.setAutoWatermarkInterval（…），这个定时的时间一般怎样去评估呢？](https://t.zsxq.com/7IEAyV3)\n\n+ [想问一下能否得到flink分配资源的时间？](https://t.zsxq.com/YjqRBq3)\n\n+ [问下flink向kafka生产数据有时候报错：This server does not host this topic-partition](https://t.zsxq.com/vJyJiMJ)\n\n+ [flink yarn 模式启动，log4j. properties配置信息见图片，yarn启动页面的taskmanager能看到日志输出到stdout，但是在指定的日志文件夹中就是没有日志文件生成。，本地运行有日志文件的](https://t.zsxq.com/N3ZrZbQ)\n\n+ [教一个问题。flink2hbase 如何根据hbase中的日期字段，动态按天建表呢？我自定义了hbase sink，在invoke方法中根据数据的时间建表，但是带来了一个问题，每条数据都要去check表是否存在，这样会产生大量的rpc请求。请问星主大大，针对上述这种情况，有什么好的解决办法吗？](https://t.zsxq.com/3rNBubU)\n\n+ [你好，有关于TM,slots,内存，线程数，进程数，cpu，调度相关的资料吗？比如一个slot起多少线程，为什么，如何起的，task是如何调度的之类的。网上没找到想要的，书上写的也不够细。源码的话刚开始看不太懂，所以想先找找资料看看](https://t.zsxq.com/buBIAMf)\n\n+ [能否在flink中只新建一个FlinkKafkaConsumer读取多个kafka的topics ，这些topics的处理逻辑都是一样的 最终将数据写入每个topic对应的es表 请问这个实现逻辑是怎样的 ](https://t.zsxq.com/EY37aEm)\n\n+ [能不能描述一下在窗口中，例如滚动窗口，多个事件进窗口后，事件在内存中保存的形式是怎么样的？会变成一个state？还是多个事件变成一个state？事件跟state的关系？事件时间过了在窗口是怎么清理事件的？如果state backends用的是RocksDBStateBackend，增量checkpoint，怎么清理已保存过期的事件咧？](https://t.zsxq.com/3vzzj62)\n\n+ [请问一下 Flink的监控是如何做的？比如job挂了能告警通知。目前是想用Prometheus来做监控，但是发现上报的指标没有很符合的我需求。我这边用yarn-session启动的job，一个jobManger会管理多个job。Prometheus还是刚了解阶段可能遗漏了一些上报指标，球主大大有没有好的建议。](https://t.zsxq.com/vJyRnY7)\n\n+ [ProcessTime和EventTime是否可以一起使用？当任务抛出异常失败的时候，如果配置了重启策略，重启时是不是从最近的checkpoint继续？遇到了一个数据库主键冲突的问题，查看kafka数据源发现该主键的消息只有一条，查看日志发现Redis连接池抛了异常(当时Redis在重启)导致任务失败重试，当时用的ProcessTime](https://t.zsxq.com/BuZJaUb)\n\n+ [flink-kafka 自定义反序列化中如何更好的处理数据异常呢，有翻到前面一篇提问，如果使用 try-catch 捕获到异常，是抛出异常更好呢？还是return null 更好呢](https://t.zsxq.com/u3niYni)\n\n+ [现在在用flink做上下游数据的比对，现在遇到了性能瓶颈，一个节点现在最多只能消费50条数据。观察taskmanager日志的gc日志发现最大堆内存有2.7g，但是新生代最大只有300m。能不能设置flink的jvm参数，flink on yarn启动模式](https://t.zsxq.com/rvJYBuB)\n\n+ [请教一个原理性的问题，side out put和直接把一个流用两种方式处理有啥本质区别？我试了下，把一个流一边写缓存，一边入数据库，两边也都是全量数据](https://t.zsxq.com/Ee27i6a)\n\n+ [如何定义一个flink window处理方式，1秒钟处理500条，1：kafka中有10000条数据时，仍旧1秒钟处理500条；2，kafka中有20条，每隔1秒处理一次。](https://t.zsxq.com/u7YbyFe)\n\n+ [问一下大佬，网页UI可以进行savepoint的保存么？还是只能从savepoint启动？](https://t.zsxq.com/YfAqFUj)\n\n+ [能否指定Kafka某些分区消费拉取消息，其他分区不拉取消息。现在有有很多场景，一个topic上百个分区，但是我只需要其中几个分区的数据](https://t.zsxq.com/AUfEAQB)\n\n+ [我想过滤kafka 读到的某些数据，过滤条件从redis中拿到（与用户的配置相关，所以需要定时更新），总觉得怪怪的，请问有更好的方案吗？因为不提供redis的source，因此我是用jedis客户端来读取redis数据的，数据也获取不到，请问星主，flink代码在编写的时候，一般是如何调试的呢](https://t.zsxq.com/qr7UzjM)\n\n+ [flink使用rocksdb状态检查点存在HDFS上，有的任务状态很小但是HDFS一个文件最小128M所以磁盘空间很快就满了，有没有啥配置可以自动清理检查点呢](https://t.zsxq.com/Ufqj2ZR)\n\n+ [这是实时去重的问题。\n   举个例子，当发生订单交易的时候，业务中台会把该比订单消息发送到kafka，然后flink消费，统计总金额。如果因为业务中台误操作，发送了多次相同的订单过来（订单id相同），那么统计结果就会多次累加，造成统计的总金额比实际交易金额更多。我需要自定义在source里通过operate state去重，但是operate state是和每个source实例绑定，会造成重复的订单可能发送到不同的source实例，这样取出来的state里面就可能没有上一次已经记录的订单id，那么就会将这条重复的订单金额统计到最后结果中，](https://t.zsxq.com/RzB6E6A)\n\n+ [双流join的时候，怎么能保证两边来的数据是对应的？举个例子，订单消息和库存消息，按逻辑来说，发生订单的时候，库存也会变，这两个topic都会同时各自发一条消息给我，我拿到这两条消息会根据订单id做join操作。问题是那如果库存消息延迟了5秒或者10秒，订单消息来的时候就join不到库存消息，这时候该怎么办？](https://t.zsxq.com/nunynmI)\n\n+ [我这有一个比对程序用的是flink，数据源用的是flink-kafka，业务数据分为上下游，需要根据某个字段分组，相同的key上下游数据放一起比对。上下游数据进来的时间不一样，因此我用了一个可以迭代的窗口大小为5分钟window进行比对处理，最大迭代次数为3次。statebackend用的是fsstatebackend。通过监控发现当程序每分钟数据量超过2万条的时候，程序就不消费数据了，虽然webui上显示正常，而且jobmanager和taskmanager的stdout没有异常日志，但是程序就是不消费数据了。](https://t.zsxq.com/nmeE2Fm)\n\n+ [异步io里面有个容量，是指同时多少个并发还是，假如我每个taskmanager核数设置10个，共10个taskmanager，那我这个数量只能设置100呢](https://t.zsxq.com/vjimeiI)\n\n+ [有个性能问题想问下有没有相关的经验？一个job从kafka里读一个topic数据，然后进行分流，使用sideout分开之后直接处理，性能影响大吗？比如分开以后有一百多子任务。还有其他什么好的方案进行分流吗？](https://t.zsxq.com/mEeUrZB)\n\n+ [线上有个作业抛出了一下异常，但是还能正常运行，这个怎么排查，能否提供一下思路](https://t.zsxq.com/Eayzr3R)\n\n等等等，还有很多，复制粘贴的我手累啊 😂\n\n另外里面还会及时分享 Flink 的一些最新的资料（包括数据、视频、PPT、优秀博客，持续更新，保证全网最全，因为我知道 Flink 目前的资料还不多）\n\n[关于自己对 Flink 学习的一些想法和建议](https://t.zsxq.com/AybAimM)\n\n[Flink 全网最全资料获取，持续更新，点击可以获取](https://t.zsxq.com/iaEiyB2)\n\n再就是星球用户给我提的一点要求：不定期分享一些自己遇到的 Flink 项目的实战，生产项目遇到的问题，是如何解决的等经验之谈！\n\n1、[如何查看自己的 Job 执行计划并获取执行计划图](https://t.zsxq.com/Zz3ny3V)\n\n2、[当实时告警遇到 Kafka 千万数据量堆积该咋办？](https://t.zsxq.com/AIAQrnq)\n\n3、[如何在流数据中比两个数据的大小？多种解决方法](https://t.zsxq.com/QnYjy7M)\n\n4、[kafka 系列文章](https://t.zsxq.com/6Q3vN3b)\n\n5、[Flink环境部署、应用配置及运行应用程序](https://t.zsxq.com/iiYfMBe)\n\n6、[监控平台该有架构是长这样子的](https://t.zsxq.com/yfYrvFA)\n\n7、[《大数据“重磅炸弹”——实时计算框架 Flink》专栏系列文章目录大纲](https://t.zsxq.com/beu7Mvj)\n\n8、[《大数据“重磅炸弹”——实时计算框架 Flink》Chat 付费文章](https://t.zsxq.com/UvrRNJM)\n\n9、[Apache Flink 是如何管理好内存的？](https://t.zsxq.com/zjQvjeM)\n\n10、[Flink On K8s](https://t.zsxq.com/eYNBaAa)\n\n11、[Flink-metrics-core](https://t.zsxq.com/Mnm2nI6)\n   \n12、[Flink-metrics-datadog](https://t.zsxq.com/Mnm2nI6)\n\n13、[Flink-metrics-dropwizard](https://t.zsxq.com/Mnm2nI6)\n   \n14、[Flink-metrics-graphite](https://t.zsxq.com/Mnm2nI6)\n   \n15、[Flink-metrics-influxdb](https://t.zsxq.com/Mnm2nI6)\n   \n16、[Flink-metrics-jmx](https://t.zsxq.com/Mnm2nI6)\n   \n17、[Flink-metrics-slf4j](https://t.zsxq.com/Mnm2nI6)\n   \n18、[Flink-metrics-statsd](https://t.zsxq.com/Mnm2nI6)\n\n19、[Flink-metrics-prometheus](https://t.zsxq.com/Mnm2nI6)\n\n20、[Flink 注解源码解析](https://t.zsxq.com/f6eAu3J)\n\n21、[使用 InfluxDB 和 Grafana 搭建监控 Flink 的平台](https://t.zsxq.com/yVnaYR7)\n\n22、[一文搞懂Flink内部的Exactly Once和At Least Once](https://t.zsxq.com/UVfqfae)\n\n23、[一文让你彻底了解大数据实时计算框架 Flink](https://t.zsxq.com/eM3ZRf2)\n\n\n当然，除了更新 Flink 相关的东西外，我还会更新一些大数据相关的东西，因为我个人之前不是大数据开发，所以现在也要狂补些知识！总之，希望进来的童鞋们一起共同进步！\n\n1、[Java 核心知识点整理.pdf](https://t.zsxq.com/7I6Iyrf)\n\n2、[假如我是面试官，我会问你这些问题](https://t.zsxq.com/myJYZRF)\n\n3、[Kafka 系列文章和学习视频](https://t.zsxq.com/iUZnamE)\n\n4、[重新定义 Flink 第二期 pdf](https://t.zsxq.com/r7eIeyJ)\n\n5、[GitChat Flink 文章答疑记录](https://t.zsxq.com/ZjiYrVr)\n\n6、[Java 并发课程要掌握的知识点](https://t.zsxq.com/QZVJyz7)\n\n7、[Lightweight Asynchronous Snapshots for Distributed Dataflows](https://t.zsxq.com/VVN7YB2)\n\n8、[Apache Flink™- Stream and Batch Processing in a Single Engine](https://t.zsxq.com/VVN7YB2)\n\n9、[Flink状态管理与容错机制](https://t.zsxq.com/NjAQFi2)\n\n10、[Flink 流批一体的技术架构以及在阿里的实践](https://t.zsxq.com/MvfUvzN)\n\n11、[Flink Checkpoint-\x07\x08轻量级分布式快照](https://t.zsxq.com/QVFqjea)\n\n12、[Flink 流批一体的技术架构以及在阿里的实践](https://t.zsxq.com/MvfUvzN)\n\n13、[Stream Processing with Apache Flink pdf](https://t.zsxq.com/N37mUzB)\n\n14、[Flink 结合机器学习算法的监控平台实践](https://t.zsxq.com/m6EAaQ3)\n\n15、[《大数据重磅炸弹-实时计算Flink》预备篇——大数据实时计算介绍及其常用使用场景 pdf 和视频](https://t.zsxq.com/emMBaQN)\n\n16、[《大数据重磅炸弹-实时计算Flink》开篇词 pdf 和视频](https://t.zsxq.com/fqfuVRR)\n\n17、[四本 Flink 书](https://t.zsxq.com/rVBQFI6)\n\n18、[流处理系统 的相关 paper](https://t.zsxq.com/rVBQFI6)\n\n19、[Apache Flink 1.9 特性解读](https://t.zsxq.com/FyzvRne)\n\n20、[打造基于Flink Table API的机器学习生态](https://t.zsxq.com/FyzvRne)\n\n21、[基于Flink on Kubernetes的大数据平台](https://t.zsxq.com/FyzvRne)\n\n22、[基于Apache Flink的高性能机器学习算法库](https://t.zsxq.com/FyzvRne)\n\n23、[Apache Flink在快手的应用与实践](https://t.zsxq.com/FyzvRne)\n\n24、[Apache Flink-1.9与Hive的兼容性](https://t.zsxq.com/FyzvRne)\n\n25、[打造基于Flink Table API的机器学习生态](https://t.zsxq.com/FyzvRne)\n\n26、[流处理系统的相关 paper](https://t.zsxq.com/rVBQFI6)']
XCL-Charts,Android图表库(XCL-Charts is a free charting library for Android platform.),基于Android Canvas来绘制各种图表,使用简便,定制灵活。目前支持3D/非3D/背向式/横向/竖向柱形图(Bar Chart)、3D/非3D饼图(Pie Chart)、堆叠图(Stacked Bar Chart)、面积图(Area Chart)、 折线图(Line Chart)、曲线图(Spline Chart)、环形图(Dount Chart)、南丁格尔玫瑰图(Rose Chart)、仪表盘(Dial Chart)、刻度盘(Gauge Chart)、雷达图(Radar Chart)、漏斗图(Funnel Chart)、圆形图(Circle Chart)、弧线比较图、散点图(Scatter Chart)、气泡图(Bubble Chart)、范围条形图(RangeBar Chart)等图表。其它特性还包括支持图表缩放、手势移动、点击响应、动画效果、多轴显示、图表参考线、混合图表及同数据源不同图表类型切换等。,3948,https://github.com/xcltapestry/XCL-Charts,master,['XCL-Charts\n==========\n\n<b>XCL-Charts V2.4</b><br/>\n  Android开源图表库(XCL-Charts is a free charting library for Android platform.) <br/>\n &nbsp;&nbsp;&nbsp;&nbsp;XCL-Charts基于Android原生Canvas来绘制各种图表,使用简便,定制灵活。<br/>\n &nbsp;&nbsp;&nbsp;&nbsp;目前支持<b>(3D/非3D,背向式)柱形图(Bar Chart)、3D/非3D饼图(Pie Chart)、堆积图(Stacked Bar Chart)、面积图(Area Chart)、\n 折线图(Line Chart)、曲线图(Spline Chart)、环形图(Dount Chart)、南丁格尔玫瑰图(Rose Chart)、仪表盘(Dial Chart)、刻度盘(Gauge Chart)、雷达图(Radar Chart)、\n 圆形图(Circle Chart)、弧线比较图、散点图(Scatter Chart)、气泡图(Bubble Chart)、范围条形图(RangeBar Chart)、玫瑰风向图(Wind Rose)、象限图(Quadrant chart)、漏斗图(Funnel Chart)等图表。<br/>\n &nbsp;&nbsp;&nbsp;&nbsp;其它特性还包括手势缩放、图表滑动、点击交互、多图叠加、图表批注、动画效果、多XY轴显示、轴线任意方位显示、动态图例、图表参考线、柱图刻度对齐风格切换、混合图表及同数据源图表类型切换等。</b><br/> \n \n <b>License</b><br/>\n      采用Apache v2 License开源协议。<br/>\n \n  Mail: xcl_168@aliyun.com <br/>\n  Blog: http://blog.csdn.net/xcl168 <br/>\n QQ群: 374780627\n<br/> \nGitHub代码托管地址:\nhttps://github.com/xcltapestry/XCL-Charts <br/>\t\t\n\n图表库简要教程\nhttp://blog.csdn.net/xcl168/article/details/42318669 <br/>\t\n<br/>\n <b>部份例图:</b><br/> \n \n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barpiechart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/area_ln_pie_chart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/spinnerBarChart2.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchart_m.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/stackedchart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchart2.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/dydialchart1.gif)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/dydialchart2.gif)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/dydialchart3.gif)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/dydialchart4.gif)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/bar3dchart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/linechart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/splinechart.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/pie3dchart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/radarchart_circle.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/WindRoseChart.png)\n\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/rosechart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/circlechart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/spinnerBarChart.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/gaugechart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/piechart2.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/arclinechart.png)\n\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/dountchart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/bubblechart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/scatterchart.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/radarchart_a.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/areachart2.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/rangebarchart.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/mulaxischart1.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/mulaxischart2.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/mulbarchart.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/QuadrantChart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/lines.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/spinnerPieChart.png)\n\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchart8.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchart9.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/FunnelChart_desc.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/FunnelChart_asc.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/splinechart05.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/splinechart6.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/linechart6.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchart6.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchartcloud.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/circlechart2.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/roundbarchart.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/roundbarchart2.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/areachart3.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/funnelchart2.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchart_hh.png)\n![](https://raw.githubusercontent.com/xcltapestry/XCL-Charts/master/screens/barchart_hhh.png)\n\n']
weui.js,A lightweight javascript library for WeUI.,3088,https://github.com/Tencent/weui.js,master,['weui.js\n=====\n\n[![npm version](https://img.shields.io/npm/v/weui.js.svg)](https://www.npmjs.org/package/weui.js/)\n\n\n### 概述\n\n[WeUI](https://github.com/Tencent/weui.git) 的轻量级 js 封装。\n\n注意：由于微信小程序不支持dom操作，所以weui.js并不适用于小程序。不过WeUI也为小程序开发了另外的版本，详情请看：https://github.com/Tencent/weui-wxss/\n\n### 手机预览\n\n![https://weui.io](https://cloud.githubusercontent.com/assets/2395166/20742697/96705822-b70c-11e6-9486-c03a5939a1d6.png)\n\n[https://weui.io/weui.js/](https://weui.io/weui.js/)\n\n\n### 开发\n\n安装\n\n```shell\ngit clone https://github.com/Tencent/weui.js.git\ncd weui.js\nnpm install\nnpm start\n```\n\n编译\n\n```shell\nnpm run build\n```\n\n\n### 使用\n\n#### global \n\n```html\n<link rel="stylesheet" href="https://res.wx.qq.com/t/wx_fed/weui-source/res/2.5.16/weui.min.css">\n<script type="text/javascript" src="https://res.wx.qq.com/t/wx_fed/weui.js/res/1.2.18/weui.min.js"></script>\n<script type="text/javascript">\n    weui.alert(\'alert\');\n</script>\n```\n\n#### import as module\n\n```javascript\nimport \'weui\';\nimport weui from \'weui.js\';\n\nweui.alert(\'alert\');\n```\n\n### 文档\n\n[Documents](https://github.com/Tencent/weui.js/tree/master/docs/README.md)\n\n### 贡献\n\n如果你有好的意见或建议，欢迎给我们提issue或pull request。\n\n### License\nThe MIT License(http://opensource.org/licenses/MIT)\n\n请自由地享受和参与开源\n']
fastjson2,FASTJSON2 is a Java JSON  library with excellent performance.,2506,https://github.com/alibaba/fastjson2,main,['[![Java CI](https://img.shields.io/github/actions/workflow/status/alibaba/fastjson2/ci.yaml?branch=main&logo=github&logoColor=white)](https://github.com/alibaba/fastjson2/actions/workflows/ci.yaml)\n[![Codecov](https://img.shields.io/codecov/c/github/alibaba/fastjson2/main?logo=codecov&logoColor=white)](https://codecov.io/gh/alibaba/fastjson2/branch/main)\n[![Maven Central](https://img.shields.io/maven-central/v/com.alibaba.fastjson2/fastjson2?logo=apache-maven&logoColor=white)](https://search.maven.org/artifact/com.alibaba.fastjson2/fastjson2)\n[![GitHub release](https://img.shields.io/github/release/alibaba/fastjson2)](https://github.com/alibaba/fastjson2/releases)\n[![Java support](https://img.shields.io/badge/Java-8+-green?logo=java&logoColor=white)](https://openjdk.java.net/)\n[![License](https://img.shields.io/github/license/alibaba/fastjson2?color=4D7A97&logo=apache)](https://www.apache.org/licenses/LICENSE-2.0.html)\n[![Gitpod Ready-to-Code](https://img.shields.io/badge/Gitpod-ready--to--code-green?label=gitpod&logo=gitpod&logoColor=white)](https://gitpod.io/#https://github.com/alibaba/fastjson2)\n[![Last SNAPSHOT](https://img.shields.io/nexus/snapshots/https/oss.sonatype.org/com.alibaba.fastjson2/fastjson2?label=latest%20snapshot)](https://oss.sonatype.org/content/repositories/snapshots/com/alibaba/fastjson2/)\n[![GitHub Stars](https://img.shields.io/github/stars/alibaba/fastjson2)](https://github.com/alibaba/fastjson2/stargazers)\n[![GitHub Forks](https://img.shields.io/github/forks/alibaba/fastjson2)](https://github.com/alibaba/fastjson2/fork)\n[![user repos](https://badgen.net/github/dependents-repo/alibaba/fastjson2?label=user%20repos)](https://github.com/alibaba/fastjson2/network/dependents)\n[![GitHub Contributors](https://img.shields.io/github/contributors/alibaba/fastjson2)](https://github.com/alibaba/fastjson2/graphs/contributors)\n\n##### 语言： 中文 | [English](README_EN.md)\n\n# FASTJSON v2\n\n`FASTJSON 2`是一个性能极致并且简单易用的Java JSON库。\n\n- `FASTJSON 2`是`FASTJSON`项目的重要升级，和FASTJSON 1相比，性能有非常大的提升，解决了autoType功能因为兼容和白名单的安全性问题。\n- 性能极致，性能远超过其他流行JSON库，包括jackson/gson/org.json，性能数据: [https://github.com/alibaba/fastjson2/wiki/fastjson_benchmark](https://github.com/alibaba/fastjson2/wiki/fastjson_benchmark)\n- 支持JDK新特性，包括`JDK 11`/`JDK 17`，针对`compact string`优化，支持Record，支持`GraalVM Native-Image`\n- 完善的[`JSONPath`](https://alibaba.github.io/fastjson2/jsonpath_cn)支持，支持[SQL:2016](https://en.wikipedia.org/wiki/SQL:2016)的JSONPath语法\n- 支持`Android 8+`，客户端和服务器一套API\n- 支持`Kotlin` [https://alibaba.github.io/fastjson2/kotlin_cn](https://alibaba.github.io/fastjson2/kotlin_cn)\n- 支持`JSON Schema` [https://alibaba.github.io/fastjson2/json_schema_cn](https://alibaba.github.io/fastjson2/json_schema_cn)\n- 新增加支持二进制格式JSONB [https://alibaba.github.io/fastjson2/jsonb_format_cn](https://alibaba.github.io/fastjson2/jsonb_format_cn)\n\n![fastjson](docs/logo.jpg "fastjson")\n\n# 1. 使用准备\n\n## 1.1 添加依赖\n\n在`fastjson v2`中，`groupId`和`1.x`不一样，是`com.alibaba.fastjson2`：\n\n`Maven`:\n\n```xml\n<dependency>\n    <groupId>com.alibaba.fastjson2</groupId>\n    <artifactId>fastjson2</artifactId>\n    <version>2.0.25</version>\n</dependency>\n```\n\n`Gradle`:\n\n```groovy\ndependencies {\n    implementation \'com.alibaba.fastjson2:fastjson2:2.0.25\'\n}\n```\n\n可以在 [maven.org](https://search.maven.org/artifact/com.alibaba.fastjson2/fastjson2) 查看最新可用的版本。\n\n## 1.2 其他模块\n\n### `Fastjson v1`兼容模块\n\n如果原来使用`fastjson 1.2.x`版本，可以使用兼容包，兼容包不能保证100%兼容，请仔细测试验证，发现问题请及时反馈。\n\n`Maven`:\n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>2.0.25</version>\n</dependency>\n```\n\n`Gradle`:\n\n```groovy\ndependencies {\n    implementation \'com.alibaba:fastjson:2.0.25\'\n}\n```\n\n### `Fastjson Kotlin`集成模块\n\n如果项目使用`Kotlin`，可以使用`fastjson-kotlin`模块，使用方式上采用`kotlin`的特性。\n\n* `Maven`:\n\n```xml\n<dependency>\n    <groupId>com.alibaba.fastjson2</groupId>\n    <artifactId>fastjson2-kotlin</artifactId>\n    <version>2.0.25</version>\n</dependency>\n\n<!-- 有些场景需要依赖kotlin-reflect -->\n<dependency>\n    <groupId>org.jetbrains.kotlin</groupId>\n    <artifactId>kotlin-reflect</artifactId>\n    <version>${kotlin-version}</version>\n</dependency>\n```\n\n* `Kotlin Gradle`:\n\n```kotlin\ndependencies {\n    implementation("com.alibaba.fastjson2:fastjson2-kotlin:2.0.25")\n}\n```\n\n### `Fastjson Extension`扩展模块\n\n如果项目使用`SpringFramework`等框架，可以使用`fastjson-extension`模块，使用方式参考 [SpringFramework Support](docs/spring_support_cn.md)。\n\n`Maven`:\n\n```xml\n<dependency>\n    <groupId>com.alibaba.fastjson2</groupId>\n    <artifactId>fastjson2-extension</artifactId>\n    <version>2.0.25</version>\n</dependency>\n```\n\n`Gradle`:\n\n```groovy\ndependencies {\n    implementation \'com.alibaba.fastjson2:fastjson2-extension:2.0.25\'\n}\n```\n\n# 2. 简单使用\n\n在`fastjson v2`中，`package`和`1.x`不一样，是`com.alibaba.fastjson2`。如果你之前用的是`fastjson1`，大多数情况直接更包名就即可。\n\n### 2.1 将`JSON`解析为`JSONObject`\n\n`Java`:\n\n```java\nString text = "...";\nJSONObject data = JSON.parseObject(text);\n\nbyte[] bytes = ...;\nJSONObject data = JSON.parseObject(bytes);\n```\n\n`Kotlin`:\n\n```kotlin\nimport com.alibaba.fastjson2.*\n\nval text = ... // String\nval data = text.parseObject()\n\nval bytes = ... // ByteArray\nval data = bytes.parseObject() // JSONObject\n```\n\n### 2.2 将`JSON`解析为`JSONArray`\n\n`Java`:\n\n```java\nString text = "...";\nJSONArray data = JSON.parseArray(text);\n```\n\n`Kotlin`:\n\n```kotlin\nimport com.alibaba.fastjson2.*\n\nval text = ... // String\nval data = text.parseArray() // JSONArray\n```\n\n### 2.3 将`JSON`解析为`Java`对象\n\n`Java`:\n\n```java\nString text = "...";\nUser data = JSON.parseObject(text, User.class);\n```\n\n`Kotlin`:\n\n```kotlin\nimport com.alibaba.fastjson2.*\n\nval text = ... // String\nval data = text.to<User>() // User\nval data = text.parseObject<User>() // User\n```\n\n### 2.4 将`Java`对象序列化为`JSON`\n\n`Java`:\n\n```java\nObject data = "...";\nString text = JSON.toJSONString(data);\nbyte[] text = JSON.toJSONBytes(data);\n```\n\n`Kotlin`:\n\n```kotlin\nimport com.alibaba.fastjson2.*\n\nval data = ... // Any\nval text = text.toJSONString() // String\nval bytes = text.toJSONByteArray() // ByteArray\n```\n\n### 2.5 使用`JSONObject`、`JSONArray`\n\n#### 2.5.1 获取简单属性\n\n```java\nString text = "{\\"id\\": 2,\\"name\\": \\"fastjson2\\"}";\nJSONObject obj = JSON.parseObject(text);\n\nint id = obj.getIntValue("id");\nString name = obj.getString("name");\n```\n\n```java\nString text = "[2, \\"fastjson2\\"]";\nJSONArray array = JSON.parseArray(text);\n\nint id = array.getIntValue(0);\nString name = array.getString(1);\n```\n\n#### 2.5.2 读取`JavaBean`\n\n`Java`:\n\n```java\nJSONArray array = ...\nJSONObject obj = ...\n\nUser user = array.getObject(0, User.class);\nUser user = obj.getObject("key", User.class);\n```\n\n`Kotlin`:\n\n```kotlin\nval array = ... // JSONArray\nval obj = ... // JSONObject\n\nval user = array.to<User>(0)\nval user = obj.to<User>("key")\n```\n\n#### 2.5.3 转为`JavaBean`\n\n`Java`:\n\n```java\nJSONArray array = ...\nJSONObject obj = ...\n\nUser user = obj.toJavaObject(User.class);\nList<User> users = array.toJavaList(User.class);\n```\n\n`Kotlin`:\n\n```kotlin\nval array = ... // JSONArray\nval obj = ... // JSONObject\n\nval user = obj.to<User>() // User\nval users = array.toList<User>() // List<User>\n```\n\n### 2.6 将`JavaBean`对象序列化为`JSON`\n\n`Java`:\n\n```java\nclass User {\n    public int id;\n    public String name;\n}\n\nUser user = new User();\nuser.id = 2;\nuser.name = "FastJson2";\n\nString text = JSON.toJSONString(user);\nbyte[] bytes = JSON.toJSONBytes(user);\n```\n\n`Kotlin`:\n\n```kotlin\nclass User(\n    var id: Int,\n    var name: String\n)\n\nval user = User()\nuser.id = 2\nuser.name = "FastJson2"\n\nval text = user.toJSONString() // String\nval bytes = user.toJSONByteArray() // ByteArray\n```\n\n序列化结果:\n\n```json\n{\n    "id"   : 2,\n    "name" : "FastJson2"\n}\n```\n\n# 3. 进阶使用\n\n### 3.1 使用`JSONB`\n\n#### 3.1.1 将`JavaBean`对象序列化`JSONB`\n\n```java\nUser user = ...;\nbyte[] bytes = JSONB.toBytes(user);\nbyte[] bytes = JSONB.toBytes(user, JSONWriter.Feature.BeanToArray);\n```\n\n#### 3.1.2 将`JSONB`数据解析为`JavaBean`\n\n```java\nbyte[] bytes = ...\nUser user = JSONB.parseObject(bytes, User.class);\nUser user = JSONB.parseObject(bytes, User.class, JSONReader.Feature.SupportBeanArrayMapping);\n```\n\n### 3.2 使用`JSONPath`\n\n#### 3.2.1 使用`JSONPath`读取部分数据\n\n```java\nString text = ...;\nJSONPath path = JSONPath.of("$.id"); // 缓存起来重复使用能提升性能\n\nJSONReader parser = JSONReader.of(text);\nObject result = path.extract(parser);\n```\n\n#### 3.2.2 使用`JSONPath`读取部分`byte[]`的数据\n\n```java\nbyte[] bytes = ...;\nJSONPath path = JSONPath.of("$.id"); // 缓存起来重复使用能提升性能\n\nJSONReader parser = JSONReader.of(bytes);\nObject result = path.extract(parser);\n```\n\n#### 3.2.3 使用`JSONPath`读取部分`byte[]`的数据\n\n```java\nbyte[] bytes = ...;\nJSONPath path = JSONPath.of("$.id"); // 缓存起来重复使用能提升性能\n\nJSONReader parser = JSONReader.ofJSONB(bytes); // 注意这里使用ofJSONB方法\nObject result = path.extract(parser);\n```\n']
libcudacxx,The C++ Standard Library for your entire system.,2171,https://github.com/NVIDIA/libcudacxx,main,['docs/overview.md']
EasyLogger,An ultra-lightweight(ROM<1.6K, RAM<0.3k), high-performance C/C++ log library. | 一款超轻量级(ROM<1.6K, RAM<0.3k)、高性能的 C/C++ 日志库,2790,https://github.com/armink/EasyLogger,master,['# EasyLogger\n\n---\n\n# 1. 介绍\n\n[EasyLogger](https://github.com/armink/EasyLogger) 是一款超轻量级(ROM<1.6K, RAM<0.3K)、高性能的 C/C++ 日志库，非常适合对资源敏感的软件项目，例如： IoT 产品、可穿戴设备、智能家居等等。相比 log4c、zlog 这些知名的 C/C++ 日志库， EasyLogger 的功能更加简单，提供给用户的接口更少，但上手会很快，更多实用功能支持以插件形式进行动态扩展。\n\n## 1.1 主要特性\n\n- 支持用户自定义输出方式（例如：终端、文件、数据库、串口、485、Flash...）；\n- 日志内容可包含级别、时间戳、线程信息、进程信息等；\n- 日志输出被设计为线程安全的方式，并支持 **异步输出** 及 **缓冲输出** 模式；\n- 支持多种操作系统（[RT-Thread](http://www.rt-thread.org/)、UCOS、Linux、Windows、Nuttx...），也支持裸机平台；\n- 日志支持 **RAW格式** ，支持 **hexdump** ；\n- 支持按 **标签**  、 **级别** 、 **关键词** 进行动态过滤；\n- 各级别日志支持不同颜色显示；\n- 扩展性强，支持以插件形式扩展新功能。\n\n> 名词解释：\n>\n> - 1、RAW格式：未经过格式化的原始日志。\n> - 2、标签：在软件中可以按照文件、模块、功能等方面，对需要打印的日志设定标签，实现日志分类。\n\n## 1.2 插件\n\n- 1、Flash：使用 [EasyFlash](https://github.com/armink/EasyFlash) 库提供的Flash操作接口，无需文件系统，直接将日志存储在 Flash 中。\n- 2、File：支持文件转档、文件循环保存等与文件日志输出相关功能。\n- 3、敬请期待……\n\n## 1.3 Star & Fork\n\n后续我还会提供更多插件。也非常欢迎大家设计、开发更多实用插件和功能，一起来完善 EasyLogger  **([Github](https://github.com/armink/EasyLogger)|[OSChina](http://git.oschina.net/armink/EasyLogger)|[Coding](https://coding.net/u/armink/p/EasyLogger/git))** 。如果觉得这个开源项目很赞，可以点击[项目主页](https://github.com/armink/EasyLogger) 右上角的 **Star** ，同时把它推荐给更多有需要的朋友。\n\n# 2. 使用\n\n### 2.1 参数配置\n\nEasyLogger 拥有过滤方式、输出格式、输出开关这些属性。\n\n- 过滤方式支持按照标签、级别、关键词进行过滤；\n- 可以动态的开启/关闭日志的输出；\n- 可设定动态和静态的输出级别\n  - 静态：一级开关，通过宏定义，在编译阶段使用；\n  - 动态：二级开关，通过API接口，在运行阶段使用。\n\n> 注：目前参数配置及输出方式都是单例模式，即全局只支持一种配置方式。此模式下，软件会较为简单，但是无法支持复杂的输出方式。\n\n### 2.2 输出级别\n\n参考 Android Logcat ，级别最高为 0(Assert) ，最低为 5(Verbose) 。\n\n```\n0.[A]：断言(Assert)\n1.[E]：错误(Error)\n2.[W]：警告(Warn)\n3.[I]：信息(Info)\n4.[D]：调试(Debug)\n5.[V]：详细(Verbose)\n```\n\n#### 2.2.1 输出缤纷多彩的日志\n\n各个级别日志默认颜色效果如下。用户也可以根据自己的喜好，在 `elog_cfg.h` 对各个级别日志的颜色及字体风格进行单独设置。\n\n![TextColor](https://raw.githubusercontent.com/armink/EasyLogger/master/docs/zh/images/TextColor.png)\n\n### 2.3 输出过滤\n\n支持按照 **级别、标签及关键词** 进行过滤。日志内容较多时，使用过滤功能可以更快定位日志，保证日志的可读性。更多的过滤功能设置方法及细节请阅读[`\\docs\\zh\\api\\kernel.md`](https://github.com/armink/EasyLogger/blob/master/docs/zh/api/kernel.md)文档\n\n注：RAW格式、hexdump 格式日志不支持标签、关键词过滤\n\n### 2.4 输出格式\n\n输出格式支持：级别、时间、标签、进程信息、线程信息、文件路径、行号、方法名。每种优先级别可以独立设置输出格式。\n\n### 2.5 输出方式\n\n通过用户的移植，可以支持任何一种输出方式。只不过对于某种输出方式可能引入的新功能，需要通过插件实现，例如：文件转存，检索Flash日志等等。后期会有更多的插件开源出来。下面简单对比下部分输出方式使用场景：\n\n- 终端：方便用户动态查看，不具有存储功能；\n- 文件与Flash：都具有存储功能，用户可以查看历史日志。但是文件方式需要文件系统的支持，而Flash方式更加适合应用在无文件系统的小型嵌入式设备中。\n\n### 2.6 Demo\n\n### 2.6.1 核心功能\n\n下图为在终端中输入命令来控制日志的输出及过滤器的设置，更加直观的展示了 EasyLogger 核心功能。\n\n- Demo 路径：[`\\demo\\os\\rt-thread\\stm32f10x\\`](https://github.com/armink/EasyLogger/tree/master/demo/os/rt-thread/stm32f10x)\n- API 文档：[`\\docs\\zh\\api\\kernel.md`](https://github.com/armink/EasyLogger/blob/master/docs/zh/api/kernel.md)\n- 移植文档：[`\\docs\\zh\\port\\kernel.md`](https://github.com/armink/EasyLogger/blob/master/docs/zh/port/kernel.md)\n\n![easylogger](https://raw.githubusercontent.com/armink/EasyLogger/master/docs/zh/images/EasyLoggerDemo.gif)\n\n### 2.6.2 Flash Log（将日志保存到 Flash 中）\n\n下图过程为通过控制台输出日志，并将输出的日志存储到 Flash 中。重启再读取上次保存的日志，最后清空 Flash 日志。\n\n- Demo 路径：[`\\demo\\os\\rt-thread\\stm32f10x\\`](https://github.com/armink/EasyLogger/tree/master/demo/os/rt-thread/stm32f10x)\n- API 文档：[`\\docs\\zh\\api\\flash.md`](https://github.com/armink/EasyLogger/blob/master/docs/zh/api/flash.md)\n- 移植文档：[`\\docs\\zh\\port\\flash.md`](https://github.com/armink/EasyLogger/blob/master/docs/zh/port/flash.md)\n\n![FlashLog](https://raw.githubusercontent.com/armink/EasyLogger/master/docs/zh/images/LogDemo.gif)\n\n### 2.6.2 File Log（将日志保存到文件中）\n\n通过 FIle 插件，可以将日志自动保存至文件中。每个文件可以设定大小，超过规定大小后，自动新建新的文件来存储日志。\n\n# 3. 文档\n\n具体内容参考[`\\docs\\zh\\`](https://github.com/armink/EasyLogger/tree/master/docs/zh)下的文件。务必保证在 **阅读文档** 后再移植使用。\n\n# 4. 后期\n\n- [x] Flash存储：在[EasyFlash](https://github.com/armink/EasyFlash)中增加日志存储、读取功能，让EasyLogger与其无缝对接。使日志可以更加容易的存储在 **非文件系统** 中，并具有历史日志检索的功能；\n- [ ] 配置文件：文件系统下的配置文件；\n- [x] 文件转档：文件系统下支持文件按容量转档，按时间区分；\n- [ ] 日志助手：开发跨平台的日志助手，兼容Linux、Windows、Mac系统，打开助手即可查看、过滤（支持正则表达式）、排序、保存日志等。前端：[HTML5](https://zh.wikipedia.org/wiki/HTML5) + [Bootstrap](https://github.com/twbs/bootstrap) + [AngularJS](https://angularjs.org/) + [NW.js](http://www.oschina.net/p/nwjs)，后端：[Rust](https://github.com/rust-lang/rust) + [iron](https://github.com/iron/iron) + [rust-websocket](https://github.com/cyderize/rust-websocket) + [serial-rs](https://github.com/dcuddeback/serial-rs)；\n- [x] 异步输出：目前日志输出与用户代码之间是同步的方式，这种方式虽然软件简单，也不存在日志覆盖的问题。但在输出速度较低的平台下，会由于增加日志功能，而降低软件运行速度。所以后期会增加 **异步输出** 方式，关键字过滤也可以放到异步输出中去；\n- [ ] Arduino：增加Arduino lib，并提供其Demo；\n\n# 5. 许可\n\nMIT Copyright (c) armink.ztl@gmail.com\n']
fe9-library,九部知识库,1921,https://github.com/frontend9/fe9-library,master,['## 前端九部 [frontend9.com](https://frontend9.com)\n\n#### [使命愿景](https://github.com/frontend9/fe9-library/blob/master/ABOUTUS.md)\n#### [九部发展历史](https://github.com/frontend9/fe9-library/blob/master/HISTORY.md)\n#### [九部成员](https://frontend9.com/#/memberList)\n#### [加入九部](https://github.com/frontend9/fe9-library/blob/master/JOINUS.md)\n\n\n---\n\n## 九部精品手册\n具有共创色彩的九部精选文章 & 成员共同编写的手册\n- [《九部知识库-精选集》](https://www.yuque.com/fe9/select)\n- [《前端九部 - 入门者手册2019》](https://www.yuque.com/fe9/basic/zw24qu) 基础前端手册，欢迎大家积极参与完善\n- [《前端九部 - 前端面试题题库》](https://github.com/frontend9/fe9-interview) 分享自己在各种公司面试时遇到的各种面试题，探讨宇宙终极答案\n\n---\n\n\n## 九部知识库 成员文章目录\n\n\n### 前端基础（[html](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Ahtml)、[css](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Acss)、[javascript](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Ajavascript)、[async](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Aasync)、[typescript](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Atypescript)、[babel](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Ababel)）\n### 编程基础(algorithm、[compile](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Acompile)、[regular-expression](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3A%22Regular+Expression%22))\n### 工程相关 ([think](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Athink)、[build](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Abuild)、[webpack](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Awebpack))\n### React全家桶（[react](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Areact)、[router](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Arouter)、[redux](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Aredux)、[mobx](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Amobx)）\n### vue全家桶 ([vue](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Avue)、[vuex](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Avuex))\n### Ant Design系列（[Ant Design](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Aant%20design)、Ant Design Mobile、Ant Design Pro、[dva](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Adva)）\n### Nodejs（[nodejs](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Anodejs)、[egg](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Aegg)、koa）\n### [umi](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Aumi)\n### 体验度量和优化([performance](https://github.com/frontend9/fe9-library/issues?q=is%3Aissue+is%3Aopen+label%3Aperformance))\n### 可视化（antV）\n### Rxjs\n### ...\n\n\n']
GoogleLibraryVersionQuerier,一款Android Studio插件，帮助你快速添加依赖库和查询历史版本,1192,https://github.com/wuyr/GoogleLibraryVersionQuerier,master,['## 一款Android Studio插件，帮助你快速添加依赖库和查询历史版本\n>### 终于审核通过啦，现在可以直接在AS里检查更新了~\n### 特性：\n#### 1. 编辑build.gradle时，会有代码提示：\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/1.gif)\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/2.gif)\n\n<br/>\n\n#### 2. 光标定位到目标类库所在行，右键（快捷键『CTRL ALT Q』）可快速查看和替换某个版本：\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/3.gif) ![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/4.gif)\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/5.png)\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/6.png)\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/7.png)\n\n<br/>\n\n### 使用技巧:\n3.0版本支持了Maven、Jcenter仓库搜索，如果不加一些条件过滤的话，在编辑gradle文件时的代码提示可能会有很多名字相似的库，像这样：\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/9.png)\n\n遇到这种情况可以在前面加group(包名)关键词，格式如下：\n\n**group关键词(包名)**:**artifact关键词(仓库名)**\n\n示例：\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/10.png)\n\n可以看到过滤了group之后的搜索结果更精准了。\n\n<br/>\n\n### 安装：\n**在线安装：**\n\n*Android Studio -> Settings -> Plugins -> Marketplace*：<br/>搜索：***Google Library Version Querier***即可：\n\n![preview](https://github.com/wuyr/GoogleLibraryVersionQuerier/raw/master/previews/8.png)\n\n**本地安装：**\n\n到 [releases](https://github.com/wuyr/GoogleLibraryVersionQuerier/releases) 里下载最新 *GoogleLibraryVersionQuerier.zip* 后拖把它拖进Android Studio中并重启。\n\n<br/>\n\n### 数据来源：[wanandroid.com](https://wanandroid.com/maven_pom/index) ， [maven.aliyun.com](https://maven.aliyun.com/mvn/view)\n### 感谢[鸿神](https://www.wanandroid.com/)提供技术支持\n\n<br/>\n\n### 更新日志:\n\n - **3.3** 修复兼容性问题，现最低兼容到AndroidStudio3.0；优化体验：右键菜单选项『Query available versions』只在编辑.gradle文件时显示；『Query available versions』的快捷键改为『CTRL ALT Q』，因原来的『ALT Q』与其他快捷键有冲突；\n\n - **3.2** 优化查询，彻底修复编辑gradle文件卡顿的问题；查询可用版本改为倒序排序；加入监听ESC键关闭版本选择对话框。\n\n - **3.1** 修复键入任何字符和在任何文件下也会弹提示的Bug，加入限制:只有在.gradle文件中的dependencies作用域内才会搜索仓库。\n\n - **3.0** 支持Maven、Jcenter仓库搜索，支持所有.gradle文件，英文提示改成中文(想想都是国人用，就不整英文了)。\n\n - **2.1** 修复请求多次接口Bug。 \n\n - **2.0** 加入编辑build.gradle文件时的代码提示和支持搜索历史版本。\n\n - **1.0** 完成搜索和替换Google官方依赖库最新版本。\n     \n']
RootTools,RootTools Library,1493,https://github.com/Stericson/RootTools,master,['# RootTools\nRootTools Library\n']
emojilib,Emoji keyword library.,1510,https://github.com/muan/emojilib,main,['# emojilib ![CI status](https://github.com/muan/emojilib/workflows/Test%20dataset/badge.svg?branch=main) [![npm](https://img.shields.io/npm/dt/emojilib.svg?style=flat-square&colorB=fd7463)](https://www.npmjs.com/package/emojilib) [![JavaScript Standard Style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat-square&colorB=f1d04a)](https://github.com/feross/standard)\n\nMake emoji searchable with this keyword library.\n\n## Install\n\n```\nnpm install emojilib --save\n```\n\n## Usage\n\n```javascript\n> require("emojilib")\n{\n  \'😀\': [\n    \'grinning_face\',\n    \'face\',\n    \'smile\',\n    \'happy\',\n    \'joy\',\n    \':D\',\n    \'grin\'\n  ],\n  \'😃\': [\n    \'grinning_face_with_big_eyes\',\n    \'face\',\n    \'happy\',\n    \'joy\',\n    \'haha\',\n  ...\n}\n```\n\nIf you are looking for the unicode emoji dataset, including version, grouping, ordering, and skin tone support flag, check out [`unicode-emoji-json`](https://github.com/muan/unicode-emoji-json).\n\n## Migrating from 2.x\n\n\nPreviously:\n\n```js\n> var emoji = require("emojilib")\n> emoji.lib\n{\n  "grinning": {\n    "keywords": ["face", "smile", "happy", "joy"],\n    "char": "😀",\n    "fitzpatrick_scale": false,\n    "category": "people"\n  },\n  ...\n}\n```\n\nNow, merge keywords with other metadata from `unicode-emoji-json`:\n\n```js\n> var data = require(\'unicode-emoji-json\')\n> var keywordSet = require(\'emojilib\')\n> for (const emoji in data) {\ndata[emoji][\'keywords\'] = keywordSet[emoji]\n}\n> data[\'😀\']\n{\n  name: \'grinning face\',\n  slug: \'grinning_face\',\n  group: \'Smileys & Emotion\',\n  emoji_version: \'1.0\',\n  unicode_version: \'1.0\',\n  skin_tone_support: false,\n  keywords: [ \'grinning_face\', \'face\', \'smile\', \'happy\', \'joy\', \':D\', \'grin\' ]\n}\n```\n\n---\n\nPreviously:\n\n```js\n> var emoji = require("emojilib")\n> emoji.ordered\n[ \'grinning\', \'grimacing\', \'grin\', \'joy\', \'smiley\', \'smile\', \'sweat_smile\', ...]\n```\n\nNow this data can be found in `unicode-emoji-json`:\n\n```js\n> var orderedEmoji = require(\'unicode-emoji-json/data-ordered-emoji\')\n[\'😀\', \'😃\', \'😄\', \'😁\', \'😆\', \'😅\',...]\n```\n\n---\n\nPreviously:\n\n```js\n> var emoji = require("emojilib")\n> emoji.fitzpatrick_scale_modifiers\n[ \'🏻\', \'🏼\', \'🏽\', \'🏾\', \'🏿\' ]\n```\n\nNow this data can be found in `unicode-emoji-json`:\n\n```js\n> require(\'unicode-emoji-json/data-emoji-components\')\n{\n  light_skin_tone: \'🏻\',\n  medium_light_skin_tone: \'🏼\',\n  medium_skin_tone: \'🏽\',\n  medium_dark_skin_tone: \'🏾\',\n  dark_skin_tone: \'🏿\',\n  red_hair: \'🦰\',\n  curly_hair: \'🦱\',\n  white_hair: \'🦳\',\n  bald: \'🦲\'\n}\n```\n\nPreviously:\n\n```js\n> require("emojilib").lib[\'v\'].fitzpatrick_scale\ntrue\n\n> require("emojilib").lib[\'turtle\'].fitzpatrick_scale\nfalse\n```\n\nNow this data can be found in `unicode-emoji-json`:\n\n```js\n> require(\'unicode-emoji-json\')[\'✌️\'].skin_tone_support\ntrue\n> require(\'unicode-emoji-json\')[\'🐢\'].skin_tone_support\nfalse\n```\n\n## Development\n\nSee `CONTRIBUTING.md`.\n']
Monocle,Optics library for Scala,1568,https://github.com/optics-dev/Monocle,master,['![Monocle Logo](https://raw.github.com/optics-dev/Monocle/master/logo/full-logo/m-transparent-color-file.png)<br>\n\nAll documentation is available on [Monocle](https://www.optics.dev/Monocle/) website.\n']
live2d-widget-models,The model library for live2d-widget.js,1288,https://github.com/xiazeyu/live2d-widget-models,master,["# live2d-widget-models\n\nThe storage of live2d models\n\n## Useage\n\n### Install all models\n~~use `npm install live2d-widget-models`~~\n**PLEASE INSTALL MANUALLY, THIS PACKAGE IS DEPRECATED BECAUSE IT WON'T ADD DEPENDENCIES ON YOUR PRODUCTION ENVIRONMENT.**\n\n### Install seperated models\nuse `npm install {packagename}`\nThe package name is the folder name in `packages/`\nWe have:\n\n- `live2d-widget-model-chitose`\n- `live2d-widget-model-epsilon2_1`\n- `live2d-widget-model-gf`\n- `live2d-widget-model-haru/01` (use `npm install --save live2d-widget-model-haru`)\n- `live2d-widget-model-haru/02` (use `npm install --save live2d-widget-model-haru`)\n- `live2d-widget-model-haruto`\n- `live2d-widget-model-hibiki`\n- `live2d-widget-model-hijiki`\n- `live2d-widget-model-izumi`\n- `live2d-widget-model-koharu`\n- `live2d-widget-model-miku`\n- `live2d-widget-model-ni-j`\n- `live2d-widget-model-nico`\n- `live2d-widget-model-nietzsche`\n- `live2d-widget-model-nipsilon`\n- `live2d-widget-model-nito`\n- `live2d-widget-model-shizuku`\n- `live2d-widget-model-tororo`\n- `live2d-widget-model-tsumiki`\n- `live2d-widget-model-unitychan`\n- `live2d-widget-model-wanko`\n- `live2d-widget-model-z16`\n\n## Releated projects\n\n- [live2d-widget.js](https://github.com/xiazeyu/live2d-widget.js)\n\n- [hexo-helper-live2d](https://github.com/EYHN/hexo-helper-live2d)\n"]
